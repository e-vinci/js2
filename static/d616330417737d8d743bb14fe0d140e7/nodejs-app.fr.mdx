---
title: "Node.js app"
description: "Introduction aux applications backend Nodes.js & Express"
---

# f) Introduction aux applications backend en Nodes.js & Express

<InternalPageMenu>
  <PathViewer>
    <PathViewerItem to="/"> web2course </PathViewerItem>
    <PathViewerItem to="/part0"> Partie 0 </PathViewerItem>
    <PathViewerItem selected> f) Node.js </PathViewerItem>
  </PathViewer>
  <InternalPageMenuItem> C'est quoi une application backend ? </InternalPageMenuItem>
  <InternalPageMenuItem> Node.js c'est quoi ? </InternalPageMenuItem>
  <InternalPageMenuItem> O√π mettre du code TS dans une application Node.js ? </InternalPageMenuItem>
  <InternalPageMenuItem> Introduction aux packages Node.js & npm </InternalPageMenuItem>
  <InternalPageMenuItem> Express c'est quoi ? </InternalPageMenuItem>
  <InternalPageMenuItem> Cr√©er une application Express "from scratch" </InternalPageMenuItem>
  <InternalPageMenuItem> Cr√©er une application Express via un g√©n√©rateur </InternalPageMenuItem>
  <InternalPageMenuItem> üç¨ Les modules CommonJS </InternalPageMenuItem>
</InternalPageMenu>

Si vous n'avez jamais d√©velopp√© d'application backend en TS, nous vous recommandons de r√©aliser cette partie du cours attentivement.

# <InternalPageTitle> C'est quoi une application backend ? </InternalPageTitle>
## Frontend, backend, c'est quoi ?
Un **frontend**, c'est une application :
- qui s'ex√©cute c√¥t√© client, une IHM (Interface Homme-Machine), qu'on pourrait aussi appeler UI (User Interface) ;
- qui est en direct interaction avec l'utilisateur ;
- impl√©ment√©, dans ce cours-ci, en HTML / CSS / TS.

Un **backend**, c'est une application :
- qui s'ex√©cute c√¥t√© serveur ; 
- qui n'offre pas d'interaction directe avec l'utilisateur ;
- qui parfois met √† disposition le **frontend** ;
- qui parfois offre des op√©rations sur des donn√©es ;
- impl√©ment√© dans ce cours-ci en Node.js.

## R√¥les principaux du backend
### Fourniture du frontend
Un des r√¥les du backend est de fournir le frontend :
- **via un serveur de fichiers statiques** ; c'est la mise √† disposition des assets : fichiers HTML, CSS, JS, images...
- **via la g√©n√©ration dynamique de pages HTML** ; c'est ce qui se passe quand le backend fait du Server Side Rendering (SSR), g√©n√©ralement dans le cadre de Multi Page Applications.  

Dans le cadre de ce cours, nous ne ferons pas de g√©n√©ration dynamique d'HTML c√¥t√© serveur (ou SSR).  

### Fourniture d'op√©rations sur des ressources
Un autre r√¥le important du backend est de mettre √† disposition des op√©rations sur des ressources, c'est ce qu'on appelle les services web ou web API.

Il existe diff√©rents types de technologies et architectures web permettant d'impl√©menter des web services, notamment :
- **RESTful API** ; c'est l'architecture qui actuellement est la plus utilis√©e et qui sera apprise dans le cadre de ce cours.
- **GraphQL API** ; c'est une technologie r√©cente qui permet de tr√®s rapidement cr√©er des requ√™tes sur des ressources et qui a √©t√© cr√©√©e par Facebook ; nous ne verrons pas cette technologie dans le cadre de ce cours.
- **SOAP API** ; c'est une fa√ßon ancienne de cr√©er des op√©rations sur des ressources mettant en oeuvre de l'XML pour communiquer entre des applications clients / serveurs. Nous ne verrons pas cette technologie dans le cadre de ce cours.

### Autres r√¥les du backend ?
Un backend peut offrir d'autres services, comme :
- **proxy** : interm√©diaire entre les clients demandant une ressource et le serveur fournissant cette ressource. On verra ce type de service, notamment pour masquer l'origine d'une requ√™te √† une API.
- **reverse proxy** : c'est un serveur qui fait l'interm√©diaire avec d'autres serveurs, cachant au client qui est le v√©ritable serveur ayant trait√© sa requ√™te. Par exemple, un proxy serveur peut mettre √† disposition des acc√®s √† des serveurs interne √† une entreprise (non visibles sur le web) alors que le client interroge un serveur qui est visible sur le web.
- **serveur d'emails** ;
- ...

# <InternalPageTitle> Node.js c'est quoi ? </InternalPageTitle>

Node.js est un environnement serveur open source permettant la cr√©ation d'outils et applications c√¥t√© serveur en JS.  
Node.js offre une utilisation optimale des ressources des serveurs sans d√©pendance √† un serveur http externe, tout en √©tant multiplateforme (Windows, Linux, Mac‚Ä¶).

Pour le d√©veloppement d'IHM de fa√ßon modernes, vous avez d√©j√† install√© l'environnement Node.js. Mais si ce n'est pas install√©, il est important que vous installiez l'environnement [Node.js en version LTS](https://nodejs.org/en/) [[R.34]](/references/#r34).

üí≠ Mais je souhaite d√©velopper des applications en TS. Comment vais-je utiliser l'environnement Node.js pour faire du TS ?  
Lors de notre d√©veloppement, nous allons utiliser un outil permettant de transpiler du TS en JS, c'est √† dire de transformer du TS en JS.

# <InternalPageTitle> O√π mettre du code TS dans une application Node.js ? </InternalPageTitle>
## Directement dans un terminal
Il est possible d'√©crire du code Node.js directement dans un terminal.

Pour rappel, nous vous conseillons d'utiliser Git Bash comme terminal au sein de VS Code. 

Vous devriez d√©j√† avoir configur√© VS Code pour avoir comme Terminal par d√©faut 
Git Bash. Si ce n'est pas fait, nous vous rappelons la proc√©dure :
- Vous devez avoir install√© Git sur votre machine.
- Cliquez √† droite du **+** au sein d'un terminal ouvert dans VS Code, clic sur **Select Default Profile**, puis s√©lectionnez "Git Bash". Tous les prochains terminaux que vous ouvrirez le seront sous Git Bash, nettement plus color√© et int√©ressant que les autres terminaux üòé.

<ScrollableImage name="terminal-2.png" minWidth="933px" maxWidth="933px" />

<figcaption>Choix du terminal par d√©faut</figcaption>

Veuillez tester du code Node.js directement dans un terminal en tapant cela au sein d'un terminal de VS Code :

```bash
node
```

Vous avez maintenant acc√®s au terminal de Node.js.  
Vous pouvez tenter une op√©ration math√©matique de votre choix, comme par exemple : **`2 * Math.PI`**

Quand vous souhaitez sortir de l'interpr√©teur de commandes de Nodes, il faut taper :
- soit deux fois **`CTRL c`** ;
- soit **`CTRL d`**.

## Dans un script
Nous √©crivons g√©n√©ralement le code Node.js au sein d'un script externe.

Nous allons utiliser `ts-node` pour ex√©cuter directement des fichiers TypeScript sans les compiler manuellement en JavaScript au pr√©alable. 

`ts-node` :
- utilise le compilateur TypeScript pour transpiler le code TypeScript en JavaScript.
- une fois le code transpil√©, `ts-node` utilise Node.js pour ex√©cuter le JavaScript r√©sultant.

Pour lancer un script en TS √† l'aide de `ts-node` (et de Node.js indirectement), il suffit de taper dans un terminal : `npx ts-node nomScript`.


`npx` est un outil de Node.js qui permet d'ex√©cuter des paquets npm sans les installer globalement, en les installant temporairement si n√©cessaire, simplifiant ainsi l'ex√©cution de scripts et commandes de projets.


Dans votre repo **web2**, veuillez cr√©er un r√©pertoire **`/tutorials/ts-node-start`** et y ajouter le fichier **index.ts** contenant ce code-ci :

```ts
const dacia= {
  brand: "Dacia",
  model: "Sandero",
  id: undefined,
  getDescription: function () {
    return `${this.id} ${this.brand} ${this.model}`;
  },
};

console.log(dacia.getDescription());

dacia.id = Math.random();

console.log(dacia.getDescription());
```

Pour lancer le script cr√©√© ci-dessus, veuillez ouvrir un terminal au bon endroit.  
Pour rappel, Il est possible de faire un clic droit dans l'Explorer de VS Code sur le r√©pertoire `ts-node-start`, `Open in Integrated Terminal` pour ouvrir un terminal √† l'endroit souhait√©.

Il ne vous reste plus qu'√† taper :

```bash
npx ts-node ./index # or node ./index.ts
```

Nous avons une erreur √† l'ex√©cution du script. En effet, l'inf√©rence automatique de type de TS a d√©fini `id` comme √©tant de type `undefined`, on ne peut donc lui r√©assigner un `Number`.

Il est int√©ressant de se rendre compte qu'en JS, on peut r√©assigner un type √† une variable, ce qui n'est pas possible en TS. N'h√©sitez donc pas √† ex√©cuter ce script √† l'aide de `node ./index.ts` pour voir le r√©sultat.

Revenons au TS. Nous allons donc d√©finir un type `Car` pour notre objet `dacia`, en indiquant que l'attribut `id` est de type `number | undefined` (soit un nombre, soit `undefined`). Voici le code modifi√© :

```ts
interface Car {
  brand: string;
  model: string;
  id: number | undefined;
  getDescription: () => string;
}

const dacia: Car = {
  brand: "Dacia",
  model: "Sandero",
  id: undefined,
  getDescription: function () {
    return `${this.id} ${this.brand} ${this.model}`;
  },
};

console.log(dacia.getDescription());

dacia.id = Math.random();

console.log(dacia.getDescription());
```

Ex√©cutez le script √† l'aide de `npx ts-node ./index` pour voir le r√©sultat.

Si votre application ne s'ex√©cute pas correctement et affiche un message du type : `To load an ES module, set "type": "module" in the package.json`, c'est que votre transpilateur TS n'a pas correctement transpil√© le code en JS. Il tente de g√©n√©rer un module ES6, au lieu de g√©n√©rer du code CommonJS (format d'une application Node.js). Pour r√©soudre ce probl√®me, veuillez ajouter un fichier `tsconfig.json` √† la racine de votre projet contenant :
  
  ```json
{
  "compilerOptions": {
    "target": "ES6",
    "outDir": "./build/",
    "module": "commonjs",
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true,
    "esModuleInterop": true,
    "resolveJsonModule": true
  }
}
  ```

Voil√†, c'est une simple application Node.js en TS qui affiche deux messages dans le terminal.

# <InternalPageTitle> Introduction aux packages Node.js & npm </InternalPageTitle>
## Introduction
Les concepts importants du gestionnaire de packages de Node.js sont r√©sum√©s ci-dessous.

## Gestionnaire de packages
**npm** est le gestionnaire de packages de Node.js. 

On peut faire des recherches de packages qui seraient utiles √† nos application web sur [npmjs.com](https://www.npmjs.com/) [[R.48]](/references/#r48).

## Fichier de configuration d'un projet
Tous les packages associ√©s √† une app, ses d√©pendances, sont donn√©es dans le fichier : **`package.json`**.

C'est le fichier qui d√©crit la configuration d'un projet JS.

On peut manuellement cr√©er ce fichier √† l'aide de la commande **`npm init`** si l'on souhaite quelque chose de plus interactif ou **`npm init -y`** si l'on souhaite un fichier avec le minimum autog√©n√©r√©.

Voici un exemple de fichier **`package.json`** :

```json
{
  "name": "api2",
  "version": "0.0.0",
  "private": true,
  "scripts": {
    "debug": "npm run dev",
    "dev": "nodemon ./bin/www",
    "start": "node ./bin/www",
    "lint": "eslint **/*.js",
    "lint:fix": "npm run lint -- --fix"
  },
  "nodemonConfig": {
    "ignore": [
      "data/*"
    ],
    "exec": "npm run lint && node"
  },
  "dependencies": {
    "cookie-parser": "~1.4.4",
    "debug": "~2.6.9",
    "express": "~4.16.1",
    "morgan": "~1.9.1"
  },
  "devDependencies": {
    "eslint": "^8.19.0",
    "eslint-config-airbnb-base": "^15.0.0",
    "nodemon": "^2.0.19",
    "prettier-airbnb-config": "^1.0.0"
  },
  "author": "e-Baron"
}
```

Lors de l'installation d'un package, celui-ci s'ajoute √† la liste des d√©pendances.  
Ainsi, si des d√©veloppeurs trouvent votre projet sur Git, ils n'auront qu'√† ex√©cuter **`npm i`** afin d'installer toutes les d√©pendances.

C'est dans le r√©pertoire **`node_modules`** que toutes les d√©pendances seront install√©es.  
Ces d√©pendances peuvent √™tre tr√®s volumineuses. C'est donc important de ne jamais mettre ce dossier sur vos web repository, via Git.  
Pour ce faire, n'oubliez pas d'inclure un fichier **`.gitignore`** dans vos repos pour ignore **`node_modules`**.

**`package.json`** indique les scripts de d√©marrage, en fonction de la fa√ßon dont nous souhaitons d√©marrer l'application.

```json
  "scripts": {
    "debug": "npm run dev",
    "dev": "nodemon ./bin/www",
    "start": "node ./bin/www",
    "lint": "eslint **/*.js",
    "lint:fix": "npm run lint -- --fix"
  },  
```

Au regard de cette configuration, on peut d√©marrer l'application √† l'aide de **`npm start`** ou **`npm run start`**, ce qui ex√©cutera le script **`./bin/www`** √† l'aide de **node**.  
On pourrait aussi d√©marrer l'application √† l'aide de **`npm run dev`**, ce qui d√©marrerait l'application √† l'aide de **`nodemon`**, un outil permettant de monitorer les changements de fichiers et de red√©marrer automatiquement le serveur en cas de changement.

## Installer un package
### G√©n√©ralit√©s
Pour installer un package (ou une d√©pendance), il suffit de faire : **`npm i nomDuPackage`** ou **`npm install nomDuPackage`**.

Pour installer une d√©pendance de d√©veloppement, qui ne sera pas install√©e lorsque nous d√©ploierons une version de production de notre application, tapez : **`npm i nomDuPackage -D`**.

Par exemple, **`nodemon`** est un package qui permet de red√©marrer le serveur √† chaque modification de fichier par les d√©veloppeurs. En production, l'application n'a pas besoin de ce package !

### Gestion des types lors de l'utilisation de TS

Attention, l'installation des types via **`npm i @types/nomDuPackage -D`** est souvent essentielle pour utiliser des packages JavaScript dans un projet TypeScript. 

Cette installation fournit les d√©finitions de types n√©cessaires pour que TypeScript comprenne la structure et les types des objets, fonctions, et classes dans le package. Cela permet √† l'√©diteur de code d'offrir l'auto-compl√©tion, la v√©rification de type, et des messages d'erreur pr√©cis lors du d√©veloppement. Ces types sont install√©s en tant que d√©pendances de d√©veloppement (**`-D`**), car ils ne sont n√©cessaires que pour le d√©veloppement, pas pour l'ex√©cution en production.

Par exemple pour utiliser **`uuid`** dans un projet TS (https://www.npmjs.com/package/uuid), il est important d'installer les d√©finitions de type pour ce package. Pour installer ce package :
```sh
npm i uuid
npm i @types/uuid -D
```

Certains packages, souvent ceux √©crits directement en TypeScript, incluent d√©j√† leurs propres d√©finitions de types dans leur code source. Dans ce cas, vous n'avez pas besoin d'installer **`@types/nomDuPackage`** s√©par√©ment.

Si vous ne savez pas si vous devez installer les d√©finitions de types pour un package, vous pouvez toujours essayer de l'utiliser sans les d√©finitions de types. Si vous obtenez des erreurs de compilation TypeScript, vous devrez installer les d√©finitions de types, et la fa√ßon de le faire sera indiqu√© dans les messages d'erreur (via **`Quick Fix...`**).

## D√©pendances install√©es
On a vu que **`npm i`** permet d'installer toutes les d√©pendances se trouvant dans **`package.json`**, ainsi que toutes les d√©pendances de ces d√©pendances...

L'arbre exact des d√©pendances install√©es, num√©ros de version..., se trouve dans **`package-lock.json`**. Ce fichier est g√©n√©r√© automatiquement pour chaque op√©ration modifiant **`node_modules`** ou **`package.json`**.

Le fichier **`package-lock.json`** est utilis√© pour verrouiller les versions des d√©pendances dans un projet Node.js, garantissant que les installations futures produisent exactement le m√™me arbre de d√©pendances, ce qui assure la consistance et la reproductibilit√© des builds.

‚ö° Si un fichier **`package-lock.json`** est compris dans un repo, lorsque vous introduirez **`npm i`** pour installer toutes les d√©pendances, npm installera les m√™mes versions que celles se trouvant dans **`package-lock.json`**. Cela peut poser des probl√®mes si votre environnement Node.js est en version diff√©rente. En cas de souci, pensez √† effacer le r√©pertoire **`node_modules`** et le fichier **`package-lock.json`** avant de relancer l'installation de toutes les d√©pendances.

## Localisation d'un module ou package par Node
Node va chercher dans tous les chemins sp√©cifi√©s dans la variable **`module.paths`** lorsque **`required()`** est appel√©. Les chemins cherch√©s sont par exemple : **`node_modules`**, **./**, ...

## Mise √† jour des packages vers leur derni√®re version
La mise √† jour de toutes les d√©pendances peut parfois amener √† des gros soucis.

Sans prendre trop de risques, vous pouvez tenter de mettre √† jour tous vos packages en suivant la documentation de npm :
[Updating packages downloaded from the registry](https://docs.npmjs.com/updating-packages-downloaded-from-the-registry) [[R.49]](/references/#r49).

Cela vous permettra de mettre √† jour vos packages, sans devoir changer la liste de vos d√©pendances qui est donn√©e dans **`package.json`**. S'il y a des d√©pendances qui ont des "breaking changes", ces versions ne seront pas install√©es.

Si vous souhaitez tous mettre √† jour d'un coup, vers la toute derni√®re version de chaque package, vous pouvez tentez le coup en utilisant la commande **`ncu`** du package [npm-check-updates](https://www.npmjs.com/package/npm-check-updates).  
Mais attention, certains packages subissent parfois des "breaking changes", ce qui impose que vous deviez faire migrer votre code avant que celui-ci soit fonctionnel.

Nous vous recommandons donc, si vous rencontrez un probl√®me lors de la mise √† jour de tous vos packages d'un coup √† l'aide de **`ncu`**, de revenir √† la situation initiale, et de faire l'upgrade de chaque package list√© dans **`package.json`** individuellement. Pour installer la derni√®re version d'un package, utilisez **`@latest`** :

```bash
npm i nomPackage@latest
```
# <InternalPageTitle> Express c'est quoi ? </InternalPageTitle>

Voici le moto du framework Express: "**Fast, unopinionated, minimalist web framework for Node.js**" [Express](https://expressjs.com/) [[R.50]](/references/#r50).

Express est un framework qui permet de rapidement cr√©er des applications en Node.js. 

Il est possible de cr√©er une application Express soit "from scratch", soit √† partir d'un boilerplate.

Dans le cadre de ce cours, nous allons plut√¥t utiliser des boilerplates pour g√©n√©rer des applications. N√©anmoins, il est int√©ressant de voir comment cr√©er une application "from scratch".

# <InternalPageTitle> Cr√©er une application Express "from scratch" </InternalPageTitle>

Il faut d'abord cr√©er un r√©pertoire pour votre application.

Au sein de votre repo **web2**, veuillez cr√©er le r√©pertoire **`/tutorials/back/express-static-file-server`**.

Veuillez, via le terminal, entrer dans ce r√©pertoire. Vous pouvez par exemple faire un clic droit sur sur le r√©pertoire **`/tutorials/back/express-static-file-server`** dans l'Explorer de VS Code, **`Open in Integrated Terminal`**.

Dans ce r√©pertoire, veuillez g√©n√©rer le fichier de configuration du projet (**`package.json`**) : **`npm init`**.  
Veuillez r√©pondre aux questions pour configurer le point d'entr√©e de l'application comme √©tant le script **`index.ts`**.

Veuillez configurer le script de d√©marrage de votre application en ajoutant cette ligne au sein de **`package.json`** :

```json highlighting="2"
  "scripts": {
    "start": "ts-node index.ts",
    //...
  }
```

Ainsi, notre application pourra d√©marrer √† l'aide de la commande **`npm start`**.

N√©anmoins, pour que cela fonctionne, il faut installer **`ts-node`**.
Veuillez installer **`ts-node`**, comme d√©pendance de d√©veloppement, √† l'aide de la commande suivante :
```bash
npm i ts-node -D
```

Il est √† noter que nous aurions pu installer **`ts-node`** de fa√ßon globale (**`npm i ts-node -g`**), mais nous pr√©f√©rons l'installer localement pour que les autres d√©veloppeurs qui travailleront sur ce projet puissent avoir la m√™me version de **`ts-node`**.

Il aurait aussi √©t√© possible de cr√©er une installation temporaire de **`ts-node`** √† l'aide de **`npx`** : **`npx ts-node index.ts`**.

A ce stade-ci, voil√† √† quoi devrait ressembler votre **`package.json`** :

```json
{
  "name": "express-static-file-server",
  "version": "1.0.0",
  "description": "",
  "main": "index.ts",
  "scripts": {
    "start": "ts-node index.ts",
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "yourName",
  "license": "ISC",
  "devDependencies": {
    "ts-node": "^10.9.2"
  }
}
```

Veuillez installer le package **`express`** : 

```bash
npm i express
```

Nous allons cr√©er un simple serveur de fichiers statiques √† l'aide du middleware **`express.static`**, afin de servir tous les fichiers qui se trouveront dans le r√©pertoire **`public`**.

Tout d'abord, t√©l√©chargez ce zip : <LinkFile name="public.zip" target="_blank" download>fichiers statiques</LinkFile>.

Veuillez d√©sarchiver ce r√©pertoire dans votre projet afin d'avoir les fichiers statiques qui seront partag√©s par votre serveur au sein de **`/public`**.   
V√©rifiez bien que vous n'avez qu'un seul r√©pertoire **`/public`** et pas un **`/public/public`**.

Nous allons cr√©er le serveur via un nouveau fichier **`/index.ts`** et y ajouter ce code :

```ts
import express from "express";

const app = express();

app.use(express.static("public"));

const PORT: number = 7777;

app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});
```

Veuillez tenter de lancer l'application en tapant cela dans votre terminal au sein du r√©pertoire du projet :

```bash
npm start
```

Vous rencontrerez l'erreur `"Could not find a declaration file for module 'express'"` parce que TypeScript ne peut pas trouver les d√©finitions de type n√©cessaires pour Express. Cela emp√™che TypeScript de conna√Ætre les types et les signatures des fonctions d'Express, ce qui invalide les b√©n√©fices du typage statique et de l'autocompl√©tion dans l'IDE. Ainsi, la compilation √©choue.

Pour r√©soudre ce probl√®me, nous devons simplement installer les d√©finitions de type pour Express : 

```bash
npm i @types/express -D
```

Veuillez lancer l'application en tapant cela dans votre terminal au sein du r√©pertoire du projet :

```bash
npm start
```

Pour acc√©der au serveur de fichiers, vous pouvez le faire via un browser : [http://localhost:7777](http://localhost:7777)

Si tout se passe bien, vous devriez avoir acc√®s au site de la pizzeria que nous d√©couvrirons plus tard dans ce cours.

On voit que juste cette ligne permet la mise en place d'un serveur de fichier statique, via le middleware **`express.static`** :

```js
app.use(express.static('public'));
```

Et pour d√©marrer un serveur web qui √©coute sur le port **7777**, ces lignes sont suffisantes :
```js
app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});
```

En cas de souci, vous pouvez acc√©der au code de ce tutoriel ici :
[express-static-file-server](https://github.com/e-vinci/ts-demos/tree/main/back/express-static-file-server/).


# <InternalPageTitle> Cr√©er une application Express via un g√©n√©rateur </InternalPageTitle>

Le g√©n√©rateur d'applications **`express-generator`** permet de g√©n√©rer le boilerplate d'une application Express de base. 

Malheureusement, ce g√©n√©rateur ne permet pas de g√©n√©rer une application en TypeScript. Nous avons donc choisi pour ce cours de cr√©er pour vous un boilerplate de base d'une application Express en TypeScript et de ne pas utiliser le g√©n√©rateur **`express-generator`**.

Si vous le souhaitez, vous pouvez passer √† la [Partie 1 : Cr√©ation de services web](../../part1).

 # <InternalPageTitle> üç¨ Les modules CommonJS </InternalPageTitle>
## Introduction
Un module est une librairie TS ou JS fournissant des objets.  
Comme en TS/JS tout est objet, un module met donc √† disposition des fonctions, des constantes, des variables...

Tr√®s souvent, Node.js est cod√© en JS conforme au standard **`CommonJS`**. La majorit√© des exemples que vous trouverez sur le web pour des applications Express seront en **`CommonJS`**.
C'est pourquoi, m√™me si ce cours se veut plus moderne en utilisant du TS, nous vous proposons optionnellement de voir comment fonctionne les modules en **`CommonJS`** dans ce chap√Ætre. Si vous pr√©f√©rez, vous pouvez passer directement √† la section suivante : [Introduction aux packages Node.js & npm](#introduction_aux_packages_node_js_npm).

Nous vous rappelons que pour ce cours-ci, nous utiliserons du TS et les modules **`ES6`** comme vu dans l'[introduction au modules](../js-language/#les_modules_es_6); les modules en **`CommonJS`** ne seront pas utilis√©s dans ce cours-ci.

## Cr√©ation d'un module
Pour cr√©er un module, il suffit de cr√©er un script JS **nomModule.js** et d'exporter des objets au sein de ce module via **module.exports** ou **exports**.

## Exporter des objets
### Introduction
Il existe plusieurs fa√ßons d'exporter des objets, soit √† la vol√©e, soit √† la fin d'un script.

üëç Nous vous recommandons de faire vos exports √† la fin du script, cela rend les scripts plus lisibles. 

Nous allons n√©anmoins voir toutes les fa√ßons d'exporter des objets en CommonJS, car vous trouverez de tout sur le web.

**On exporte toujours un seul objet principal dans un module**. Cet objet peut bien s√ªr contenir une multitude d'objets via ses propri√©t√©s.

### Export √† la fin d'un script
C'est la fa√ßon la plus propre d'exporter un seul objet :

```js
module.exports¬†=¬†router;
```

C'est l'√©quivalent d'un "default export" tel qu'il sera vu en ECMAScript.

S'il y a plusieurs objets √† exporter, voici la fa√ßon recommand√©e de le faire : 

```js
module.exports¬†=¬†{authorize,¬†users¬†};
```

C'est l'√©quivalent d'un "Named export" tel qu'il sera vu en ECMAScript.

### Export √† la vol√©e

Il est possible de faire des exports √† la vol√©e, c'est √† dire d'exporter des objets au fur et √† mesure qu'ils sont initialis√©s.

Voici la version longue :

```js
module.exports.authorize¬†=¬†authorize;
module.exports.users¬†=¬†users¬†;
```

Il est aussi possible d'√©courter une export √† la vol√©e : 
```js
exports.authorize¬†=¬†authorize;
exports.users¬†=¬†users¬†;
```

Voici quelques pr√©cisions :
- **`module.exports`** : c'est la r√©f√©rence de l'objet retourn√©e par l'appel de **`required()`** (m√©thode qui sera utilis√©e pour l'import).
- **`exports`** : c'est la r√©f√©rence vers **`module.exports`**, **`exports`** n'est pas retourn√© par l'appel de **`required()`**.

‚ö° Il faut faire attention au mauvais usage de l'utilisation de **`exports`**.  
Voici une mauvaise utilisation :

```js
exports¬†=¬†{¬†authorize,¬†users¬†};¬†/*¬†exports¬†has¬†a¬†new¬†reference,¬†
                                   it¬†is¬†no¬†longer¬†linked¬†to¬†module.exports */
```

## Importer des objets
### Introduction
Pour utiliser des objets (fonctions, constantes, objets, classes...) au sein d'un script JS provenant de modules, on le fait √† l'aide de la fonction **`required()`** et du chemin vers le module √† utiliser.

Il est possible d'importer tant des objets de modules que l'on a cr√©√© soi-m√™me, que de packages mis √† disposition via un gestionnaire de packages.

### Import d'un module
Lorsqu'un seul objet a √©t√© export√©, on l'importe en lui donnant le nom que l'on souhaite √† l'import et en indiquant le chemin vers le module √† utiliser.

```js
const¬†pizzaRouter¬†=¬†require('./routes/pizzas');
```

Lorsque plusieurs objets ont √©t√© export√©s, on importe ce que l'on souhaite en utilisant des accolades et en indiquant le chemin vers le module √† utiliser.

```js
const¬†{¬†users,¬†authorize¬†}¬†=¬†require('../utils/auths');
```

### Import d'un package
Il est aussi possible d'importer des objets de packages offerts par la communaut√©.
Pour ce faire, il est juste n√©cessaire d'indiquer le nom du package lors de l'import.

Si un seul objet est export√© par un package, voici un exemple de comment le r√©cup√©rer :

```js
//¬†module¬†integrated¬†to¬†the¬†runtime¬†environment
const¬†http¬†=¬†require('http');
// module used after package installation
const¬†shortid¬†=¬†require('shortid');
```