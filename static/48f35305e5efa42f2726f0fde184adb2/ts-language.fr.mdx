---
title: 'Language TS'
description: 'Introduction au langage TypeScript, apprentissage de la syntaxe'
---

# c) Introduction au TS

<InternalPageMenu>
  <PathViewer>
    <PathViewerItem to="/"> web2course </PathViewerItem>
    <PathViewerItem to="/part0" > Partie 0 </PathViewerItem>
    <PathViewerItem selected> c) TS </PathViewerItem>
  </PathViewer>
  <InternalPageMenuItem> Le TS, c'est quoi ? </InternalPageMenuItem>
  <InternalPageMenuItem> A quel moment le TS intervient ? </InternalPageMenuItem>
    <InternalPageMenuItem> Quand d√©finir les types ? </InternalPageMenuItem>
<InternalPageMenuItem> Comment d√©finir les types ? </InternalPageMenuItem> 
  <InternalPageMenuItem> Comment contr√¥ler le flux en TS ? </InternalPageMenuItem> 
  <InternalPageMenuItem> R√©duction de type plus avanc√©e </InternalPageMenuItem> 
  <InternalPageMenuItem> Comment en savoir plus sur TS ? </InternalPageMenuItem> 

</InternalPageMenu>

# <InternalPageTitle> Le TS, c'est quoi ? </InternalPageTitle>

 **Le TypeScript est du JavaScript avec des types**. Ainsi, toute la syntaxe d√©crite dans l'[introduction du JS](../js-language) est valable pour le TS.

Le TS s'√©crit tant dans un browser que dans un environnement serveur.  
On √©crira du TS conforme au standard que l'on souhaite voir associ√© √† JS : **`ECMAScript`**, **`CommonJS`**...

Comme le monde de l'entreprise va de plus en plus vers `ECMAScript 6` (ou `ES6`), nous avons choisi `ECMAScript` comme standard pour ce cours.

Nous allons voir dans cette partie les sp√©cificit√©s utiles du TS.

Notons que le TS permet d'am√©liorer l'orient√© objet en JS, mais nous ne verrons pas ces aspects dans ce cours sauf pour quelques exceptions. Nous estimons que le d√©veloppement web moderne ne n√©cessite pas de ma√Ætriser l'orient√© objet en JS ; il nous semble plus int√©ressant de faire de la programmation fonctionnelle, tout en manipulant des objets et des types.

# <InternalPageTitle> A quel moment le TS intervient ? </InternalPageTitle>

En TypeScript, l'intervention se fait principalement au moment de la **transpilation** (on parle aussi de compilation par abus de langage) :
- **Type Checking**: TypeScript intervient lors de la transpilation, v√©rifiant les types et s'assurant que le code respecte les d√©finitions de types fournies. Cela permet de d√©tecter les erreurs de type avant l'ex√©cution. 
- **Type Safety** : TypeScript aide √† maintenir la s√©curit√© des types en obligeant √† d√©finir des types pr√©cis pour les variables, les fonctions, etc. Cela √©vite l'utilisation du type `any`, qui d√©sactive les v√©rifications de type, et r√©duit les risques d'erreurs li√©es aux pointeurs nuls (null pointers).
- Le code TypeScript est transpil√© en JavaScript. Les annotations de type sont supprim√©es et le **code r√©sultant est du pur JavaScript**.

Il y a d'autres aspects importants o√π TypeScript peut intervenir, principalement : 
- **Intellisense** : Les √©diteurs de code et IDE qui supportent TypeScript (comme Visual Studio Code) utilisent les informations de type pour fournir des suggestions de code, auto-compl√©ter les noms de variables et de fonctions, et offrir des informations sur les signatures de fonctions.
- **Erreurs en temps r√©el** : Pendant l'√©criture du code, les √©diteurs peuvent afficher des erreurs de type en temps r√©el, avant m√™me que le code ne soit compil√©.
- **Documentation** : Les annotations de type servent de documentation vivante, aidant les d√©veloppeurs √† comprendre les interfaces et les attentes des fonctions.
- **Refactoring** : Les outils de refactoring utilisent les informations de type pour effectuer des transformations de code de mani√®re s√©curis√©e (comme par exemple le `Quick Fix...` de VS Code).
- **Linting** : Les outils comme ESLint utilisent les types pour imposer des r√®gles de style et de bonnes pratiques de code.
- **Tests** : Les frameworks de tests peuvent utiliser les types pour g√©n√©rer des cas de test ou v√©rifier les types des donn√©es manipul√©es.
- **Runtime (indirectement)** : M√™me si TypeScript ne v√©rifie pas les types √† l'ex√©cution, les d√©veloppeurs peuvent utiliser des gardes de type (type guards) et des assertions pour v√©rifier les types √† l'ex√©cution, ce qui ajoute une couche suppl√©mentaire de s√©curit√©.

# <InternalPageTitle> Quand d√©finir les types ? </InternalPageTitle>

## Introduction

Pour maintenir la s√©curit√© des types, il est important d'√©viter que TypeScript inf√®re le type `any` pour les variables, les fonctions, les param√®tres, etc.

Il y a beaucoup de cas o√π TS est capable d'inf√©rer le type d'une variable, d'une fonction, etc. sans que l'on ait besoin de le sp√©cifier explicitement. 

## Cas o√π il est inutile de sp√©cifier le type

üëç Lorsque l'inf√©rence de type est claire et √©vidente, ou lorsque l'annotation (de type) n'apporte pas de valeur ajout√©e significative en termes de lisibilit√© ou de documentation, il n'est pas recommand√© de sp√©cifier le type explicitement. Cela peut rendre le code plus verbeux et moins lisible.

Voici quelques exemples o√π il est inutile de sp√©cifier le type :
  
  ```ts 
  const x = 10; // TypeScript inf√®re que x est de type number
  const y = 'hello'; // TypeScript inf√®re que y est de type string
  const z = [1, 2, 3]; // TypeScript inf√®re que z est de type number[]

  function greet(name: string) { 
    return `Hello, ${name}!`; // Le type string est √©vident ici
  }
  ```

## Cas o√π il est important de sp√©cifier le type

### Type Checking

üëç Il est recommand√© de sp√©cifier le type lorsque TypeScript ne peut pas inf√©rer le type correctement, ou lorsque l'inf√©rence de type peut entra√Æner des erreurs potentielles difficiles √† d√©tecter.

Voici un exemple concret o√π il est recommand√© de sp√©cifier le type :

  ```ts
  let value; // TypeScript inf√®re que value est de type any

function setValue(newValue) { 
    value = newValue; 
}

setValue(42);

// Plus tard dans le code
console.log(value.toFixed(2)); // Erreur √† la compilation/transpilation : toFixed n'est pas une fonction sur type 'any'
  ```

TypeScript d√©tectera l'erreur lors de la transpilation/compilation, car value est de type `any` et n'a pas de m√©thode `toFixed`.
C'est l'√©diteur de code qui indiquera cette erreur avant que le code ne soit transpil√© en JavaScript.

Pour √©viter ce probl√®me, voici comment on peut sp√©cifier le type de `value` :

```ts
let value: number;

function setValue(newValue: number) {
    value = newValue;
}

setValue(42);

// Maintenant, TypeScript sait que value est de type number
console.log(value.toFixed(2)); // Correct : affiche '42.00'
```

En sp√©cifiant `value` comme √©tant de type `number`, TypeScript peut v√©rifier statiquement que les op√©rations ult√©rieures sur `value` (comme `toFixed(2)`) sont appropri√©es et √©viter les erreurs potentielles qui seraient r√©v√©l√©es √† l'ex√©cution.

### Documentation & lisibilit√©

üëç Pour l'aspect documentation et lisibilit√©, il est recommand√© de sp√©cifier le type des param√®tres de fonction. Concernant les valeurs de retour, m√™me si TypeScript peut les inf√©rer correctement, il est conseill√© de sp√©cifier le type de retour lorsque le corps de la fonction est volumineux. Cela rend le code plus explicite et aide les autres d√©veloppeurs √† comprendre comment utiliser la fonction sans avoir √† lire son impl√©mentation.

Voici un exemple d'une fonction assez volumineuse o√π il est recommand√© de sp√©cifier le type de retour :

```ts
function processData(data: string[]): { averageLength: number, maxLength: number } {
    let totalLength = 0;
    let maxLength = 0;

    for (let item of data) {
        totalLength += item.length;
        if (item.length > maxLength) {
            maxLength = item.length;
        }
    }

    const averageLength = data.length > 0 ? totalLength / data.length : 0;

    return { averageLength, maxLength };
}
```
En sp√©cifiant le type de retour `{ averageLength: number, maxLength: number }`, on documente clairement que la fonction processData produit un objet avec ces deux propri√©t√©s. Cela rend le code plus explicite et facilite la compr√©hension pour les autres d√©veloppeurs qui utilisent ou maintiennent cette fonction.

### Maintenabilit√© 

üëç Dans le cas o√π le type de retour est complexe ou utilis√© √† plusieurs endroits dans le code, il est int√©ressant de d√©finir une interface ou un type pour ce type de retour. Cela permet de r√©utiliser le type de retour dans d'autres parties du code et de garantir la coh√©rence des types. 

Voici ce que √ßa donnerait pour notre exemple :
  
  ```ts
  interface DataProcessingResult {
    averageLength: number;
    maxLength: number;
}

function processData(data: string[]): DataProcessingResult {
    let totalLength = 0;
    let maxLength = 0;

    for (let item of data) {
        totalLength += item.length;
        if (item.length > maxLength) {
            maxLength = item.length;
        }
    }

    const averageLength = data.length > 0 ? totalLength / data.length : 0;

    return { averageLength, maxLength };
}
  ```
  
En d√©finissant l'interface `DataProcessingResult`, on peut r√©utiliser ce type de retour dans d'autres parties du code, ce qui rend le code plus maintenable et √©vite les erreurs de type.

# <InternalPageTitle> Comment d√©finir les types ? </InternalPageTitle>

Il existe plusieurs fa√ßons de d√©finir des types en TypeScript. Voici les principales m√©thodes :

## Les annotations de type

Les annotations de type sont des instructions qui indiquent au compilateur TypeScript le type d'une variable, d'un param√®tre de fonction, d'une valeur de retour, etc. Les annotations de type sont plac√©es apr√®s le nom de la variable, du param√®tre ou de la fonction, suivies de deux points **`:`** et du type souhait√©.

Voici quelques exemples d'annotations de type :

```ts
let x: number; // x est de type number
let y: string; // y est de type string
let z: number[]; // z est de type number[]
const numbers: number[] = [1, 2, 3]; // numbers est de type number[]
let isActive: boolean; // isActive est de type boolean
let greet: (name: string) => string; 
// greet est une fonction qui prend un param√®tre de type string et retourne une valeur de type string
const person: { name: string, age: number } = { name: "Alice", age: 30 };
```

## Les interfaces

Les interfaces sont des contrats qui d√©finissent la structure des objets en TypeScript. Elles permettent de d√©finir des types personnalis√©s pour les objets, les fonctions, les classes, etc. Les interfaces sont largement utilis√©es pour d√©finir des types complexes et r√©utilisables.

Voici un exemple d'interface pour d√©finir un type de donn√©es :

```ts
interface Person {
    readonly id: number; // Propri√©t√© en lecture seule
    name: string;
    age: number;
    email?: string; // Propri√©t√© optionnelle
}

const alice: Person = { id:1, name: "Alice", age: 30 };
const bob: Person = { id:2, name: "Bob", age: 25, email: "bob@vinci.be" };

// Tentative de modification d'une propri√©t√© en lecture seule (erreur)
// alice.id = 3; // Erreur: Cannot assign to 'id' because it is a read-only property.
```

Notons qu'une interface peut √©tendre un type d√©fini ou une autre interface. Voici un exemple d'interface qui √©tend un type d√©fini:
  
  ```ts
  type Employee = { // fonctionne aussi avec une interface (interface Employee { ... })
    name: string;
    age: number;
};

interface Manager extends Employee {
    department: string;
    manageTeam(): void;
}

const manager: Manager = {
    name: "Bob",
    age: 35,
    department: "HR",
    manageTeam() {
        console.log("Managing team...");
    }
};
  ```

## Les types

Les types sont similaires aux interfaces, mais ils peuvent √©galement √™tre utilis√©s pour d√©finir des types primitifs, des unions, des intersections, des tuples, etc. 

Voici un exemple de type pour d√©finir un type de donn√©es :

```ts
type Person = {
    name: string;
    age: number;
    email?: string; // Propri√©t√© optionnelle
    readonly id: number; // Propri√©t√© en lecture seule
}

const person: Person = {
    name: "Alice",
    age: 30,
    id: 1
    // email est optionnel et peut √™tre omis si n√©cessaire
};
```

Notons que les types peuvent √™tre utilis√©s pour d√©finir des types primitifs, des unions, des intersections, des tuples, etc. :

```ts
type ID = string | number; // Unions type

type Printable = {
    print(): void;
};

type Loggable = {
    log(): void;
};

type LoggableAndPrintable = Printable & Loggable; // Intersections de type

// Utilisation du type intersection
let obj: LoggableAndPrintable = {
    print() {
        console.log("Printing...");
    },
    log() {
        console.log("Logging...");
    }
};

function readPizzaById(id: number): Pizza | undefined {
  const pizzas = parse(jsonDbPath, defaultPizzas);
  return pizzas.find((pizza) => pizza.id === id);
} // Fonction qui retourne un type Pizza ou undefined
```

## Les classes

Les classes en TypeScript peuvent √©galement √™tre utilis√©es pour d√©finir des types. Les classes peuvent √™tre utilis√©es pour d√©finir des types d'objets avec des propri√©t√©s et des m√©thodes.

Voici un exemple de classe pour d√©finir un type de donn√©es :

```ts
class Person {
    name: string;
    age: number;
    email?: string; // Propri√©t√© optionnelle

    constructor(name: string, age: number, email?: string) {
        this.name = name;
        this.age = age;
        this.email = email;
    }
}
``` 
üëç Dans ce cours, nous avons volontairement choisi de ne pas faire d'orient√© objet en JS/TS. Nous vous recommandons de ne pas utiliser les classes pour d√©finir des types, mais plut√¥t d'utiliser des interfaces ou des types.

## Les enums

Les √©num√©rations (enums) sont des types de donn√©es qui permettent de d√©finir un ensemble de valeurs nomm√©es. Les √©num√©rations sont largement utilis√©es pour d√©finir des types de donn√©es avec des valeurs pr√©d√©finies.

Voici un exemple d'√©num√©ration pour d√©finir un type de donn√©es :

```ts
enum Color {
    Red = 'red',
    Green = 'green',
    Blue = 'blue'
}

const color: Color = Color.Red;

if (color === Color.Red) {
    console.log("It's red!");
}
```

## Generics

Les g√©n√©riques (generics) sont des types de donn√©es param√©tr√©s qui permettent de d√©finir des types r√©utilisables et flexibles. Les g√©n√©riques sont utilis√©s pour d√©finir des types de donn√©es qui peuvent accepter diff√©rents types de param√®tres.  

Voici un exemple de g√©n√©rique pour d√©finir un type de donn√©es :

```ts
// D√©finition d'une interface g√©n√©rique
interface Box<T> {
    value: T;
}

// Utilisation de l'interface g√©n√©rique
const box1: Box<number> = { value: 10 };
const box2: Box<string> = { value: "Hello, TypeScript!" };
const box3: Box = { value: true }; // le type de T est inf√©r√© comme boolean

console.log(box1.value); // Output: 10
console.log(box2.value); // Output: "Hello, TypeScript!"
console.log(box3.value); // Output: true
```

## Interfaces vs Types

Les interfaces et les types sont deux fa√ßons de d√©finir des types en TypeScript. Les interfaces sont principalement utilis√©es pour d√©finir des structures d'objets (et leur contrat), tandis que les types sont utilis√©s pour d√©finir des types primitifs, des unions, des intersections...

üëç Dans ce cours, nous vous recommandons d'utiliser les interfaces pour d√©finir des types d'objets.

Voici un exemple :
  
  ```ts
interface Pizza {
  id: number;
  title: string;
  content: string;
}

const pizza: Pizza = {
  id: 1,
  title: "Margherita",
  content: "Tomato, mozzarella, basilique"
};
```


üëç Dans ce cours, nous vous recommandons d'utiliser les types pour d√©finir des types primitifs, des unions et des intersections, des types sur base d'interfaces...

Voici quelques exemples :
  
  ```ts
  interface AuthenticatedUser {
  username: string;
  token: string;
}

  type MaybeAuthenticatedUser = AuthenticatedUser | undefined; // Union type


  interface Pizza {
  id: number;
  title: string;
  content: string;
}

  type NewPizza = Omit<Pizza, "id">;  // Omet la propri√©t√© "id" de l'interface Pizza

  function updatePizza(
  id: number,
  updatedPizza: Partial<NewPizza> // Partial permet de rendre les propri√©t√©s de NewPizza optionnelles
): Pizza {
  // ...
}
```

`Omit` est un utilitaire TS qui permet de cr√©er un nouveau type en omettant certaines propri√©t√©s d'un type existant.

`Partial` est un utilitaire TS qui permet de rendre toutes les propri√©t√©s d'un type optionnel.

# <InternalPageTitle> Comment contr√¥ler le flux en TS ? </InternalPageTitle>

## Introduction

Le contr√¥le de flux vise √† garantir la s√©curit√© et la pr√©cision des types en fonction des chemins d'ex√©cution possibles. 

Le contr√¥le de flux en TypeScript se r√©f√®re g√©n√©ralement √† l'ensemble des m√©canismes par lesquels le transpilateur/compilateur analyse les chemins d'ex√©cution possibles d'un programme pour d√©terminer les types des variables. Cela inclut les v√©rifications de type conditionnelles telles que `if`, `else`, `switch`, ainsi que les op√©rateurs de v√©rification de type comme `typeof`, `instanceof`, `in`, et les assertions de type via `as`.

## V√©rification de type conditionnelle

La v√©rification de type conditionnelle est une technique courante pour garantir la s√©curit√© des types en fonction des conditions. TypeScript utilise les instructions `if`, `else`, `switch` pour effectuer des v√©rifications de type conditionnelles.

Voici un exemple d'utilisation de la v√©rification de type conditionnelle avec `if` :

```ts
function greet(name: string | undefined) {
    if (name) { // TypeScript sait que name est de type string ici
        console.log(`Hello, ${name}!`); 
    } else { // TypeScript sait que name est de type undefined ici
        console.log("Hello, stranger!");
    }
}
```

Dans cet exemple, TypeScript inf√®re que `name` est de type `string | undefined`. La v√©rification `if (name)` permet de v√©rifier si `name` est d√©fini (non `undefined`) avant d'afficher le message de salutation.

## Op√©rateurs de v√©rification de type

Les op√©rateurs de v√©rification de type sont des outils puissants pour garantir la s√©curit√© des types en TypeScript. Ces op√©rateurs permettent de v√©rifier le type d'une variable ou d'une expression √† l'ex√©cution.

Voici quelques exemples d'op√©rateurs de v√©rification de type :

### `typeof`

L'op√©rateur `typeof` permet de v√©rifier le type d'une variable ou d'une expression √† l'ex√©cution. TypeScript utilise `typeof` pour effectuer des v√©rifications de type sur les variables.

```ts 
function logType(value: unknown) {
    if (typeof value === "string") {  // V√©rifie si value est une string
        console.log("It's a string!");
    } else if (typeof value === "number") {
        console.log("It's a number!");
    } else {
        console.log("Unknown type!");
    }
}
```

Dans cet exemple, TypeScript utilise `typeof` pour v√©rifier le type de `value` et afficher un message en fonction du type d√©tect√©.

### `instanceof`

L'op√©rateur `instanceof` permet de v√©rifier si un objet est une instance d'une classe.

Voici un exemple :
  
  ```ts
class Person {
    name: string;

    constructor(name: string) {
        this.name = name;
    }
}

function greet(person: Person | unknown) {
    if (person instanceof Person) { // V√©rifie si person est une instance de Person
        console.log(`Hello, ${person.name}!`);
    } else {
        console.log("Hello, stranger!");
    }
}
```
Dans cet exemple, TypeScript utilise `instanceof` pour v√©rifier si `person` est une instance de `Person` avant d'afficher le message de salutation. Vous ne verrez pas ce genre de code dans ce cours, car nous ne faisons pas d'orient√© objet en JS/TS.

### `in`

L'op√©rateur `in` permet de v√©rifier si une propri√©t√© existe dans un objet. TypeScript utilise `in` pour effectuer des v√©rifications de type sur les propri√©t√©s d'un objet.

Voici un exemple avec une interface `Person` :
  
  ```ts
interface Person {
  name: string;
  age: number;
}

function greet(person: Person | unknown) {
  if (person && typeof person === "object"  && "name" in person) {
      console.log(`Hello, ${person.name}!`);
  } else {
      console.log("Hello, stranger!");
  }
}
  ```

Dans cet exemple, TypeScript utilise `in` pour v√©rifier si la propri√©t√© `name` existe dans `person` avant d'afficher le message de salutation.

### Assertions de type

Les assertions de type (type assertions) permettent de forcer le type d'une variable ou d'une expression √† un type sp√©cifique. TypeScript utilise les assertions de type pour effectuer des v√©rifications de type manuelles.

Attention, les assertions de type ne changent pas le comportement √† l'ex√©cution de votre code ! Il est donc important d'utiliser les assertions de type que quand vous √™tes s√ªr du type de la variable ! A utiliser avec pr√©caution et parcimonie.

#### Assertions de type avec `as`

Voici un exemple d'assertion de type avec `as` :
  
  ```ts
 interface Person {
  id: number;
  username: string;
  email: string;
}

// Exemple de donn√©es re√ßues de l'API (simplifi√©)
const apiResponse: unknown = {
  id: 1,
  username: "john_doe",
  email: "john.doe@example.com",
  // D'autres propri√©t√©s qui ne nous int√©ressent pas pour cet exemple
};

// V√©rification de type pour garantir que 'apiResponse' est bien de type 'User'
if (
  apiResponse &&
  typeof apiResponse === "object" &&
  "id" in apiResponse &&
  "username" in apiResponse &&
  "email" in apiResponse
) {
  const user: Person = {
    id: apiResponse.id as number, // Assertion de type pour 'id'
    username: apiResponse.username as string,   // Assertion de type pour 'username'
    email: apiResponse.email as string,  // Assertion de type pour 'email'
  };

  console.log(user);
}
  ```

Dans cet exemple, TypeScript utilise des assertions de type avec `as` pour forcer le type des propri√©t√©s de `apiResponse` √† `number` et `string` respectivement. Cela garantit que `user` est de type `Person` et √©vite les erreurs de type potentielles √† la transpilation.

#### Assertion de type non-null

L'assertion de type non-null (`!`) affirme (au transpiler et aux lecteurs du code) que la valeur d'une variable n'est pas `null` ou `undefined` (on dit "nullish").

Voici un exemple d'assertion de type non-null :
  
  ```ts
let value: string | undefined = "Hello, TypeScript!";
const length = value!.length; // Assertion de type non-null(ish)
console.log(length); // Output: 17
  ```
Dans cet exemple, TypeScript utilise l'assertion de type non-null (`!`) pour garantir que `value` n'est pas `null` avant d'acc√©der √† sa propri√©t√© `length`.



## Conclusion

Le contr√¥le de flux en TypeScript est un outil puissant pour garantir la s√©curit√© des types en fonction des chemins d'ex√©cution possibles. En utilisant des v√©rifications de type conditionnelles, des op√©rateurs de v√©rification de type et des assertions de type, les d√©veloppeurs peuvent s'assurer que leur code respecte les d√©finitions de types fournies et √©viter les erreurs de type potentielles.

Nous avons vu les fa√ßons les plus directes de contr√¥ler le flux en TS ; il existe d'autre fa√ßons (type guards, assertion functions), mais nous ne les verrons pas dans ce cours. 

# <InternalPageTitle> R√©duction de type plus avanc√©e </InternalPageTitle>

## Introduction

En TypeScript, la **r√©duction de type** ("type narrowing") permet de contr√¥ler le flux d'ex√©cution (vu √† la section pr√©c√©dente) en ajustant dynamiquement le type des variables, facilitant ainsi des d√©cisions conditionnelles bas√©es sur des types pr√©cis dans le code.

La **r√©duction de type** ("type narrowing") en TypeScript fait r√©f√©rence au processus par lequel TypeScript restreint le type d'une variable ou d'une expression √† un sous-type plus sp√©cifique. Cela se produit g√©n√©ralement apr√®s une v√©rification de type, ce qui permet au compilateur TypeScript de savoir plus pr√©cis√©ment quel type de valeur vous manipulez √† un moment donn√© dans votre code.

Nous allons voir quelques exemples courants de **r√©duction de type** plus avanc√© en TypeScript dans une application Express.

## Tentative n¬∞1 de r√©duction de type du body d'une requ√™te : assertion de type

En TS, lorsqu'on utilise Express, le type du `body` d'une requ√™te est `any` par d√©faut. Cela peut √™tre probl√©matique, car cela signifie que le type du `body` n'est pas v√©rifi√© par TypeScript. 

Pour r√©duire le type du body √† un type plus sp√©cifique, on pourrait utiliser une assertion de type :

```ts numbered highlighting="2"
router.post("/", (req, res) => {
  const { title, content } = req.body as NewPizza;

  if (
    !title ||
    !content ||
    !isString(title) ||
    !isString(content) ||
    !title.trim() ||
    !content.trim()
  ) {
    return res.sendStatus(400);
  }

  const pizzas = parse(jsonDbPath, defaultPizzas);
  // Use reduce() to find the highest id in the pizzas array
  const nextId =
    pizzas.reduce((maxId, pizza) => (pizza.id > maxId ? pizza.id : maxId), 0) +
    1; // 0 is the initial value of maxId

  const addedPizza: Pizza = {
    id: nextId,
    title,
    content,
  };

  pizzas.push(addedPizza);

  serialize(jsonDbPath, pizzas);

  return res.json(addedPizza);
});
```

N√©anmoins, cette approche n'est pas optimale, car il est impossible d'assurer que le type du `body` est bien `NewPizza`. En effet, une API n'a pas d'influence sur ce que les clients d√©cident d'envoyer.

Pour des raisons de robustesse de l'API, on se doit de valider le type du `body` avant de l'utiliser. Cela sera fait √† l'ex√©cution ici (lignes 4 √† 13) via des v√©rifications de type, mais on prend le risque d'oublier une validation qui pourrait √™tre d√©tect√©e √† la transpilation/compilation.

üëé D√®s lors, nous vous d√©conseillons d'utiliser l'assertion de type (avec `as`) pour r√©duire le type du `body` d'une requ√™te Express.  
M√™me si le code est tr√®s concis, √ßa n'est pas une bonne pratique de faire des v√©rifications de type apr√®s avoir utilis√© une assertion de type juste pour se simplifier la vie en TS.

## Tentative n¬∞2 de r√©duction de type du body d'une requ√™te : v√©rification de type uniquement

Pour r√©duire le type du `body` √† un type plus sp√©cifique, on pourrait tenter d'utiliser une v√©rification de type :

```ts highlighting="9-10"
router.post("/", (req, res) => {
  if (
      !req.body ||
      typeof req.body !== 'object' ||
      !("title" in req.body) || 
      !("content" in req.body) ||
      typeof req.body.title !== 'string' ||
      typeof req.body.content !== 'string' ||
      !req.body.title.trim() || // Unsafe call of an `any` typed value.
      !req.body.content.trim() // Unsafe call of an `any` typed value.
    ) {
      return res.sendStatus(400);
    }
    //... 
```

‚ö°Ô∏è Ici, `req.body` est de type `any`. TS ne reconna√Æt pas la r√©duction de type pour une variable de type `any`. Ce code ne peut donc pas transpiler/ compiler !  
Ainsi, il est n√©cessaire de typer la variable `req.body` pour que TS puisse reconna√Ætre les propri√©t√©s `title` et `content` et les types de ces propri√©t√©s.

## R√©duction de type du body d'une requ√™te : assertion de type avec `unknown`

Nous allons cr√©er une variable de type `unknown` qui est une forme plus strictement typ√©e d'`any`, car TypeScript n√©cessite que vous effectuiez une v√©rification de type avant d'acc√©der √† ses propri√©t√©s ou de l'assigner √† un autre type :

```ts numbered highlighting="2"
router.post("/", (req, res) => {
  const body: unknown = req.body;
  if (
    !body ||
    typeof body !== "object" ||
    !("title" in body) ||
    !("content" in body) ||
    typeof body.title !== "string" ||
    typeof body.content !== "string" ||
    !body.title.trim() ||
    !body.content.trim()
  ) {
    return res.sendStatus(400);
  }

const { title, content } = body;
//...
```

üëç Ici, `title` et `content` sont reconnues par TypeScript comme de type `string` apr√®s la v√©rification de type. C'est donc une solution robuste qui peut √™tre utilis√©e dans ce cours.

üí≠  Notons ici que pour TS, le type de `body` est : `object & Record<"title", unknown> & Record<"content", unknown>`. C'est un type tr√®s complexe, mais qui permet de garantir que `title` et `content` sont bien des propri√©t√©s de `body`.

Le type `Record<"title", unknown>` repr√©sente un objet qui a une propri√©t√© obligatoire nomm√©e `title` avec une valeur de type inconnu (`unknown`). De m√™me pour `content`.  
Pourtant, TS d√©tecte que le type de `title` est `string`... Mais au niveau de l'objet `body`, √ßa n'est pas le cas...  
On peut retenir cela : **en TS, la r√©duction de type des propri√©t√©s d'un objet ne r√©duit pas le type de l'objet lui-m√™me.**

Nous ne pourrions pas √©crire :
  
```ts numbered highlighting="16"
router.post("/", (req, res) => {
  const body: unknown = req.body;
  if (
    !body ||
    typeof body !== "object" ||
    !("title" in body) ||
    !("content" in body) ||
    typeof body.title !== "string" ||
    typeof body.content !== "string" ||
    !body.title.trim() ||
    !body.content.trim()
  ) {
    return res.sendStatus(400);
  }

const { title, content } : NewPizza = body;
//...
```

Ce code ne transpile pas car TS ne peut pas garantir que `title` et `content` sont bien de type `string` apr√®s la v√©rification de type. Comme vu pr√©c√©demment, `body` est complexe et TS ne peut pas r√©duire le type de `body` √† `NewPizza`.

D√®s lors, dans ce cas, comme on est s√ªr du type, on pourrait utiliser une assertion de type pour r√©duire le type de `body` √† un type plus sp√©cifique :

```ts numbered highlighting="16"
router.post("/", (req, res) => {
  const body: unknown = req.body;
  if (
    !body ||
    typeof body !== "object" ||
    !("title" in body) ||
    !("content" in body) ||
    typeof body.title !== "string" ||
    typeof body.content !== "string" ||
    !body.title.trim() ||
    !body.content.trim()
  ) {
    return res.sendStatus(400);
  }

  const { title, content } = body as NewPizza;
  //...
```

üëç Ici, `body` est r√©duit √† `NewPizza` via une assertion de type. C'est une solution robuste qui peut aussi √™tre utilis√©e dans ce cours. L'avantage par rapport au m√™me code mais sans l'assertion de type (`as NewPizza`), c'est que TS informera le d√©veloppeur si `body` n'est plus de type `NewPizza` √† la transpilation/compilation.  

üí≠ En effet, si le type `NewPizza` venait √† changer (si l'on ajoutait une propri√©t√© par exemple), alors le linter afficherait qu'il manque une propri√©t√© partout o√π ce type est utilis√©.  
Par exemple, si on ajoute une propri√©t√© `price` √† `NewPizza`, alors TS afficherait une erreur √† la ligne 16 car `body` n'a pas de propri√©t√© `price`.

## üç¨ R√©duction de type du body d'une requ√™te : fonction de type "guard"

Parfois, on souhaiterait que TypeScript puisse inf√©rer le type de `req.body` sans avoir √† le typer explicitement (avec `as`).

La seule fa√ßon actuelle de le faire est de cr√©er une **fonction de type "guard"** qui permet de v√©rifier si un objet a les propri√©t√©s `title` et `content` et que ces propri√©t√©s sont des cha√Ænes de caract√®res non vides.

Une **fonction de type "guard"** retourne un type qui est un "predicate", un type qui permet de v√©rifier si une valeur est d'un certain type.

Par exemple, on pourrait cr√©er une fonction `isNewPizza` qui v√©rifie si un objet a les propri√©t√©s `title` et `content` et que ces propri√©t√©s sont des cha√Ænes de caract√®res non vides.  
`isNewPizza` retournerait un type pr√©dicat `body is NewPizza` qui  permettrait √† TypeScript de reconna√Ætre que `req.body` est de type `NewPizza`. Imaginez cette fonction d√©finie dans un fichier `/src/utils/type-guards.ts` :
  ```ts 
  const isNewPizza = (body: unknown): body is NewPizza => {
  if (
    !body ||
    typeof body !== "object" ||
    !("title" in body) ||
    !("content" in body) ||
    body.title !== "string" ||
    body.content !== "string" ||
    !body.title.trim() ||
    !body.content.trim()
  ) {
    return false;
  }

  return true;
};
```

Ensuite, on pourrait utiliser cette fonction pour r√©duire le type de `req.body` √† `NewPizza` :

```ts numbered highlighting="2"
router.post("/", (req, res) => {
  if(!isNewPizza(req.body)) return res.sendStatus(400);
  const { title, content } : NewPizza = body;
  //...
```

Pour ce cours, nous avons choisi de ne pas mettre les fonctions de type guard en avant car m√™me si cela offre un code concis et lisible, cela implique une compr√©hension approfondie de TS qui d√©passe les objectifs de ce cours.

# <InternalPageTitle> Comment en savoir plus sur TS ? </InternalPageTitle>

Si vous souhaitez en savoir plus sur ce langage, nous vous recommandons de consulter la documentation en ligne de [typescriptlang.org](https://www.typescriptlang.org).

