---
title: "RESTful API"
description: "Introduction aux RESTful API en Node.js, Express & TS"
---

# a) Introduction aux RESTful API

<InternalPageMenu>
  <PathViewer>
    <PathViewerItem to="/"> web2course </PathViewerItem>
    <PathViewerItem to="/part1"> Partie 1 </PathViewerItem>
    <PathViewerItem selected> a) RESTful API </PathViewerItem>
  </PathViewer>
  <InternalPageMenuItem> Introduction aux RESTful API & conventions </InternalPageMenuItem>
  <InternalPageMenuItem> D√©marrage d'une RESTful API en Express & TS </InternalPageMenuItem>
  <InternalPageMenuItem> Les fonctions middleware en Express </InternalPageMenuItem>
  <InternalPageMenuItem> D√©finition d'une route en Express </InternalPageMenuItem>
  <InternalPageMenuItem> Op√©rations de lecture </InternalPageMenuItem> 
  <InternalPageMenuItem> Exercice 1.1 : lecture de toutes les ressources </InternalPageMenuItem>
  <InternalPageMenuItem> Exercice 1.2 : middleware s'ex√©cutant sur toutes les routes </InternalPageMenuItem>
  <InternalPageMenuItem> Utilisation du linter et du formatter pour TS </InternalPageMenuItem>
  <InternalPageMenuItem> Param√®tres de route </InternalPageMenuItem>
  <InternalPageMenuItem> Param√®tres de requ√™te </InternalPageMenuItem>
  <InternalPageMenuItem> Op√©ration de cr√©ation & parsing du body </InternalPageMenuItem>
  <InternalPageMenuItem> Client REST </InternalPageMenuItem>
  <InternalPageMenuItem> Utilisation du debugger</InternalPageMenuItem>
  <InternalPageMenuItem> Exercice 1.3 : lectures sp√©cifiques, cr√©ation & REST Client </InternalPageMenuItem>
  <InternalPageMenuItem> üç¨ Exercice 1.4 : Gestion de la pagination, du tri et du filtrage </InternalPageMenuItem>
  <InternalPageMenuItem> Codes de statut HTTP associ√©s aux r√©ponses </InternalPageMenuItem> 
  <InternalPageMenuItem> Exercice 1.5 : codes de statut HTTP </InternalPageMenuItem>
  <InternalPageMenuItem> Op√©rations de suppression & de modification </InternalPageMenuItem>
  <InternalPageMenuItem> Exercice 1.6 : suppression & modification de ressources </InternalPageMenuItem>
</InternalPageMenu>

# <InternalPageTitle> Introduction aux RESTful API & conventions </InternalPageTitle>
## C'est quoi une application REST ?

<div className="card card__simple-youtube-container">
    <YoutubeImage src="https://youtu.be/EIESrlEV-CQ" />
</div>

**REST** vient de **RE**presentational **S**tate **T**ransfer : c'est un style architectural pour construire des applications web extensibles, o√π les client et serveurs sont s√©par√©s.

Dans une application REST, une **interface uniforme** (ou API) est d√©finie afin de permettre √† des applications de coop√©rer.

Toute application REST se doit d'√™tre **stateless** : il n'y a pas d'enregistrement du contexte d'une session sur le serveur pour comprendre une requ√™te d'un client.  
Ainsi, les requ√™tes clientes ne d√©pendent pas d'un historique de requ√™tes, chaque requ√™te contient tout l'information n√©cessaire au serveur.

Une RESTful API met √† disposition des **op√©rations** sur des **ressources** via :
- des **URI** ; il y a donc une adresse unique pur chaque ressource ;
- des **m√©thodes HTTP** (GET, POST, DELETE, PATCH, PUT) repr√©sentant les op√©rations possibles ; on parle souvent d'op√©rations **CRUD**, des op√©rations de type **C**reate, **R**ead, **U**pdate ou **D**elete) ;
- des **repr√©sentations** des ressources compr√©hensibles tant par les clients que les serveurs ; les ressources sont repr√©sent√©es par leur "Media type" : **JSON**, **XML**, **HTML**, **TXT**, **JPEG**... ; dans le cadre de ce cours, les ressources seront quasi toujours repr√©sent√©es via du **JSON**.

## Conventions REST

 Le type d'op√©ration CRUD sur une ressource est d√©fini via la **m√©thode http** de la requ√™te.  
 Les op√©rations possibles sont :
  - GET = Read
  - POST = Create
  - DELETE = Delete üòâ
  - PATCH / PUT = Update
    - PATCH = Update d'une ou plusieurs propri√©t√©(s) de la ressources
    - PUT = Update de toutes les propri√©t√©s de la ressources, ou cr√©ation si la ressource n'existe pas
    
Voici un exemple d'application de ces conventions REST dans le cadre d'une RESTful API permettant de g√©rer des **posts** :

| URI | M√©thode HTTP | Op√©ration |
|---|---|---|
| **`posts`** | GET | READ ALL : Lire toutes les ressources de la collection |
| **`posts?userId=value`** | GET | READ ALL FILTERED : Lire toutes les ressources de la collection selon le filtre donn√© |
| **`posts/{id}`** | GET | READ ONE : Lire la ressource identifi√©e |
| **`posts`** | POST | CREATE ONE : Cr√©er une ressource bas√©e sur les donn√©es de la requ√™te |
| **`posts/{id}`** | DELETE | DELETE ONE : Effacer la ressource identifi√©e |
| **`posts/{id}`** | PUT | UPDATE ONE : Remplacer l'enti√®ret√© de la ressource par les donn√©es de la requ√™te |

<br/>

Lors de l'ajout d'un post, si cette API est h√©berg√©e √† l'URL racine **https://jsonplaceholder.typicode.com/**, alors nous pourrions identifier une ressource de type **posts** de cette fa√ßon : **https://jsonplaceholder.typicode.com/posts/10**.

Pour lire cette ressource, il faudrait faire une requ√™te http de type **GET** sur cette **URL** : **https://jsonplaceholder.typicode.com/posts/10**.

# <InternalPageTitle> D√©marrage d'une RESTful API en Express & TS  </InternalPageTitle>

## Cr√©ation d'un projet √† partir d'un boilerplate
Nous allons maintenant d√©couvrir notre toute premi√®re RESTful API permettant de g√©rer les donn√©es associ√©es √† une pizzeria, afin de b√©n√©ficier d'op√©rations sur des ressources de type "pizzas" et de type "drinks".

Dans votre repo **web2**, veuillez cr√©er le r√©pertoire **`/tutorials/back/api`**.

Veuillez ouvrir un terminal au niveau de ce r√©pertoire.

Dans ce r√©pertoire, veuillez g√©n√©rer une application express nomm√©e **basic** sur base du boilerplate : [basic-ts-api-boilerplate](https://github.com/e-vinci/basic-ts-api-boilerplate) [[R.51]](/references/#r51).  
Pour ce faire :

```bash
git clone https://github.com/e-vinci/basic-ts-api-boilerplate basic
```

Veuillez installer les d√©pendances :
```bash
cd basic
npm i
```

‚ö° Comme vous avez fait un clone du boilerplate, attention au Git dans le Git, n'oubliez pas de supprimer le dossier **`.git`** pr√©sent dans votre nouveau projet.

Veuillez jeter un oeil √† la structure du projet **`basic`**.

Nous d√©veloppons des RESTful API qui ne poss√®dent pas de serveur de fichiers statiques.  
On n'a donc pas besoin d'avoir un r√©pertoire **`/public`** ni d'un serveur statique (`express.static`).  

## Fonctionnement d'une application Express

Nous allons maintenant nous attarder √† comprendre les concepts associ√©s √† l'utilisation d'Express, mais en focalisant sur ceux utiles aux applications REST.  
Voici comment une requ√™te faite √† une application Express est trait√©e :

<ScrollableImage name="express-flow.png" minWidth="800px" maxWidth="800px" />

<figcaption>Flux d'une requ√™te vers une application Express [R.51]</figcaption>

Dans ce flux de traitement d'une requ√™te, la responsabilit√© des d√©veloppeurs est de s'occuper de la partie "Middleware".

La grande majorit√© du code √©crit sera du "routing middleware" : notre code s'occupera de r√©pondre √† des requ√™tes clientes pour diff√©rentes URLs et m√©thodes HTTP (GET, POST...).

On l'a d√©j√† vu, la configuration d'une application Express, comme toutes applications Node.js, est faite au sein de **`package.json`**.

En fonction de comment est configur√© l'application, on la d√©marrera via **`npm start`**, **`npm run dev`**, **`npm run build`**...

Un **serveur web int√©gr√©** √† nos applications Express est d√©marr√© au sein du fichier **`bin/www.ts`**.

C'est ce fichier que vous devez mettre √† jour si par exemple vous souhaitez que votre application fonctionne sur un port diff√©rent que le port par d√©faut **`3000`**.

Un serveur int√©gr√© est diff√©rent d'une application web offerte par un serveur standalone comme Apache, Tomcat... C'est un serveur tr√®s l√©ger d√©di√© √† votre application.

# <InternalPageTitle> Les fonctions middleware en Express </InternalPageTitle>
## C'est quoi une fonction middleware ?

Les fonctions middleware s'occupent du traitement des requ√™tes des clients et de la pr√©paration des r√©ponses :

<ScrollableImage name="middlewares.jpg" minWidth="638px" maxWidth="638px" />

<figcaption>Les fonctions Middleware et Express [R.52]</figcaption>

Une fonction middleware a acc√®s aux objets de la requ√™te et de la r√©ponse et peut utiliser la requ√™te et la r√©ponse pour ajouter, par exemple, un log, pour autoriser un utilisateur, pour parser des donn√©es Json vers des objets TS/JS, pour servir des fichiers statiques, pour faire un traitement pour une route bien sp√©cifique...

Par exemple, lors d'une op√©ration d'ajout d'une pizza, si une fonction middleware ne termine pas le cycle de requ√™te-r√©ponse, elle doit appeler **`next()`** pour permettre √† d'autres fonctions qui sont dans la queue de pouvoir √™tre ex√©cut√©es.

Voici les √©l√©ments associ√©s √† l'appel d'une fonction middleware :

<ScrollableImage name="middleware-function.png" minWidth="944px" maxWidth="944px" />

<figcaption>Une fonction middleware [R.53]</figcaption>

Il existe diff√©rents types de fonctions middleware ayant diff√©rents cas d'utilisation :
- **Application-level middleware** : la fonction middleware est li√©e √† l'objet **`app`** et peut s'appliquer √† toutes les requ√™tes.
- **Router-level middleware** : la fonction middleware est li√©e √† un objet de type **`express.router()`** et est tr√®s similaire au "application-level middleware", mais ne s'applique qu'√† un groupe de requ√™tes.
- **Error-handling middleware** : fonction de gestion des erreurs qui se d√©finit comme les fonctions ci-dessus (au niveau **`app`** ou **`router`**), mais qui contient un quatri√®me param√®tre nomm√© **`error`**.
- **Built-in middleware** : fonctions middleware mises √† disposition par Express directement. En voici quelques exemples :
  - **`express.static`** : pour servir des assets statiques ;
  - **`express.json`** : pour parser le body de requ√™tes en JSON vers des objets JS ;
  - **`express.urlencoded`** : pour parser des requ√™tes dont le body est de type "urlencoded" (type par d√©faut des formulaires) vers des objets TS/JS.
- **Third-party middleware** : fonctions mises √† disposition par la communaut√© et installables via npm, comme par exemple la fonction middleware **`cookieParser`**.

La suite fournit quelques exemples de fonctions middleware qui seront soit plus tard rencontr√©es dans notre code, soit sont extraites de la documentation d'Express : [Using middleware](https://expressjs.com/en/guide/using-middleware.html) [[R.54]](/references/#r54).

## Application-level middleware : exemple
Voici une fonction middleware qui sera ex√©cut√©e √† chaque fois qu'il y a une requ√™te, quelque soit le chemin (ou path) associ√© √† la requ√™te :

```js
import express from "express";

const app = express();

app.use((_req, _res, next) => {
  console.log(
    "Time:",
    new Date().toLocaleString("fr-FR", { timeZone: "Europe/Brussels" })
  );
  next();
});
```

## Router-level middleware : exemple
Voici une partie du code qui pourrait se trouver au sein d'un router de pizzas, dans un fichier **`/routes/pizzas.ts`** :

```js
import { Router } from "express";
const router = Router();

router.use((_req, _res, next) => {
  console.log(
    "Time:",
    new Date().toLocaleString("fr-FR", { timeZone: "Europe/Brussels" })
  );
  next();
});

router.get("/", (req, res) => {
  return res.json(pizzas);
});
```

La premi√®re fonction middleware ne contient pas de m√©thode HTTP, ni de chemin, elle s'appliquerait donc √† toutes les routes associ√©es au router de pizzas.  
Voici le code qui permettrait, dans **`/app.ts`**, d'appeler le router de pizzas :

```js
import pizzaRouter from "./routes/pizzas";
app.use('/pizzas', pizzaRouter);
```

Lors de l'op√©ration de lecture de toutes les pizzas, si le router est utilis√© de cette fa√ßon, en relisant l'avant-dernier snippet, on voit que : 
- la premi√®re fonction (o√π il y a un `console.log`) s'applique donc √† toutes les routes qui commencent par **`/pizzas`** ;
- la deuxi√®me fonction middleware s'appliquent seulement aux requ√™tes de type **`GET`** sur la route (ou le chemin) **`/pizzas`** (√©quivalent de la route **`/pizzas/`**).

## Error-handling middleware : exemple
Ce type de middleware est √† d√©finir apr√®s tous les middlewares pouvant g√©n√©rer une erreur et est appel√© via **`throw`** ou via **`next(err)`** dans une fonction middleware o√π un souci est d√©tect√©.

Voici la d√©finition d'un gestionnaire d'erreurs :

```js
const errorHandler: ErrorRequestHandler = (err, _req, res, _next) => {
  console.error(err.stack);
  return res.status(500).send("Something broke!");
};

app.use(errorHandler);
```

Veuillez l'ajouter dans **`/app.ts`** juste avant l'export d'**`app`**. 
N'oubliez pas d'importer **`ErrorRequestHandler`** depuis **`express`**.

Attention, il y a bien 4 param√®tres au lieu des 3 habituels pour les autres types de fonctions middleware.

Veuillez d√©marrer l'API (par d√©faut elle est configur√©e sur le port 3000 au sein de **`bin/www.ts`**) :

```bash
npm run dev
```

Nous allons maintenant simuler une erreur dans notre application pour v√©rifier que notre gestionnaire d'erreurs fonctionne.

Veuillez ajouter le code suivant dans **`/routes/pizzas.ts`**, comme premi√®re route, juste apr√®s `defaultPizzas` :

```ts 
router.get("/error", (_req, _res, _next) => {
  throw new Error("This is an error");
  // equivalent of next(new Error("This is an error"));
});
```

Pour red√©marrer l'API, cela se fait automatiquement pour vous √† chaque sauvegarde d'un fichier : 
- üëç Nous vous conseillons de mettre l'auto-save dans VS Code : **`File`** > **`Auto Save`**.
- Sinon, vous devez penser √† faire des sauvegardes manuelles : **`CTRL s`** √† chaque modification de fichier.


Pour faire une requ√™te √† cette route, veuillez taper dans votre navigateur (ou cliquez sur ce lien) : http://localhost:3000/pizzas/error.

Regardez le message d'erreur tant dans le terminal de VS Code que ce qui est affich√© dans votre browser.

## Built-in middleware & third-party middleware : exemple
Dans **`app.ts`**, on peut trouver pas mal d'exemples de ces types de middleware. Ils sont comment√©s ci-dessous dans le code :

```js
const app = express();

app.use(logger('dev')); //¬†HTTP request logger linked to morgan package
app.use(express.json()); //¬†Parse requests with JSON payloads
app.use(express.urlencoded({ extended: false })); //¬†Parse requests with URL-
                                                  // encoded payload 
app.use(cookieParser()); //¬†Parse cookie header (req.cookies)
app.use(express.static(path.join(__dirname, 'public'))); //¬†Serve static assets
```

# <InternalPageTitle> D√©finition d'une route en Express </InternalPageTitle>
## D√©finition d'une route
Le routing, ou routage, contr√¥le la r√©ponse √† une requ√™te client pour un chemin et une m√©thode HTTP. Le chemin est aussi appel√© **endpoint** ou **URI** ou **PATH**.

On va d√©finir une route soit sur l'objet **`app`**, soit sur un **`router`**.  
Un objet de type **`router`** permet de regrouper toutes les routes associ√©es √† un type de ressources.

On d√©finit une route de cette fa√ßon : **`app.`** ou **`router.`**  **`METHOD(PATH, MIDDLEWARE_FUNCTION)`**.

üëç Dans notre cours, nous vous recommandons d'organiser vos routes par type de ressources et donc de mettre en place des routers.

# <InternalPageTitle> Op√©rations de lecture </InternalPageTitle>

Nous souhaitons d√©couvrir comment mettre en place une op√©ration permettant de lire toutes les ressources de type "drinks".  

Pour cela, il nous faut cr√©er un router pour traiter des ressources **`/drinks`** au sein de **`/routes/drinks.ts`**.  

Pour √™tre s√ªr de ne pas avoir de probl√®me de compilation avec TypeScript, il est recommand√© de toujours ouvrir votre projet en tant que **`workspace`** dans VS Code (`File` > `Open Folder...` et s√©lection de votre r√©pertoire `basic`).

Pour l'op√©ration de lecture de toutes les boissons, selon les conventions REST, il faut faire une requ√™te de type **`GET /drinks`**. Le router de **`/routes/drinks.ts`** doit donc offrir une route renvoyant toutes les boissons qui existent.

Pour d√©marrer, nous souhaitons une application basique qui ne g√®re pas la persistance des donn√©es. Le menu sera donc un array d'objets, chaque objet repr√©sentant une boisson.

Notre op√©ration de lecture de boissons va renvoyer du JSON au client, c'est √† dire une repr√©sentation textuelle d'un array d'objets. Nous verrons plus tard ce qu'est r√©ellement le JSON. A ce stade-ci, il est suffisant de conna√Ætre la fonction d'Express qui permet √† un objet TS/JS de circuler sur le r√©seau : **`res.json()`**.

Voici le code du router **`/routes/drinks.ts`** :
```ts
import { Router } from "express";
import { Drink } from "../types";

const drinks: Drink[] = [
  {
    id: 1,
    title: "Coca-Cola",
    image:
      "https://media.istockphoto.com/id/1289738725/fr/photo/bouteille-en-plastique-de-coke-avec-la-conception-et-le-chapeau-rouges-d%C3%A9tiquette.jpg?s=1024x1024&w=is&k=20&c=HBWfROrGDTIgD6fuvTlUq6SrwWqIC35-gceDSJ8TTP8=",
    volume: 0.33,
    price: 2.5,
  },
  {
    id: 2,
    title: "Pepsi",
    image:
      "https://media.istockphoto.com/id/185268840/fr/photo/bouteille-de-cola-sur-un-fond-blanc.jpg?s=1024x1024&w=is&k=20&c=xdsxwb4bLjzuQbkT_XvVLyBZyW36GD97T1PCW0MZ4vg=",
    volume: 0.33,
    price: 2.5,
  },
  {
    id: 3,
    title: "Eau Min√©rale",
    image:
      "https://media.istockphoto.com/id/1397515626/fr/photo/verre-deau-gazeuse-%C3%A0-boire-isol%C3%A9.jpg?s=1024x1024&w=is&k=20&c=iEjq6OL86Li4eDG5YGO59d1O3Ga1iMVc_Kj5oeIfAqk=",
    volume: 0.5,
    price: 1.5,
  },
  {
    id: 4,
    title: "Jus d'Orange",
    image:
      "https://images.unsplash.com/photo-1600271886742-f049cd451bba?q=80&w=1374&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D",
    volume: 0.25,
    price: 4.5,
  },
  {
    id: 5,
    title: "Limonade",
    image:
      "https://images.unsplash.com/photo-1583064313642-a7c149480c7e?q=80&w=1430&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D",
    volume: 0.33,
    price: 5,
  },
];

const router = Router();

router.get("/", (_req, res) => {
  return res.json(drinks);
});

export default router;
```

Ici, on a d√©fini un array de boissons, chaque boisson √©tant un objet de type **`Drink`**. TS aurait pu nous aider √† d√©finir automatiquement le type de chaque objet gr√¢ce √† l'inf√©rence de type : (le 1er objet contient un `id` qui est un `number`, un `title` qui est une string, `image` qui est une string, ...).

N√©anmoins, il est bien plus clair de pr√©ciser le type de chaque objet comme √©tant de type `Drink`. Une bonne pratique est de d√©finir les types de donn√©es dans un fichier **`/types.ts`** ; veuillez mettre √† jour ce fichier avec le type **`Drink`** :
```ts
interface Drink {
  id: number;
  title: string;
  image: string;
  volume: number;
  price: number;
}

export type { Pizza, NewPizza, PizzaToUpdate, Drink };
```

Et voici le code de **`app.ts`** (les parties modifi√©es sont surlign√©es) :

```js numbered highlighting="5,22"
import express, { ErrorRequestHandler } from "express";

import usersRouter from "./routes/users";
import pizzaRouter from "./routes/pizzas";
import drinkRouter from "./routes/drinks";

const app = express();

app.use((_req, _res, next) => {
  console.log(
    "Time:",
    new Date().toLocaleString("fr-FR", { timeZone: "Europe/Brussels" })
  );
  next();
});

app.use(express.json());
app.use(express.urlencoded({ extended: false }));

app.use("/users", usersRouter);
app.use("/pizzas", pizzaRouter);
app.use("/drinks", drinkRouter);

const errorHandler: ErrorRequestHandler = (err, _req, res, _next) => {
  console.error(err.stack);
  return res.status(500).send("Something broke!");
};

app.use(errorHandler);
export default app;
```

Pour consommer l'op√©ration de lecture via un browser, nous pouvons lire toutes les ressources de type "drinks" ici : http://localhost:3000/drinks

# <InternalPageTitle> Exercice 1.1 : lecture de toutes les ressources </InternalPageTitle>
Vous allez cr√©er la premi√®re version de la RESTful API de **myMovies**, un site qui permettra de pr√©senter des films. Vous devez, sous Express, mettre √† disposition cette op√©ration :

| URI | M√©thode HTTP | Op√©ration |
|---|---|---|
| **`films`** | GET | READ ALL : Lire toutes les ressources de la collection |

<br/>

Une ressource de type **`films`** doit contenir les propri√©t√©s suivantes :
  - **`id`** : un entier 
  - **`title`** : titre du film (String)
  - **`director`** : le r√©alisateur du film (String)
  - **`duration`** : dur√©e du film en minutes ; elle doit √™tre un nombre positif (pas une string !).

Un film pourra avoir des propri√©t√©s suppl√©mentaires (elles sont optionnelles) :
  - **`budget`** : pour informer du co√ªt qu'a cout√© la production du film, en millions ; le budget doit √™tre un nombre positif (pas une string !).
  - **`description`** : pour donner une URL vers une image du film.
  - **`imageUrl`** : pour donner une URL vers une image du film.

Veuillez donc "hardcoder" au moins trois ressources, parmi vos films pr√©f√©r√©s, dans un array au sein de votre RESTful API. Et si vous voulez aller tr√®s vite, demander √† une IA de g√©n√©rez des films contenant les propri√©t√©s demand√©es.

Le code de votre application doit se trouver dans votre repo git au sein du r√©pertoire **`/exercises/1.1`**. Vous allez donc cr√©er un nouveau projet sur base d'un clone du boilerplate : [basic-ts-api-boilerplate](https://github.com/e-vinci/basic-ts-api-boilerplate).

Veuillez supprimer tout le code du boilerplate qui n'est pas n√©cessaire pour cet exercice.

Une fois tout fonctionnel, veuillez faire un **`commit`** de votre code avec le message suivant : **`new: ex1.1`**.

# <InternalPageTitle> Exercice 1.2 : middleware s'ex√©cutant sur toutes les routes </InternalPageTitle>
## Application middleware de base
Veuillez cr√©er un middleware qui permette d'enregistrer et d'afficher dans la console des statistiques sur les requ√™tes faites √† votre API.

Vous devez enregistrer, depuis le d√©marrage du serveur, le nombre de requ√™tes **`GET`** faites √† votre API.

Veuillez repartir du code de la solution de votre Exercice 1.1 en cr√©ant un nouveau projet dans votre repo git dans **`/exercises/1.2`**.  
Vous pouvez t√©l√©charger la solution de l'Exercice 1.1 en cliquant sur <DownloadGitFolder repoUrl="https://github.com/e-vinci/js-exercises" folderPath="1.1"/>

Voici un example de ce qui devrait √™tre affich√© dans la console √† chaque requ√™te vers votre API :
```bash
GET counter : 2
```

Veuillez faire un **`commit`** de votre code avec le message suivant : **`new: ex1.2`**.

#### ü§ù Tips
- Comment r√©cup√©rer la m√©thode HTTP ? **`req.method`** ...
- Comment appliquer un middleware √† toutes les routes ? revoir les **application-level middleware**...

## üç¨ Challenge optionnel : et si on allait un peu plus loin ?

S'il vous reste du temps et que vous souhaitez travailler les structures de donn√©es, vous pourriez maintenant cat√©goriser le nombre d'appels par **`PATH`** et par **`m√©thode HTTP`**.

Voici un example de ce qui pourrait √™tre affich√© dans la console √† chaque requ√™te vers votre API :
```bash
Request counter :
- GET / : 10
- GET /pizzas : 2
- POST /pizzas : 5
- DELETE /pizzas : 2
```


# <InternalPageTitle> Utilisation du linter et du formatter pour TS </InternalPageTitle>
## Le linter 
Un linter est un outil qui analyse le code source pour signaler des erreurs de programmation, des bogues, des erreurs stylistiques et des constructions suspectes.

Pour b√©n√©ficier de feedback sur votre code lors de son √©criture, vous devez avoir install√© l'extension **ESLint** au sein de VS Code.

Vous devez aussi avoir ouvert le projet comme Workspace dans VS Code : `File`, `Open Folder...`. Le fichier de configuration de TypeScript (qui sp√©cifie les options de compilation pour le compilateur TypeScript `tsc`) doit se trouver √† la racine de votre Workspace.

Pour info, la configuration des r√®gles de **ESLint** se fait dans le fichier `.eslintrc` devant se trouver √† la racine d'un projet et offert au sein du boilerplate.

Il est possible de b√©n√©ficier d'un check du projet par le linter et de voir tous les avertissement ou erreurs en tapant cette commande dans votre projet :
```bash
npm run lint
```

## Le formatter
Un formateur de code est un outil qui permet de formater le code source de mani√®re automatique et coh√©rente. Cela permet de rendre le code plus lisible et de suivre des conventions de codage.

Pour formatter votre code, vous devez avoir install√© l'extension **prettier** au sein de VS Code.

Vous pouvez facilement formatter votre code :
- soit en tapant `Alt Shift F `(`Option Shift F` sous MacOS);
- soit en faisant un clic droit sur votre script, `Format Document` ; la premi√®re fois, il se peut que vous deviez s√©lectionner **prettier** comme formater : dans un fichier `.ts`, clic droit, `Format Document With...`, `Configure Default Formatter`.


# <InternalPageTitle> Param√®tres de route </InternalPageTitle>

Les **route parameters** sont des segments d'une URL qui sont utilis√©s pour capturer une valeur sp√©cifi√©e √† leur position dans l'URL. On r√©cup√®re ces param√®tres via l'objet **`req.params`**.

Pour notre pizzeria, nous souhaitons pouvoir lire une boisson identifi√©e par son **id**.

Nous allons donc ajouter le param√®tre de route **`id`**.  
En respect des conventions REST, un client devra faire ce genre de requ√™te pour appeler cette op√©ration : **`GET /drinks/2`**.

Pour continuer le tutoriel que nous avons initi√© dans le r√©pertoire **`/tutorials/pizzeria/api/basic`**,  voici la nouvelle route √† ajouter dans le router **`/routes/drinks.ts`** :
```ts
router.get("/:id", (req, res) => {
  const id = Number(req.params.id);
  const drink = drinks.find((drink) => drink.id === id);
  if (!drink) {
    return res.sendStatus(404);
  }
  return res.json(drink);
});
```

Pour consommer cette nouvelle op√©ration via un browser, nous pouvons lire la ressource de type "drinks" identifi√©e par **2** dans le menu ainsi :
http://localhost:3000/drinks/2

Le browser fait bien une requ√™te du genre : **`GET /drinks/2`**.  
Le param√®tre de la route "2" est r√©cup√©r√© dans l'URL de la route par Express et est offert via **`req.params.id`**. 

N'h√©sitez pas √† faire une requ√™te pour un identifiant n'existant pas dans les boissons : http://localhost:3000/drinks/666.

# <InternalPageTitle> Param√®tres de requ√™te </InternalPageTitle>

Les **query parameters** sont des param√®tres qui peuvent √™tre ajout√©s √† une URL.  
On r√©cup√®re ces param√®tres via l'objet **`req.query`**.

Pour notre pizzeria, nous souhaitons pouvoir filtrer toutes les ressources de type "boissons" n'√©tant pas plus cher qu'un certain budget.

En respect des conventions REST, un client devra faire ce genre de requ√™tes : **`GET /drinks/?budget-max=price`** ;

Il n'y a donc pas de nouvelle route √† ajouter ici. En effet, √ßa reste une requ√™te de type GET sur la route **`/drinks`**. 

Veuillez donc mettre √† jour **`/routes/drinks.ts`** pour la lecture de toutes les boissons en filtrant selon le budget maximum :
```ts
router.get("/", (req, res) => {
  if (!req.query["budget-max"]) {
    // Cannot call req.query.budget-max as "-" is an operator
    return res.json(drinks);
  }
  const budgetMax = Number(req.query["budget-max"]);
  const filteredDrinks = drinks.filter((drink) => {
    return drink.price <= budgetMax;
  });
  return res.json(filteredDrinks);
});
```

Pour consommer cette nouvelle op√©ration via un browser, nous pouvons lire toutes les ressources de type "drinks" tri√©es par leur titre de mani√®re descendante :
http://localhost:3000/drinks/?budget-max=3

N'h√©sitez pas √† tester d'autres filtres.


# <InternalPageTitle> Op√©ration de cr√©ation & parsing du body </InternalPageTitle>

Nous souhaitons d√©velopper une op√©ration permettant de cr√©er une ressource de type "drinks".  
Selon les conventions REST, il faut faire une requ√™te de type **`POST /drinks`** qui offre une repr√©sentation de la ressource √† cr√©er. La repr√©sentation utilis√©e est le JSON que nous verrons plus en d√©tails plus tard.  
Lors de l'ajout d'une boisson, si nous souhaitons cr√©er une ressource dont le titre est "Virgin Tonic", l'image est "https://plus.unsplash.com/premium_photo-1668771899398-1cdd763f745e?q=80&w=1374&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D", le volume est de 25cl et le prix est de 4,5‚Ç¨, alors la repr√©sentation de la ressource √† cr√©er sera la suivante :
```json
{
    "title":"Virgin Tonic",
    "image":"https://plus.unsplash.com/premium_photo-1668771899398-1cdd763f745e?q=80&w=1374&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D",
    "volume":0.25,
    "price":4.5
}
```

Selon les conventions REST, une requ√™te de cr√©ation est de type **POST** et contient ses **param√®tres au sein du body** de la requ√™te.

**`/routes/drinks.ts`** doit offrir une nouvelle route permettant d'ajouter une nouvelle boisson (au menu des boissons), qui est un array d'objets. Une nouvelle boisson doit donc √™tre ajout√©e √† une variable, un array, qui est contenu dans la m√©moire vive de notre machine.  
Lorsque l'ajout d'une boisson a r√©ussi, nous souhaitons renvoyer la repr√©sentation de la nouvelle ressource au client. 

Ainsi, le client aura souvent acc√®s √† une nouvelle propri√©t√©, l'**id** de la ressource cr√©√©e par l'API.

Voici une premi√®re version du code du router **`/routes/drinks.ts`** pour la nouvelle op√©ration. Rajoutons-le dans notre application :
```ts
router.post("/", (req, res) => {
  const { title, image, volume, price } = req.body;
  if (!title || !image || !volume || !price) {
    return res.sendStatus(400);
  }

  const nextId =
    drinks.reduce((maxId, drink) => (drink.id > maxId ? drink.id : maxId), 0) +
    1;

  const newDrink: Drink = {
    id: nextId,
    title,
    image,
    volume,
    price,
  };

  drinks.push(newDrink);
  return res.json(newDrink);
});
```

Ici, le linter ESLint nous avertit que **`req.body`** n'est pas d√©fini, nous avons une allocation de valeurs de type **`any`** ins√©curitaire. En effet, `title`, `image`, `volume` et `price` peuvent √™tre de n'importe quel type (**`any`**). 
Notre compilateur interdit ce genre de pratique, il est donc important de d√©finir le type de **`req.body`**.

Pour cela, nous devons d√©finir une interface qui repr√©sente la repr√©sentation de la ressource √† cr√©er.

Voici le code de **`/types.ts`** mis √† jour :
```ts
type NewDrink = Omit<Drink, "id">;

export type { Pizza, NewPizza, PizzaToUpdate, Drink, NewDrink };
```

Gr√¢ce √† `Omit`, nous avons cr√©√© un nouveau type **`NewDrink`** qui est le type **`Drink`** sans la propri√©t√© **`id`**.


Concernant `req.body`, il faut faire ce que l'on appelle de la **r√©duction de type** (ou **type narrowing**). Cela consiste √† v√©rifier que les propri√©t√©s sont bien d√©finies et qu'elles sont du bon type, g√©n√©ralement √† l'aide d'op√©rateurs (comme **`typeof`** ou **`instanceof`**, les op√©rateurs d'√©galit√©, l'op√©rateur **`in`** ) qui r√©duisent dynamiquement le type de la variable.

Et voici le code de **`/routes/drinks.ts`** mis √† jour en suivant les bonnes pratiques identifi√©es dans l'intro au TS de ce cours :
```ts numbered highlighting="2-20,22"
router.post("/", (req, res) => {
  const body: unknown = req.body;
  if (
    !body ||
    typeof body !== "object" ||
    !("title" in body) ||
    !("image" in body) ||
    !("volume" in body) ||
    !("price" in body) ||
    typeof body.title !== "string" ||
    typeof body.image !== "string" ||
    typeof body.volume !== "number" ||
    typeof body.price !== "number" ||
    !body.title.trim() ||
    !body.image.trim() ||
    body.volume <= 0 ||
    body.price <= 0
  ) {
    return res.sendStatus(400);
  }

  const { title, image, volume, price } = body as NewDrink;

  const nextId =
    drinks.reduce((maxId, drink) => (drink.id > maxId ? drink.id : maxId), 0) +
    1;

  const newDrink: Drink = {
    id: nextId,
    title,
    image,
    volume,
    price,
  };

  drinks.push(newDrink);
  return res.json(newDrink);
});
```

Nous avons finalement ajout√© une **assertion de type** : gr√¢ce √† **`as NewDrink`**, nous avons indiqu√© √† TypeScript que **`body`** est de type **`NewDrink`** car nous en sommes certains (suite aux v√©rifications de type).

Il est √† noter que la repr√©sentation de la ressource √† cr√©er est pars√©e dans l'objet **`req.body`** gr√¢ce √† la fonction middleware **`express.json()`** appel√©e dans **`/app.ts`** :
```js
app.use(express.json());
```

Il est donc important de ne pas oublier cette ligne lorsque l'on cr√©e une RESTful API.

Bien, on se rend compte que la validation des donn√©es est tr√®s importante, mais elle est souvent r√©p√©titive. C'est pourquoi il peut √™tre int√©ressant d'utiliser des librairies de validation de donn√©es comme **`Joi`** ou **`Yup`**.

OK, c'est bien, mais comment tester ce nouveau code ?

Le browser permet de facilement cr√©er des requ√™tes de type **`GET`**, mais pas des requ√™tes de type **`POST`**...   
Nous avons donc besoin d'un client l√©ger permettant de faire des requ√™tes HTTP.

# <InternalPageTitle> Client REST </InternalPageTitle>

## Introduction
Dans le cadre de ce cours, tout comme g√©n√©ralement dans un environnement professionnel, nous souhaitons pouvoir d√©velopper une API ind√©pendamment du d√©veloppement d'une IHM (Interface Homme Machine, ce sont les √©crans permettant d'interagir avec l'application web).

En effet, cela prendrait trop de temps de devoir d√©velopper un frontend pour tester nos API.

Nous allons donc utiliser un client l√©ger permettant de faire des requ√™tes √† nos API.  
Il en existe de nombreux, comme [REST Client](https://marketplace.visualstudio.com/items?itemName=humao.rest-client) [[R.55]](/references/#r55) ou [Postman](https://www.postman.com/) [[R.56]](/references/#r56).

## REST Client
Dans le cadre de ce cours, nous utilisons [REST Client](https://marketplace.visualstudio.com/items?itemName=humao.rest-client) [[R.55]](/references/#r55) de Visual Studio Code pour tester nos API.

Pour installer REST Client au sein de VS Code, veuillez cliquer sur l'onglet **`Extensions`**. 

Recherchez l'extension **`REST Client`** et cliquez sur **`Install`**.

Quelques notions pour utiliser REST Client :
- Il faut cr√©er un fichier **`.http`** (ou **`.rest`**) contenant les requ√™tes vers vos RESTful APIs.  
NB : Il est appropri√© de cr√©er un fichier par type de ressources.
- Chaque requ√™te est introduite par **`###`** (3 "**`#`**"" ou plus) ; voici la requ√™te permettant de lire toutes les boissons :
```http
### Read all drinks
GET http://localhost:3000/drinks
```
- Pour ex√©cuter une requ√™te, il suffit de cliquer sur **`Send Request`**.
- Lorsqu'on envoie des donn√©es au format JSON, il est important d'avoir un espace avant les accolades (avant le "**`{`**" ).
- On peut d√©finir des **File variables** via ce genre de syntaxe : **`@baseUrl = http://localhost:3000`**.
- Pour utiliser la variable **`baseUrl`**, il suffit de la mettre entre double accolades. Par exemple, voici la requ√™te permettant de lire toutes les boissons :  
```http
### Read all drinks with File variable
@baseUrl = http://localhost:3000
GET {{baseUrl}}/drinks
```

Nous allons maintenant tester l'API de la pizzeria que nous avons cr√©√©e pour toutes ses op√©rations.

Au sein de VS Code, dans votre projet **`/tutorials/pizzeria/api/basic`**, veuillez cr√©er un r√©pertoire nomm√© **`REST Client`**. Dans ce r√©pertoire, veuillez cr√©er un fichier nomm√© **`drinks.http`**.

Dans **`drinks.http`**, veuillez ajouter cette requ√™te pour la lecture de toutes les boissons et ex√©cutez la : 
```http
### Read all drinks with File variable
@baseUrl = http://localhost:3000
GET {{baseUrl}}/drinks
```

Est-ce que cela fonctionne bien ?  Avez vous bien d√©marr√© votre API ?  
Vous devriez obtenir le m√™me r√©sultat que si vous acc√©diez √† votre API √† l'aide du browser.

Au sein de **`drinks.http`**, veuillez ajouter ces deux requ√™tes pour la lecture d'une seule boisson ou pour la lecture de toutes les boissons en les filtrant selon le budget maximum :
```http
### Read a single drink
GET {{baseUrl}}/drinks/3

### Read all drinks cheaper or equal to 3 ‚Ç¨
GET {{baseUrl}}/drinks/?budget-max=3
```

Veuillez ex√©cuter ces deux requ√™tes.

Nous sommes pr√™ts pour ajouter une requ√™te appelant l'op√©ration de cr√©ation d'une boisson.

Au sein de **`drinks.http`**, veuillez ajouter cette requ√™te pour la cr√©ation d'une boisson :
```http
### Create a drink
POST {{baseUrl}}/drinks
Content-Type: application/json

{
    "title":"Virgin Tonic",
    "image":"https://plus.unsplash.com/premium_photo-1668771899398-1cdd763f745e?q=80&w=1374&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D",
    "volume":0.25,
    "price":4.5    
}
```

On remarque qu'il est important de mettre une ligne vide avant les accolades repr√©sentant le body de la requ√™te.

üí≠ Comment tester que le bon fonctionnement de l'op√©ration de cr√©ation ?

Il suffit d'ex√©cuter l'op√©ration de lecture de toutes les boissons üòé !
Lors de l'ajout d'une boisson, si la nouvelle ressource appara√Æt, c'est qu'elle a bien √©t√© cr√©√©e !  
Faites le test !

# <InternalPageTitle> Utilisation du debugger </InternalPageTitle>

## Introduction
üí≠ Qui est votre meilleur ami ?

Il est possible qu'√† ce stade-ci, vous ignorez une des bonnes r√©ponses, car pour les d√©veloppeurs, le debugger est leur meilleur ami !

Le debugger est toujours l√† pour vous, pr√™t √† vous faire voyager pas √† pas dans votre code, √† vous donner des pistes dans les moments difficiles, sans imposer de solutions, il vous offre une libert√© totale ! Et il acceptera toujours votre code tel qu'il est, sous r√©serve bien s√ªr que celui-ci compile.
C'est exactement ce que l'on attend d'un ami üòÅ.

## Utilisation de la configuration de debug offerte

Nous vous offrons une configuration de Debug permettant de facilement d√©boguer plusieurs applications au sein d'un m√™me folder de VS Code. Cette configuration se trouve dans le fichier **`.vscode/launch.json`**.  
Cette configuration est active au sein de VS Code que si elle se trouve √† la racine du folder ouverte dans VS Code. Vous devez donc vous assurer que le dossier **`.vscode`** et son fichier **`launch.json`** se trouvent au bon endroit. Voici deux sc√©narios :
- Si vous ouvrez un seul projet au sein de VS Code, c'est-√†-dire que le folder ouvert de VS Code est le clone du boilerplate d'une API : vous ne devez pas d√©placer le r√©pertoire **`.vscode`**, tout est bien configur√©.
- Si vous ouvrez ou folder de VS Code contenant plusieurs projets, comme par exemple un repository contenant plusieurs API : vous devez d√©placer **`.vscode`** √† la racine du folder ouvert dans VS Code.

Si vous avez plusieurs applications au sein d'un folder de VS Code, pour d√©boguer une application en particulier, nous vous conseillons cette approche :
- Ouvrez le fichier **`package.json`** de l'application √† d√©boguer ;
- Cliquez sur l'ic√¥ne **`Run and Debug`** √† gauche de l'Explorer, puis cliquez sur **`Start Debugging`** (ou cliquez juste sur **`F5`**) en v√©rifiant que la configuration de debugging s√©lectionn√©e est bien nomm√©e **`Launch via NPM`**.

Notons que le nom de la configuration de debugging peut facilement √™tre modifi√©e en changeant la valeur de l'attribut **`name`** dans **`/.vscode/launch.json`**.

## Utilisation du debugger TS
Il existe un autre moyen de d√©boguer son application au sein de VS Code :
- Vous pouvez installer l'extension **`TypeScript Debugger`** au sein de VS Code;
- Ensuite, il vous suffit de cr√©er une configuration de Debug : **`Add Configuration...`**, **`TS Debug`** ; sinon, vous pouvez s√©lectionner la configuration existante et nomm√©e **`ts-node`** dans le boilerplate d'une API. Une fois que votre configuration est ouverte apr√®s avoir cliqu√© sur l'onglet de Debug, vous √™tes pr√™t √† d√©boguer.
- Ouvrez le script d'entr√©e de votre application : **`/bin/www.ts`**.
- Cliquez sur **`Start Debugging`** ou sur **`F5`** en v√©rifiant que la configuration de debugging s√©lectionn√©e est bien nomm√©e **`ts-node`** (ou le nom que vous auriez choisi pour la configuration de votre debugger pour TS).

# <InternalPageTitle> Exercice 1.3 : lectures sp√©cifiques, cr√©ation & REST Client </InternalPageTitle>

Veuillez continuer le d√©veloppement de la RESTful API de **myMovies**, sous Express, afin de mettre √† disposition de nouvelles op√©rations sur des films et utiliser **REST Client**.

Veuillez repartir du code de la solution de votre [Exercice 1.2](#exercice_1_2_middleware_sexecutant_sur_toutes_les_routes) en cr√©ant un nouveau projet dans votre repo git dans **`/exercises/1.3`**.  

Veuillez rajouter ces op√©rations √† votre API :

| URI | M√©thode HTTP | Op√©ration |
|---|---|---|
| **`films?minimum-duration=value`** | GET | READ ALL FILTERED : Lire toutes les ressources de la collection selon le filtre donn√© |
| **`films/{id}`** | GET | READ ONE : Lire la ressource identifi√©e |
| **`films`** | POST | CREATE ONE : Cr√©er une ressource bas√©e sur les donn√©es de la requ√™te |

<br/>

Pour rappel, une ressource de type **`films`** doit contenir les propri√©t√©s suivantes :
  - **`id`** : un entier 
  - **`title`** : titre du film (String)
  - **`director`** : le r√©alisateur du film (String)
  - **`duration`** : dur√©e du film en minutes ; elle doit √™tre un nombre positif (pas une string !).

Un film pourra avoir des propri√©t√©s suppl√©mentaires (elles sont optionnelles) :
  - **`budget`** : pour informer du co√ªt qu'a co√ªt√© la production du film, en millions ; le budget doit √™tre un nombre positif (pas une string !).
  - **`description`** : pour donner une URL vers une image du film.
  - **`imageUrl`** : pour donner une URL vers une image du film.

Les ressources ne doivent toujours pas persister : d√®s lors, ajoutez les donn√©es associ√©es aux films dans un array.

Veuillez bien valider les param√®tres re√ßu par les op√©rations de vos API ; v√©rifiez par exemple que **`budget`** et **`duration`** sont des **nombres positifs**. Si √ßa n'est pas le cas, renvoyer un message d'erreur (comme par exemple "Wrong minimum duration") au format JSON (via **`res.json`**). Ceci n'est pas une bonne pratique, mais pour l'instant, c'est suffisant.

Veuillez **tester toutes les fonctions de la RESTful API** pour la collection de films √† l'aide du **REST Client** dans VS Code. Veuillez ajouter vos requ√™tes au sein du fichier **`films.http`** dans le r√©pertoire **REST Client** du dossier associ√© √† cet exercice.

Veuillez tester pas √† pas chaque ligne de votre op√©ration de cr√©ation de film. Pour ce faire, vous devez utiliser le debugger !

Une fois tout fonctionnel, veuillez faire un **`commit`** de votre code avec le message suivant : **`new: ex1.3`**.

#### ü§ù Tips
- D√©veloppez les op√©rations de votre API de mani√®re incr√©mentale : testez une op√©ration via REST Client avant de passer √† une nouvelle op√©ration.
- Pour le filtre sur les films, vous allez r√©cup√©rer un param√®tre de requ√™te.  
‚ö° Attention, le signe **`-`** est un op√©rateur en TS/JS, vous ne pouvez pas r√©cup√©rer le param√®tre de requ√™te via **`req.query.minimum-duration`**...  
üí≠ Mais alors comment faire ?  
On acc√®de aussi au propri√©t√© d'un objet √† l'aide d'un array, ici √ßa serait via **`req.query['minimum-duration']`**.
- Pour transformer une string en nombre, vous pouvez utiliser la fonction **`Number`** : **`Number(req.query['minimum-duration'])`**...

#### üç¨ Challenge optionnel
Si vous avez encore du temps, pour l'op√©ration de cr√©ation, vous pourriez ajouter une validation des donn√©es plus robuste en assurant qu'aucune propri√©t√© inattendue n'est pr√©sente dans la repr√©sentation de la ressource √† cr√©er.

Une fois tout fonctionnel, veuillez faire un **`commit`** de votre code avec le message suivant : **`new: ex1.3++`**.

# <InternalPageTitle> üç¨ Exercice 1.4 : Gestion de la pagination, du tri et du filtrage </InternalPageTitle>

N'h√©sitez pas, c'est optionnel, de g√©rer de nouvelles op√©rations au sein de votre RESTful API de **myMovies** :
-	Filtrez tous les films qui commencent par une certaines cha√Ænes de caract√®res.
-	Permettez de trier les films.

Le code de votre application est √† ajouter dans votre repo git dans **`/exercises/1.4`**.  
Veuillez faire un **`commit`** de votre code avec le message suivant : **`1.4 : API : ordering & filtering client`**.

üç¨ Et si vraiment vous avez encore du temps et souhaitez d√©j√† approfondir les RESTful APIs, n'h√©sitez pas aussi √† impl√©menter la gestion de la pagination. Pour cette partie, veuillez faire un **`commit`** de votre code avec le message suivant : **`new: ex1.4`**.

#### ü§ù Tips
Besoin d'inspiration pour l'aspect filtrage et la gestion du tri des ressources ? [REST API Guide](https://dev.to/drminnaar/rest-api-guide-14n2) [[R.58]](/references/#r58).


# <InternalPageTitle> Codes de statut HTTP associ√©s aux r√©ponses </InternalPageTitle>

On ne peut pas toujours renvoyer du JSON suite √† une requ√™te client ainsi qu'un code HTTP correspondant au fait que tout est OK (**`200 OK`**).

Quand vous ex√©cutez cette requ√™te :
```http
### Read all drinks with File variable
GET {{baseUrl}}/drinks
```

Vous faites appel √† l'op√©ration de lecture de toutes les boissons. La derni√®re ligne de cette op√©ration est la suivante :
```ts
return res.json(filteredDrinks);
```

La fonction **`json`** renvoie une r√©ponse au format JSON, mais de plus, elle renvoie un **status code** **`200`** indiquant au client que tout s'est bien pass√©.

Au sein de **`drinks.http`**, veuillez ajouter cette requ√™te pour tenter de cr√©er une boisson en oubliant un param√®tre :
```http
### Try to create a drink with incomplete data
POST {{baseUrl}}/drinks
Content-Type: application/json

{
    "title":"Missing Data Drink",
    "volume":0.25,
    "price":4.5    
}
```

Veuillez ex√©cuter cette requ√™te. Que se passe-t-il ?  
On r√©cup√®re un code d'erreur **`400 Bad Request`**.

En effet, lorsqu'on omet un param√®tre dans la repr√©sentation de la ressource √† cr√©er, voici les lignes de code amenant au renvoi du code d'erreur **`400`** au sein de **`drinks.ts`** :
```ts numbered highlighting="3-20"
router.post("/", (req, res) => {
  const body: unknown = req.body;
  if (
    !body ||
    typeof body !== "object" ||
    !("title" in body) ||
    !("image" in body) ||
    !("volume" in body) ||
    !("price" in body) ||
    typeof body.title !== "string" ||
    typeof body.image !== "string" ||
    typeof body.volume !== "number" ||
    typeof body.price !== "number" ||
    !body.title.trim() ||
    !body.image.trim() ||
    body.volume <= 0 ||
    body.price <= 0
  ) {
    return res.sendStatus(400);
  }

  const { title, image, volume, price } = body as NewDrink;

  const nextId =
    drinks.reduce((maxId, drink) => (drink.id > maxId ? drink.id : maxId), 0) +
    1;

  const newDrink: Drink = {
    id: nextId,
    title,
    image,
    volume,
    price,
  };

  drinks.push(newDrink);
  return res.json(newDrink);
});
```

Le client est donc bien inform√© qu'il y a eu un probl√®me lors de l'ex√©cution de l'op√©ration.   
Il pourrait par exemple utiliser cette information pour pr√©senter un message d'erreur au niveau d'une IHM.

Voici les grandes cat√©gories de "status codes" :
- R√©ponses informatives : **`100-199`**
- R√©ponses en cas de succ√®s : **`200-299`**
- Redirections : **`300-399`**
- Erreurs du client : **`400-499`**
- Erreurs du serveur : **`500-599`**

Voici les "status codes" que nous allons g√©n√©ralement utiliser :
- **`200 OK`** : tout s'est bien pass√©, Express ajoute ce code automatiquement pour nous quand nous utilisons une m√©thode comme **`res.json()`**.
- **`400 Bad Request`** : pour indiquer au client que la requ√™te contient des param√®tres non valides ou n'est pas compl√®te.
- **`401 Unauthorized`** : pour indiquer au client qu'il doit s'authentifier pour acc√©der √† cette op√©ration. On renvoie aussi ce code d'erreur quand un client fournit un mauvais username ou password.
- **`403 Forbidden`** : le client est connu du serveur, mais il n'a pas les privil√®ges pour acc√©der √† cette op√©ration (par exemple, le client n'est pas admin et tente d'acc√©der √† une op√©ration seulement accessible √† un admin).
- **`404 Not Found`** : la ressource demand√©e n'existe pas, bien que l'URL semble valide.
- **`409 Conflict`** : l'√©tat du serveur entre en conflit avec la requ√™te. Par exemple, la requ√™te demande de cr√©er un utilisateur qui existe d√©j√†.
- **`500 Internal Server Error`** : le serveur a rencontr√© une erreur qu'il ne peut pas r√©gler. Par exemple, le serveur de base de donn√©es ne r√©pond pas et ne permet donc pas d'acc√©der aux ressources.

# <InternalPageTitle> Exercice 1.5 : codes de statut HTTP </InternalPageTitle>

Veuillez continuer le d√©veloppement de la RESTful API de **myMovies**, sous Express, afin de mieux g√©rer la la lecture et la cr√©ation de films et les r√©ponses √† donner aux clients.

Veuillez cr√©er un nouveau projet dans votre repo git dans **`/exercises/1.5`** en partant du code de la solution de votre [Exercice 1.3](#exercice_1_3_lectures_specifiques_creation_rest_client) ou de votre [Exercice 1.4 optionnel](#üç¨_exercice_1_4_gestion_de_la_pagination_du_tri_et_du_filtrage).

Veuillez am√©liorer les deux op√©rations de lecture (**`GET /films`** & **`GET /films/:id`**) et l'op√©ration de cr√©ation de films (**`POST /films`**):
- En cas d'√©chec de la validation des param√®tres re√ßus par une op√©ration (non respect du contrat de l'API), veuillez renvoyer le status code appropri√©.
- Lors de l'√©chec de la lecture d'un film en particulier, veuillez renvoyer le status code appropri√©.
- Lors de l'ajout d'un film, si la ressource existe d√©j√†, c'est-√†-dire s'il y a d√©j√† un film pr√©sent avec le **`title`** et le **`director`** donn√©, veuillez renvoyer le status code appropri√©.

Veuillez faire un **`commit`** de votre code avec le message suivant : **`new: ex1.5`**.

# <InternalPageTitle> Op√©rations de suppression & de modification </InternalPageTitle>

## Op√©ration de suppression
Nous souhaitons d√©velopper une op√©ration permettant de supprimer une ressource de type "boisson" √† l'aide de son identifiant.  

Selon les conventions REST, une **op√©ration de suppression**:
- est associ√©e √† une requ√™te de type **`DELETE /drinks/{id}`** contenant l'**identifiant** de la ressource √† supprimer au sein de l'URI comme **param√®tre de route**.
- **ne contient pas de donn√©es dans le body** et est de **type DELETE**.

Voici le code du router **`/routes/drinks.ts`** pour la nouvelle op√©ration, veuillez la rajouter dans le r√©pertoire de votre tutoriel en cours :
```ts
router.delete("/:id", (req, res) => {
  const id = Number(req.params.id);
  const index = drinks.findIndex((drink) => drink.id === id);
  if (index === -1) {
    return res.sendStatus(404);
  }
  const deletedElements = drinks.splice(index, 1); // splice() returns an array of the deleted elements
  return res.json(deletedElements[0]);
});
```

Au sein de **`drinks.http`**, veuillez ajouter cette requ√™te pour supprimer la boisson poss√©dant l'identifiant "2" :
```http
### Delete a drink
DELETE {{baseUrl}}/drinks/2
```

Veuillez ex√©cuter cette requ√™te et v√©rifier que la boisson a bien √©t√© supprim√©e.

## Op√©ration de modification
Nous souhaitons d√©velopper une op√©ration permettant de modifier une ressource de type "drinks" √† l'aide de son identifiant et de nouvelles valeurs pour ses propri√©t√©s. 

Selon les conventions REST, une **op√©ration de modification** :
- si l'on accepte de modifier que certaines des propri√©t√©s d'une boisson (que l'on ne doit donc pas fournir toutes les propri√©t√©s d'une boisson), est associ√©e √† une requ√™te de type **`PATCH /drinks/{id}`** contenant l'**identifiant** de la ressource √† supprimer au sein de l'URL comme **param√®tre de route**.
- **contient les nouvelles donn√©es au sein du body** et est de **type PATCH ou PUT**.

Lors de l'ajout d'une boisson, si nous souhaitons modifier une ressource identifi√©e par **`5`** en fournissant un nouveau titre "Citronnade", la repr√©sentation des donn√©es de la ressource √† modifier sera la suivante :
```json
{
    "title":"Citronnade"
}
```

Selon les conventions REST, la requ√™te de modification est de type PATCH et contient ses param√®tres au sein du body de la requ√™te.

Voici le code du router **`/routes/drinks.ts`** pour la nouvelle op√©ration √† rajouter dans votre tutoriel en cours :
```ts
router.patch("/:id", (req, res) => {
  const id = Number(req.params.id);
  const drink = drinks.find((drink) => drink.id === id);
  if (!drink) {
    return res.sendStatus(404);
  }

  const body: unknown = req.body;

  if (
    !body ||
    typeof body !== "object" ||
    ("title" in body &&
      (typeof body.title !== "string" || !body.title.trim())) ||
    ("image" in body &&
      (typeof body.image !== "string" || !body.image.trim())) ||
    ("volume" in body &&
      (typeof body.volume !== "number" || body.volume <= 0)) ||
    ("price" in body && (typeof body.price !== "number" || body.price <= 0))
  ) {
    return res.sendStatus(400);
  }

  const { title, image, volume, price }: Partial<NewDrink> = body;

  if (title) {
    drink.title = title;
  }
  if (image) {
    drink.image = image;
  }
  if (volume) {
    drink.volume = volume;
  }
  if (price) {
    drink.price = price;
  }

  return res.json(drink);
});
```

Au sein de **`drinks.http`**, veuillez ajouter cette requ√™te pour modifier la boisson poss√©dant l'identifiant "5" :

```http
### Update the drink identified by 5
PATCH {{baseUrl}}/drinks/5
Content-Type: application/json

{
    "title":"Citronnade"
}
```

Veuillez ex√©cuter cette requ√™te et v√©rifier que la boisson a bien √©t√© modifi√©e.

En cas de souci, vous pouvez acc√©der au code du tutoriel ici : [basic](https://github.com/e-vinci/ts-demos/tree/main/back/api/basic).

# <InternalPageTitle> Exercice 1.6 : suppression & modification de ressources </InternalPageTitle>

Veuillez continuer le d√©veloppement de la RESTful API de **myMovies**, sous Express, afin d'ajouter les op√©rations de suppression et de modification de ressources.

Veuillez cr√©er un nouveau projet dans votre repo git dans **`/exercises/1.6`** en repartant du code de la solution de votre [Exercice 1.5](#exercice_1_5_codes_de_statut_http).

Veuillez ajouter ces trois nouvelles op√©rations :

| URI | M√©thode HTTP | Op√©ration |
|---|---|---|
| **`films/{id}`** | DELETE | DELETE ONE : Effacer la ressource identifi√©e |
| **`films/{id}`** | PATCH | UPDATE ONE : Mettre √† jour les propri√©t√©s de la ressource par les valeurs donn√©es dans la requ√™te, pour une ou plusieurs propri√©t√©s |
| **`films/{id}`** | PUT | UPDATE ONE or CREATE ONE : Remplacer la ressource par une ressource reprenant les valeurs donn√©es dans la requ√™te, seulement si toutes les propri√©t√©s non optionnelles de la ressource sont donn√©es ! Si la ressource n'existe pas, cr√©er cette ressource seulement si l'**`id`** donn√© n'est pas d√©j√† existant. |

Veuillez bien valider les param√®tres re√ßus par les op√©rations de vos API ; v√©rifiez par exemple que **`budget`** et **`duration`** sont des **nombres positifs**. 

Veuillez **tester toutes les fonctions de la RESTful API** pour la collection de films √† l'aide du **REST Client** dans VS Code. Veuillez ajouter vos requ√™tes au sein du fichier **`films.http`** dans le r√©pertoire **REST Client** du dossier associ√© √† cet exercice.

Et n'h√©sitez pas √† utiliser le debugger pour tester pas √† pas chaque ligne de vos op√©rations qui ne fournissent pas le r√©sultat attendu.

Veuillez faire un **`commit`** de votre code avec le message suivant : **`new: ex1.6`**.

#### üç¨ Challenge optionnel
Si vous avez encore du temps, pour les op√©rations de modification, vous pourriez ajouter une validation des donn√©es plus robuste en assurant qu'aucune propri√©t√© inattendue n'est pr√©sente dans la repr√©sentation de la ressource √† modifier (ou √† cr√©er si c'est un **`put`**).  

De plus, pour l'op√©ration `PUT`, lorsqu'il s'agit d'une cr√©ation, vous pourriez ajouter une validation pour v√©rifier que le film n'existe pas d√©j√† (sur base du **`title`** et du **`director`**).

Une fois tout fonctionnel, veuillez faire un **`commit`** de votre code avec le message suivant : **`new: ex1.6++`**.


