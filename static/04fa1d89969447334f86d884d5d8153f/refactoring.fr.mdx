---
title: "Refactoring de l'API"
description: "Refactoring √† l'aide d'un fat model"
---

# c) Refactoring √† l'aide de services

<InternalPageMenu>
  <PathViewer>
    <PathViewerItem to="/"> web2course </PathViewerItem>
    <PathViewerItem to="/part1"> Partie 1)</PathViewerItem>
    <PathViewerItem selected> c) Refactoring </PathViewerItem>
  </PathViewer>
  <InternalPageMenuItem> Architectures web possibles pour une API ? </InternalPageMenuItem>
  <InternalPageMenuItem> Architecture Express & services </InternalPageMenuItem>
  <InternalPageMenuItem> Exercice 1.8 : Refactoring √† l'aide d'un service </InternalPageMenuItem>
  <InternalPageMenuItem> Exercice 1.9 : Encore un service </InternalPageMenuItem>
</InternalPageMenu>

<div className="card card__simple-youtube-container">
    <YoutubeImage src="https://youtu.be/FihV6wXpIQE" />
</div>

# <InternalPageTitle> Architectures web possibles pour une API ? </InternalPageTitle>

Si nous reprenons le code actuel du tutoriel de l'API g√©rant des boissons ([persistence](https://github.com/e-vinci/js-demos/tree/main/back/api/persistence)), nous pouvons d√©tecter que celui-ci pourrait √™tre plus propre.

Par exemple, le routeur de "drinks" s'occupe tant de g√©rer les requ√™tes des clients que d'acc√©der directement aux donn√©es.  
G√©n√©ralement, nous pr√©f√©rons s√©parer le code g√©rant les acc√®s aux donn√©es du code g√©rant la pr√©sentation du r√©sultat des op√©rations.

On peut donc se demander comment s√©parer le code traitant de sujets tr√®s diff√©rents. Il existe une multitude d'architectures possibles, voici par exemple certains des plus grands noms :
- **Architecture MVC (Model View Controller)** ; au niveau backend, ce genre d'architecture est g√©n√©ralement tr√®s utile quand on fait des MPA (ou Multi-Page Applications) via du Server-Side Rendering. Les **Views** permettent de g√©n√©rer le frontend √† l'aide d'un moteur de templating ; le **Controller** s'occupe de traiter les requ√™tes en appelant le **Model** pour l'acc√®s aux op√©rations sur les donn√©es et en renvoyant les **Views** ad√©quates. Pour une API, cette architecture n'est pas la plus adapt√©e.
- **Architecture classique "three-tier"** ; au niveau backend, quand on d√©veloppe une architecture trois tiers, cela signifie que l'on d√©coupe notre API en trois couches :
  - **couche de pr√©sentation** : cette couche est responsable de pr√©senter les ressources aux clients et d'interpr√©ter les repr√©sentations des ressources donn√©es dans les requ√™tes ;
  - **couche business** : cette couche s'occupe de toute la logique de l'API, elle fait l'interm√©diaire entre la couche de pr√©sentation et la couche de donn√©es ;
  - **couche de donn√©es** : cette couche s'occupe des acc√®s aux donn√©es et permet notamment la persistance des ressources au sein de bases de donn√©es.  
  Le mod√®le trois tiers est fort int√©ressant, mais il demande un peu trop d'√©criture de codes sans grande valeur ajout√©e quand nous utilisons le framework Express.
- ...

Finalement, parmi les architectures classiques, il n'y a pas r√©ellement une architecture qui colle parfaitement √† ce qui est offert par le framework Express, sans devoir √©crire du code sans valeur ajout√©e.  

Ainsi, nous allons simplement cr√©er notre propre architecture "maison", sur base de ces points :
- On souhaite pouvoir **facilement remplacer la couche d'acc√®s aux donn√©es sans changer la repr√©sentation des ressources** ; en effet, dans un premier temps, nous sauvegarderons des donn√©es dans des fichiers JSON. Plus tard, si l'on venait √† sauvegarder les donn√©es dans un syst√®me de gestion de base de donn√©es, on ne veut pas devoir mettre √† jour le code prenant en compte les requ√™tes des clients et pr√©sentant la r√©ponse √† ces requ√™tes ; en gros, on souhaite que le code de nos routers, au sein d'Express, soit ind√©pendant de l'impl√©mentation des acc√®s aux donn√©es.
- Nous n'avons pas vraiment de contraintes pour l'aspect "business" de nos APIs : la logique de l'application peut soit s'associer √† la couche de donn√©es, soit √† la couche pr√©sentation. N√©anmoins, nous allons pr√©f√©rer **associer un maximum de la logique de notre application** √† ce que nous allons appeler un **service**. Le **service** contiendra toutes les **op√©rations possibles sur les ressources**, ainsi que les **acc√®s aux donn√©es**.
- Le **service** peut √™tre soit √©crit en orient√© objet, soit simplement √™tre un module fournissant des fonctions. Dans le cadre de ce cours, nous choisissons de pr√©senter un maximum de programmation fonctionnelle plut√¥t que de l'orient√© objet.  
N√©anmoins, n'h√©sitez pas √† √©crire des classes si cela vous tient √† coeur üòâ.

# <InternalPageTitle> Architecture Express & services </InternalPageTitle>

Dans un nouveau tutoriel, nous allons maintenant faire un refactor de notre API de gestion des pizzas en cr√©ant et utilisant un service.

Veuillez cr√©er un nouveau projet **`/tutorials/back/api/services`** sur base d'un copier/coller de votre r√©pertoire **`/tutorials/back/api/persistence`**.

En cas de souci, vous pouvez t√©l√©charger le code du tutoriel pr√©c√©dent ici : [persistence](https://github.com/e-vinci/ts-demos/tree/main/back/api/persistence).

Nous allons commencer par cr√©er le **service** offrant les op√©rations sur les boissons.   
Veuillez cr√©er le fichier **`/services/drinks.ts`**.  
Au sein de ce fichier, veuillez ajouter le code s'occupant des op√©rations sur les ressources de type "drinks" :

```ts numbered
import path from "node:path";
import { Drink, NewDrink } from "../types";
import { parse, serialize } from "../utils/json";
const jsonDbPath = path.join(__dirname, "/../data/drinks.json");

const defaultDrinks: Drink[] = [
  {
    id: 1,
    title: "Coca-Cola",
    image:
      "https://media.istockphoto.com/id/1289738725/fr/photo/bouteille-en-plastique-de-coke-avec-la-conception-et-le-chapeau-rouges-d%C3%A9tiquette.jpg?s=1024x1024&w=is&k=20&c=HBWfROrGDTIgD6fuvTlUq6SrwWqIC35-gceDSJ8TTP8=",
    volume: 0.33,
    price: 2.5,
  },
  {
    id: 2,
    title: "Pepsi",
    image:
      "https://media.istockphoto.com/id/185268840/fr/photo/bouteille-de-cola-sur-un-fond-blanc.jpg?s=1024x1024&w=is&k=20&c=xdsxwb4bLjzuQbkT_XvVLyBZyW36GD97T1PCW0MZ4vg=",
    volume: 0.33,
    price: 2.5,
  },
  {
    id: 3,
    title: "Eau Min√©rale",
    image:
      "https://media.istockphoto.com/id/1397515626/fr/photo/verre-deau-gazeuse-%C3%A0-boire-isol%C3%A9.jpg?s=1024x1024&w=is&k=20&c=iEjq6OL86Li4eDG5YGO59d1O3Ga1iMVc_Kj5oeIfAqk=",
    volume: 0.5,
    price: 1.5,
  },
  {
    id: 4,
    title: "Jus d'Orange",
    image:
      "https://images.unsplash.com/photo-1600271886742-f049cd451bba?q=80&w=1374&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D",
    volume: 0.25,
    price: 4.5,
  },
  {
    id: 5,
    title: "Limonade",
    image:
      "https://images.unsplash.com/photo-1583064313642-a7c149480c7e?q=80&w=1430&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D",
    volume: 0.33,
    price: 5,
  },
];

function readAllDrinks(budgetMax: number): Drink[] {
  const drinks = parse(jsonDbPath, defaultDrinks);
  if (!budgetMax) {
    return drinks;
  }

  const budgetMaxNumber = Number(budgetMax);

  const filteredDrinks = drinks.filter((drink) => {
    return drink.price <= budgetMaxNumber;
  });
  return filteredDrinks;
}

function readOneDrink(id: number): Drink | undefined {
  const drinks = parse(jsonDbPath, defaultDrinks);
  const drink = drinks.find((drink) => drink.id === id);
  if (!drink) {
    return undefined;
  }
  return drink;
}

function createOneDrink(newDrink: NewDrink): Drink {
  const drinks = parse(jsonDbPath, defaultDrinks);

  const nextId =
    drinks.reduce((maxId, drink) => (drink.id > maxId ? drink.id : maxId), 0) +
    1;

  const createdDrink = {
    id: nextId,
    ...newDrink,
  };

  drinks.push(createdDrink);
  serialize(jsonDbPath, drinks);

  return createdDrink;
}

function deleteOneDrink(drinkId: number): Drink | undefined {
  const drinks = parse(jsonDbPath, defaultDrinks);
  const index = drinks.findIndex((drink) => drink.id === drinkId);
  if (index === -1) {
    return undefined;
  }

  const deletedElements = drinks.splice(index, 1);
  serialize(jsonDbPath, drinks);
  return deletedElements[0];
}

function updateOneDrink(
  drinkId: number,
  newDrink: Partial<NewDrink>
): Drink | undefined {
  const drinks = parse(jsonDbPath, defaultDrinks);
  const drink = drinks.find((drink) => drink.id === drinkId);
  if (!drink) {
    return undefined;
  }

  if (newDrink.title !== undefined) {
    drink.title = newDrink.title!; // the router already checks for the presence of title
  }
  if (newDrink.image !== undefined) {
    drink.image = newDrink.image!;
  }
  if (newDrink.volume !== undefined) {
    drink.volume = newDrink.volume!;
  }
  if (newDrink.price !== undefined) {
    drink.price = newDrink.price!;
  }

  serialize(jsonDbPath, drinks);
  return drink;
}

export {
  readAllDrinks,
  readOneDrink,
  createOneDrink,
  deleteOneDrink,
  updateOneDrink,
};
```

Maintenant, nous allons mettre √† jour le router **`/routes/drinks.ts`** afin de faire les appels aux fonctions offertes par le mod√®le :

```ts numbered
import { Router } from "express";
import { NewDrink } from "../types";
import {
  createOneDrink,
  deleteOneDrink,
  readAllDrinks,
  readOneDrink,
  updateOneDrink,
} from "../services/drinks";

const router = Router();

router.get("/", (req, res) => {
  const budgetMax = Number(req.query["budget-max"]);
  const drinks = readAllDrinks(budgetMax);
  return res.json(drinks);
});

router.get("/:id", (req, res) => {
  const id = Number(req.params.id);
  const drink = readOneDrink(id);
  if (!drink) {
    return res.sendStatus(404);
  }
  return res.json(drink);
});

router.post("/", (req, res) => {
  const body: unknown = req.body;
  if (
    !body ||
    typeof body !== "object" ||
    !("title" in body) ||
    !("image" in body) ||
    !("volume" in body) ||
    !("price" in body) ||
    typeof body.title !== "string" ||
    typeof body.image !== "string" ||
    typeof body.volume !== "number" ||
    typeof body.price !== "number" ||
    !body.title.trim() ||
    !body.image.trim() ||
    body.volume <= 0 ||
    body.price <= 0
  ) {
    return res.sendStatus(400);
  }

  const { title, image, volume, price } = body as NewDrink;

  const newDrink = createOneDrink({ title, image, volume, price });
  return res.json(newDrink);
});

router.delete("/:id", (req, res) => {
  const id = Number(req.params.id);
  const deletedDrink = deleteOneDrink(id);
  if (!deletedDrink) {
    return res.sendStatus(404);
  }
  return res.json(deletedDrink);
});

router.patch("/:id", (req, res) => {
  const id = Number(req.params.id);

  const body: unknown = req.body;

  if (
    !body ||
    typeof body !== "object" ||
    ("title" in body &&
      (typeof body.title !== "string" || !body.title.trim())) ||
    ("image" in body &&
      (typeof body.image !== "string" || !body.image.trim())) ||
    ("volume" in body &&
      (typeof body.volume !== "number" || body.volume <= 0)) ||
    ("price" in body && (typeof body.price !== "number" || body.price <= 0))
  ) {
    return res.sendStatus(400);
  }

  const { title, image, volume, price }: Partial<NewDrink> = body;

  const updatedDrink = updateOneDrink(id, { title, image, volume, price });

  if (!updatedDrink) {
    return res.sendStatus(404);
  }

  return res.json(updatedDrink);
});

export default router;
```

Lancer votre API soit via le debugger, soit via la commande **`npm run dev`**.  
Veuillez ensuite tester que les op√©rations sur les boissons fonctionnent bien en ex√©cutant les requ√™tes HTTP d√©j√† pr√©sentes dans le r√©pertoire **`REST Client`** du boilerplate.

Maintenant, nous allons aussi mettre √† jour l'architecture pour traiter des ressources de type "pizzas". Veuillez cr√©er un fichier **`/services/pizzas.ts`** :

```ts numbered
// Create the pizzas service based on the drinks.ts service
import path from "node:path";
import { Pizza, NewPizza } from "../types";
import { parse, serialize } from "../utils/json";
const jsonDbPath = path.join(__dirname, "/../data/pizzas.json");

const defaultPizzas: Pizza[] = [
  {
    id: 1,
    title: "4 fromages",
    content: "Gruy√®re, S√©rac, Appenzel, Gorgonzola, Tomates",
  },
  {
    id: 2,
    title: "Vegan",
    content: "Tomates, Courgettes, Oignons, Aubergines, Poivrons",
  },
  {
    id: 3,
    title: "Vegetarian",
    content: "Mozarella, Tomates, Oignons, Poivrons, Champignons, Olives",
  },
  {
    id: 4,
    title: "Alpage",
    content: "Gruy√®re, Mozarella, Lardons, Tomates",
  },
  {
    id: 5,
    title: "Diable",
    content: "Tomates, Mozarella, Chorizo piquant, Jalapenos",
  },
];

function readAllPizzas(order: string | undefined): Pizza[] {
  const orderByTitle = order && order.includes("title") ? order : undefined;

  let orderedMenu: Pizza[] = [];
  const pizzas = parse(jsonDbPath, defaultPizzas);
  if (orderByTitle)
    orderedMenu = [...pizzas].sort((a, b) => a.title.localeCompare(b.title));

  if (orderByTitle === "-title") orderedMenu = orderedMenu.reverse();

  return orderedMenu.length === 0 ? pizzas : orderedMenu;
}

function readPizzaById(id: number): Pizza | undefined {
  const pizzas = parse(jsonDbPath, defaultPizzas);
  return pizzas.find((pizza) => pizza.id === id);
}

function createPizza(newPizza: NewPizza): Pizza {
  const pizzas = parse(jsonDbPath, defaultPizzas);
  const lastId = pizzas[pizzas.length - 1].id;
  const pizza: Pizza = { id: lastId + 1, ...newPizza };
  const updatedPizzas = [...pizzas, pizza];
  serialize(jsonDbPath, updatedPizzas);
  return pizza;
}

function deletePizza(id: number): Pizza | undefined {
  const pizzas = parse(jsonDbPath, defaultPizzas);
  const index = pizzas.findIndex((pizza) => pizza.id === id);
  if (index === -1) return undefined;

  const deletedElements = pizzas.splice(index, 1);
  serialize(jsonDbPath, pizzas);
  return deletedElements[0];
}

function updatePizza(
  id: number,
  updatedPizza: Partial<NewPizza>
): Pizza | undefined {
  const pizzas = parse(jsonDbPath, defaultPizzas);
  const pizza = pizzas.find((pizza) => pizza.id === id);
  if (!pizza) return undefined;

  if (updatedPizza.title !== undefined) {
    pizza.title = updatedPizza.title;
  }
  if (updatedPizza.content !== undefined) {
    pizza.content = updatedPizza.content;
  }

  serialize(jsonDbPath, pizzas);
  return pizza;
}

export { readAllPizzas, readPizzaById, createPizza, deletePizza, updatePizza };
```

Et le router **`/routes/pizzas.ts`** doit aussi √™tre mis √† jour :

```ts numbered
import { Router } from "express";

import { NewPizza, PizzaToUpdate } from "../types";
import {
  createPizza,
  deletePizza,
  readAllPizzas,
  readPizzaById,
  updatePizza,
} from "../services/pizzas";

const router = Router();

router.get("/error", (_req, _res, _next) => {
  throw new Error("This is an error");
  // equivalent of next(new Error("This is an error"));
});

/* Read all the pizzas from the menu
   GET /pizzas?order=title : ascending order by title
   GET /pizzas?order=-title : descending order by title
*/
router.get("/", (req, res) => {
  if (req.query.order && typeof req.query.order !== "string") {
    return res.sendStatus(400);
  }

  const pizzas = readAllPizzas(req.query.order);
  return res.json(pizzas);
});

// Read the pizza identified by an id in the menu
router.get("/:id", (req, res) => {
  const id = Number(req.params.id);
  const pizza = readPizzaById(id);
  if (!pizza) return res.sendStatus(404);
  return res.json(pizza);
});

// Create a pizza to be added to the menu.
router.post("/", (req, res) => {
  const body: unknown = req.body;
  if (
    !body ||
    typeof body !== "object" ||
    !("title" in body) ||
    !("content" in body) ||
    typeof body.title !== "string" ||
    typeof body.content !== "string" ||
    !body.title.trim() ||
    !body.content.trim()
  ) {
    return res.sendStatus(400);
  }

  const { title, content } = body as NewPizza;

  const addedPizza = createPizza({ title, content });

  return res.json(addedPizza);
});

// Delete a pizza from the menu based on its id
router.delete("/:id", (req, res) => {
  const id = Number(req.params.id);
  const deletedPizza = deletePizza(id);
  if (!deletedPizza) return res.sendStatus(404);

  return res.json(deletedPizza);
});

// Update a pizza based on its id and new values for its parameters
router.patch("/:id", (req, res) => {
  const body: unknown = req.body;
  if (
    !body ||
    typeof body !== "object" ||
    ("title" in body &&
      (typeof body.title !== "string" || !body.title.trim())) ||
    ("content" in body &&
      (typeof body.content !== "string" || !body.content.trim()))
  ) {
    return res.sendStatus(400);
  }

  const pizzaToUpdate: PizzaToUpdate = body;

  const id = Number(req.params.id);
  const updatedPizza = updatePizza(id, pizzaToUpdate);
  if (!updatedPizza) return res.sendStatus(404);

  return res.json(updatedPizza);
});

export default router;
```

Lancer votre API soit via le debugger, soit via la commande **`npm run dev`**.  
Veuillez ensuite tester que tout fonctionne bien en ex√©cutant quelques requ√™tes HTTP associ√©es aux pizzas et d√©j√† pr√©sentes dans le r√©pertoire **`REST Client`** du boilerplate.

En cas de souci, vous pouvez acc√©der au code du tutoriel ici :
[services](https://github.com/e-vinci/js-demos/tree/main/back/api/services).

# <InternalPageTitle> Exercice 1.8 : Refactoring √† l'aide d'un service </InternalPageTitle>

Vous allez faire un nouveau refactor de la RESTful API de **myMovies**, afin de restructurer l'application selon l'architecture recommand√©e, en utilisant un service pour g√©rer les op√©rations sur les films.

Veuillez repartir du code de la solution de votre [Exercice 1.7](../json/#exercice_1_7_persistance_des_donnees).  
Le code de votre application doit se trouver dans votre repo git dans **`/exercises/1.8`**. 

Veuillez faire un refactor de votre API g√©rant les films afin que tout ce qui traite des op√©rations sur les ressources soit fait au sein du service **`/services/films.ts`**.

Veuillez tester que votre API fonctionne toujours aussi bien apr√®s le refactoring.

Veuillez faire un **`commit`** de votre code avec le message suivant : **`new: ex1.8`**.


# <InternalPageTitle> Exercice 1.9 : Encore un service </InternalPageTitle>

Vous allez cr√©er une nouvelle API mettant √† disposition des op√©rations CRUD (**C**reate, **R**ead, **U**pdate & **D**elete) sur des ressources de type "texte √† dactylographier". 

Vous devez appliquer les outils de d√©veloppement et l'architecture recommand√©e dans ce cours-ci en mettant en place un service.

Pour ce faire, veuillez cr√©er un nouveau projet dans votre repo git dans **`/exercises/1.9`** sur base du boilerplate [basic-ts-api-boilerplate](https://github.com/e-vinci/basic-ts-api-boilerplate) ou sur base de votre exercice pr√©c√©dent (**`/exercises/1.8`**).

‚ö° Si vous avez fait un clone du boilerplate, attention au Git dans le Git, n'oubliez pas de supprimer le dossier **`.git`** pr√©sent dans votre nouveau projet.

Un texte √† dactylographier contient comme propri√©t√©s : 
- **`id`** : un uuid g√©n√©r√© via la librairie https://www.npmjs.com/package/uuid ;
- **`content`** : un contenu textuel ;
- **`level`** : le niveau associ√© au texte; les seules valeurs autoris√©es sont : **easy**, **medium** et **hard**.

Voici le tableau formalisant toutes les op√©rations que vous devez impl√©menter :

| URI |	M√©thode |	M√©thode |
|-----|---------|-----------|
| **`texts`**	| GET |	READ ALL : Lire toutes les ressources de la collection |
| **`texts?level=value`**	| GET |	READ ALL FILTERED : Lire toutes les ressources de la collection selon le filtre donn√© |
| **`texts/:id`** | GET | READ ONE : Lire la ressource identifi√©e |
| **`texts`**	| POST	| CREATE ONE : Cr√©er une ressource bas√©e sur les donn√©es de la requ√™te |
| **`texts/:id`** |	DELETE	| DELETE ONE : Effacer la ressource identifi√©e |
| **`texts/:id`** |	PUT	| UPDATE ONE : Remplacer l'enti√®ret√© de la ressource par les donn√©es de la requ√™te |

<br/>

Veuillez bien valider les valeurs des param√®tres. Notamment, une **`level`** doit √™tre compris dans les valeurs autoris√©es, sinon un code d'erreur appropri√© doit √™tre renvoy√©.

Veuillez tester toutes les m√©thodes offertes par votre application √† l'aide du client HTTP de REST Client.

#### ü§ù Tips
- Pour utiliser la librairie **`uuid`**, consultez la documentation en ligne : https://www.npmjs.com/package/uuid
- Si vous avez oubli√© d'installer les d√©finitions de type pour **`uuid`**, vous pouvez le faire via la commande **`npm install --save-dev @types/uuid`**. Pour rappel, cela est expliqu√© dans l'[Introduction aux packages Node.js & npm](../../part0/nodejs-app/#introduction_aux_packages_node_js_npm) (voir "Installer un package").

Veuillez faire un **`commit`** de votre code avec le message suivant : **`new: ex1.9`**.