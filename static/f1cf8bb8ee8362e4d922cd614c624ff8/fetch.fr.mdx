---
title: "Requ√™tes & promises"
description: "SPA, les requ√™tes et les promises en React"
---

# g) Les requ√™tes & promises

<InternalPageMenu>
  <PathViewer>
    <PathViewerItem to="/"> web2course </PathViewerItem>
    <PathViewerItem to="/part2"> Partie 2 </PathViewerItem>
    <PathViewerItem selected> g) Les requ√™tes & promises </PathViewerItem>
  </PathViewer>
  <InternalPageMenuItem> Fetch de donn√©es </InternalPageMenuItem>
  <InternalPageMenuItem> useEffect </InternalPageMenuItem>
  <InternalPageMenuItem> Les "promises" & fetch </InternalPageMenuItem>
  <InternalPageMenuItem> Exercice 2.13 : Premier fetch online </InternalPageMenuItem> 
  <InternalPageMenuItem> Exercice 2.13b : Un autre fetch online </InternalPageMenuItem> 
  <InternalPageMenuItem> Gestion d'√©v√©nements associ√©s au temps </InternalPageMenuItem>
  <InternalPageMenuItem> Exercice 2.14 : Gestion d'√©v√©nement temporel </InternalPageMenuItem>
  <InternalPageMenuItem> async / await </InternalPageMenuItem>
  <InternalPageMenuItem> Exercice 2.14b : async / await p√©riodique  </InternalPageMenuItem>
  <InternalPageMenuItem> Op√©ration asynchrone d'√©criture d'une ressource </InternalPageMenuItem>
  <InternalPageMenuItem> Cr√©ation de fonctions asynchrones renvoyant une promesse </InternalPageMenuItem>
    <InternalPageMenuItem> Single Origin Policy & CORS </InternalPageMenuItem>
  <InternalPageMenuItem> Simulation d'une m√™me origine via un proxy </InternalPageMenuItem>
  <InternalPageMenuItem> Exercice 2.15 : Proxy & async / await </InternalPageMenuItem> 
  <InternalPageMenuItem> Exercice 2.15b : async / await : effacer une ressource </InternalPageMenuItem>

</InternalPageMenu>

# <InternalPageTitle> Fetch de donn√©es </InternalPageTitle>

La m√©thode **`fetch`** permet de faire des requ√™tes HTTP d'un browser vers des API.

Cette m√©thode est asynchrone, c'est-√†-dire quelle n'est pas bloquante, elle renvoie des promesses de r√©sultats via des objets **`Promise`**. Dans un premier temps, nous allons de mani√®re intuitive d√©couvrir la programmation asynchrone. Nous verrons plus en d√©tails par la suite ce type de programmation √† l'aide de **promises** (les promesses).

Si un jour vous avez besoin d'en savoir plus sur la m√©thode **`fetch`**, n'h√©sitez pas √† consulter la [documentation MDN](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch) [[R.61]](/references/#r61).

Pour ce tutoriel, veuillez cr√©er une copie du tutoriel `routing-state`, si n√©cessaire voici le code du tutoriel [routing-state](https://github.com/e-vinci/ts-demos/tree/main/front/routing-state), et l'appeler `fetch-no-proxy`. Changez le nom du projet dans `package.json`.

Actuellement, les **`pizzas`** du menu sont "hardcod√©es" dans `App`.  

Nous souhaitons changer √ßa : afin de r√©cup√©rer une liste de pizzas, l'IHM doit faire une requ√™te **`fetch`** √† notre RESTful API d√©velopp√©e dans la partie [Refactoring √† l'aide de services](../../part1/refactoring/) :
[services](https://github.com/e-vinci/js-demos/tree/main/back/api/services).

Nous n'allons donc plus utiliser REST Client mais une fonction offerte par le browser pour faire l'√©quivalent de cette requ√™te :

```http
### Read all pizzas with File variable
GET {{baseUrl}}/pizzas
```

Veuillez mettre √† jour `App` en supprimant l'array **`pizzas`** et en rajoutant la requ√™te `fetch` : 
```tsx numbered highlighting="1,5-18"
const App = () => {
  const [actionToBePerformed, setActionToBePerformed] = useState(false);
  const [pizzas, setPizzas] = useState<Pizza[]>([]);

  useEffect(() => {
    fetch("http://localhost:3000/pizzas")
      .then((response) => {
        if (!response.ok)
          throw new Error(
            `fetch error : ${response.status} : ${response.statusText}`
          );
        return response.json();
      })
      .then((pizzas) => setPizzas(pizzas))
      .catch((err) => {
        console.error("HomePage::error: ", err);
      });
  }, []);

  // Reste du code inchang√©
```

Malheureusement, cela ne fonctionne pas, nous avons cette erreur : `Access to fetch at 'http://localhost:3000/pizzas' from origin 'http://localhost:5173' has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource. If an opaque response serves your needs, set the request's mode to 'no-cors' to fetch the resource with CORS disabled.`.

Nous allons apprendre √† r√©soudre cette erreur dans la partie qui suit, car celle-ci d√©pend de la fa√ßon dont l'API a √©t√© configur√©e. A ce stade-ci, pour voir l'application fonctionner, veuillez :
- Stopper la RESTful API ;
- T√©l√©charger, et d√©sarchiver cette API : <LinkFile name="api-json-server.zip" target="_blank" download> RESTful API offerte gr√¢ce √† json-server </LinkFile>
- Lancer l'API t√©l√©charg√©e : 
  - Ouvrir un terminal dans son r√©pertoire.
  - Installation des packages : **`npm i`**
  - Ex√©cution de l'API : **`npm start`**
- Faire un refresh au niveau de votre browser. 

Le menu des pizzas devrait s'afficher üéâ.  
Le code va √™tre expliqu√© dans la suite du tutoriel.

Si n√©cessaire, vous pouvez trouver le code associ√© √† ce tutoriel ici : [fetch-no-proxy](https://github.com/e-vinci/ts-demos/tree/main/front/fetch-no-proxy).

# <InternalPageTitle> useEffect </InternalPageTitle>

Mais √† quoi sert `useEffect` dans un composant React ?

`useEffect` est un hook de React qui permet d'ex√©cuter des effets secondaires dans nos composants fonctionnels. Les effets secondaires peuvent inclure des op√©rations telles que la r√©cup√©ration de donn√©es depuis une API, la manipulation directe du DOM, la configuration de timers, etc.

Le code √† l'int√©rieur de `useEffect` est une fonction qui sera ex√©cut√©e apr√®s que le composant soit rendu.

Le tableau vide `[]` en second argument signifie que cet effet ne s'ex√©cutera qu'une seule fois, apr√®s le premier rendu du composant :

```tsx highlighting="5-7"
const App = () => {
  const [actionToBePerformed, setActionToBePerformed] = useState(false);
  const [pizzas, setPizzas] = useState<Pizza[]>([]);

  useEffect(() => {
   // Code de la fonction
  }, []);
  // ...
```

Si vous aviez mis des variables d'√©tat dans ce tableau, l'effet se serait ex√©cut√© √† chaque fois que ces variables auraient chang√©.

Un exemple est donn√© dans le composant `AudioPlayer` du tutoriel : 
```ts
const AudioPlayer = ({
  sound,
  actionToBePerformed,
  clearActionToBePerformed,
}: AudioPlayerProps) => {
  const [isPlaying, setIsPlaying] = useState(false);
  const audioRef = useRef<HTMLAudioElement>(null);

  useEffect(() => {
    const audioElement = audioRef.current;

    if (audioElement && actionToBePerformed) {
      console.log("actionToBePerformed", actionToBePerformed);
      if (audioElement.paused) audioElement.play();
      else audioElement.pause();
      clearActionToBePerformed();
    }
  }, [actionToBePerformed]);
```

La fonction a l'int√©rieur de `useEffect` ne sera appel√©e que si la valeur de `actionToBePerformed` change.

En r√©sum√©, pour les fetch de donn√©es, si on souhaite le faire qu'une seule fois, au tout premier rendu du composant, alors il faut utiliser `useEffect` avec un `[]` en deuxi√®me param√®tre.

La suite va expliquer les fondements de la programmation asynchrone en JS/TS.

# <InternalPageTitle> Les "promises" & fetch </InternalPageTitle>

La m√©thode **`fetch`** renvoie une **`Promise`**, qui est un objet repr√©sentant un √©tat interm√©diaire d'une op√©ration. Le code des callbacks s'ex√©cute quand la t√¢che asynchrone est finie avec succ√®s ou si la t√¢che √©choue.

Les √©tats d'une promesse sont les suivants :

- **pending** : √©tat initial,
- **fulfilled** : l'op√©ration asynchrone a √©t√© termin√©e avec succ√®s ; par exemple la requ√™te **`fetch()`** a obtenu un flux de donn√©es avec la RESTful API,
- **rejected** : l'op√©ration asynchrone a √©chou√©e ; par exemple la requ√™te **`fetch`** est mal construite.

Pour r√©cup√©rer le r√©sultat d'une m√©thode asynchrone, on va faire appel :
- **`.then( callback )`** : ce morceau de code permet de cha√Æner des traitements asynchrones. Par exemple, √† la fin du premier traitement asynchrone associ√© au **`fetch()`**, on appelle

```ts numbered highlighting="2-8"
fetch("http://localhost:3000/pizzas")
      .then((response) => {
        if (!response.ok)
          throw new Error(
            `fetch error : ${response.status} : ${response.statusText}`
          );
        return response.json();
      })
      .then((pizzas) => setPizzas(pizzas))
      .catch((err) => {
        console.error("HomePage::error: ", err);
      });
```

La **callback** sera appel√©e et recevra comme param√®tre un objet de type **`Response`** : cet objet ne contient pas encore le contenu du body de la r√©ponse. En fait, **`Response.body`** est un flux de donn√©es (un stream), il faudra donc faire appel √† un traitement asynchrone pour obtenir le contenu du body sous forme d'un objet JS.  
C'est ce qui est fait en renvoyant **`return response.json();`** : la fonction **`json()`** renvoie une promesse, c'est √† dire qu'une fois le traitement termin√©, nous pourrons cha√Æner celui-ci via un autre **`.then()`**.
C'est ainsi que nous cha√Ænons, une fois le **`body`** disponible, l'appel d'une deuxi√®me **callback** qui s'occupe de mettre √† jour la variable d'√©tat `pizza`. Cette deuxi√®me **callback** recevra en param√®tre le body de la r√©ponse sous forme d'un objet JS :

```ts numbered highlighting="9"
fetch("http://localhost:3000/pizzas")
      .then((response) => {
        if (!response.ok)
          throw new Error(
            `fetch error : ${response.status} : ${response.statusText}`
          );
        return response.json();
      })
      .then((pizzas) => setPizzas(pizzas))
      .catch((err) => {
        console.error("HomePage::error: ", err);
      });
```

**`.catch( callback )`** : ce morceau de code permet d'ex√©cuter une **callback** lorsque la t√¢che asynchrone associ√©e √† la promesse √©choue. Dans le code, on voit que l'on affiche juste un message dans la console :

```js numbered highlighting="10-12"
fetch("http://localhost:3000/pizzas")
      .then((response) => {
        if (!response.ok)
          throw new Error(
            `fetch error : ${response.status} : ${response.statusText}`
          );
        return response.json();
      })
      .then((pizzas) => setPizzas(pizzas))
      .catch((err) => {
        console.error("HomePage::error: ", err);
      });
```

**`.finally( callback )`** : si l'on souhaite ex√©cuter une callback quelque soit le r√©sultat de la promesse, en cas de succ√®s ou d'√©chec.

‚ö° Pour le cha√Ænage des traitements via plusieurs callback appel√©es au sein de **`.then()`**, cela n'est possible que s'il y a un **`return`** dans les callback.

En effet, si une callback dans la gestion de promesses retourne :

- **Une valeur** : la promesse retourn√©e par **`then`** est r√©solue avec la valeur.
- **Pas de valeur** : la promesse retourn√©e par **`then`** est r√©solue avec **`undefined`**.
- **Une autre promesse "pending"**: la promesse retourn√©e par **`then`** est r√©solue/rejet√©e √† la suite de la r√©solution/rejet de la promesse retourn√©e par la **callback**.

Pour info, autrefois, pour la programmation asynchrone en JS, nous utilisions simplement les callbacks, des fonctions que l'on passait en argument d'autres fonctions. Le code pouvait facilement devenir illisible et donc difficilement maintenable.


# <InternalPageTitle> Exercice 2.13 : Premier fetch online </InternalPageTitle>

Nous souhaitons consommer une API qui nous permette d'afficher des blagues.  
Nous avons trouv√© une restful API qui permet tr√®s facilement de g√©n√©rer de mani√®re al√©atoire des **`jokes`** : [JokeAPI](https://v2.jokeapi.dev/).

Cette API est tr√®s simple d'utilisation. D'ailleurs, la page du site [JokeAPI](https://v2.jokeapi.dev/) vous donne un exemple fonctionnel de comment r√©cup√©rer des blagues simples dans l'onglet **`Try it out here`**. Pour cela, d√©s√©lectionnez **`twopart`** et vous obtenez l'URL pour faire vos requ√™tes en dessous du formulaire.

Veuillez cr√©er un nouveau projet en utilisant les technos Vite + React + TS + SWC nomm√© `/exercises/2.13-14` dans votre repo git.

Dans votre application, veuillez afficher une **`joke`** apr√®s l'avoir r√©cup√©r√©e de **`JokeAPI`**, en donnant ces 2 informations :
- la cat√©gorie associ√©e √† la **`joke`** ;
- le texte associ√© √† la **`joke`**.

Une fois tout fonctionnel, veuillez faire un commit avec le message suivant : **`new:ex2.13`**.

# <InternalPageTitle> Exercice 2.13b : Un autre fetch online </InternalPageTitle>

Nous avons trouv√© une restful API qui permet tr√®s facilement de g√©n√©rer de mani√®re al√©atoire des photos de chiens : [Dog API](https://dog.ceo/dog-api/).

Cette API est tr√®s simple d'utilisation. D'ailleurs, la page du site [Dog API](https://dog.ceo/dog-api/) vous donne un exemple fonctionnel de comment r√©cup√©rer al√©atoirement une photo de chien.

Veuillez cr√©er un nouveau projet en utilisant les technos Vite + React + TS + SWC nomm√© `/exercises/2.13b` dans votre repo git.

Dans votre application, veuillez afficher 3 photos al√©atoires de chiens. Veuillez ajouter un bouton qui permette de rafra√Æchir les photos avec 3 nouvelles photos al√©atoires.

Comme contrainte d'impl√©mentation, vous devez cr√©er un composant **`RandomDog`** et l'appeler 3 fois dans votre composant principal. 

Une fois tout fonctionnel, veuillez faire un commit avec le message suivant : **`new:ex2.13b`**.

#### ü§ù Tips
- Comment forcer le composant `App` √† faire un rerender de ses enfants ?  
  Vous pouvez utiliser un √©tat qui sera modifi√© √† chaque fois que vous cliquez sur le bouton de rafra√Æchissement des photos de chiens.  
  Cela forcera le composant `App` √† faire un rerender de ses enfants.
- Pensez √† faire en sorte, pour que le rerender des enfants fonctionne, qu'une nouvelle cl√© soit g√©n√©r√©e pour chaque enfant (`RandomDog`). Si aucune cl√© n'est g√©n√©r√©e, React ne fera pas de rerender des enfants, car il consid√®re que les enfants n'ont pas chang√© ; )

# <InternalPageTitle> Gestion d'√©v√©nements associ√©s au temps  </InternalPageTitle>

## Gestion d'un timer
**`setTimeout(f,t)`** permet l'ex√©cution d'une callback **`f`** √† l'expiration d'un timer, apr√®s **`t`** ms.

**`clearTimeout()`** permet de stopper l'ex√©cution d'une callback qui a √©t√© appel√©e via **`setTimeout()`**.

Cet exemple montre comment mettre en place un minuteur qui met √† jour un √©tat apr√®s 3 secondes :
```tsx numbered highlighting="8-10,13"
import { useState, useEffect } from 'react';

const TimerComponent = () => {
  const [message, setMessage] = useState('Attendez 3 secondes...');

  useEffect(() => {
    // D√©finir un timer de 3 secondes
    const timer = setTimeout(() => {
      setMessage('3 secondes se sont √©coul√©es!');
    }, 3000);

    // Nettoyage du timer pour √©viter des fuites de m√©moire si le composant est d√©mont√© avant que le timer se d√©clenche
    return () => clearTimeout(timer);
  }, []); // Le tableau vide [] signifie que cet effet s'ex√©cute une seule fois lors du montage

  return (
    <div>
      <p>{message}</p>
    </div>
  );
};

export default TimerComponent;
```

Ici nous apprenons un nouveau concept associ√© √† `useEffect` : la **fonction de nettoyage**. Une fonction de nettoyage, au sein de `useEffect`, est une fonction qui sera appel√©e lors de la destruction d'un composant (par exemple lorsque l'on passe d'une page √† une autre, la page sera "d√©truite"). La fonction de nettoyage est sp√©cifi√©e dans le `return` de `useEffect`.

Ci-dessus, la fonction de nettoyage `clearTimeout(timer)` est retourn√©e par `useEffect` pour s'assurer que le timer est nettoy√© si le composant est d√©mont√© avant que le timer ne se d√©clenche. Cela sera tr√®s utile √† mettre en place lorsqu'une action est associ√©e √† une page uniquement.

## Gestion d'intervalles de temps & actions r√©p√©t√©es

**`setInterval(f,t)`** permet l'ex√©cution d'une callback **`f`** tous les **`t`** ms.

**`clearInterval()`** permet de stopper les appels √† la callback qui ont √©t√© programm√©s via **`setInterval()`**.

Cet exemple montre comment mettre en place un intervalle qui met √† jour un compteur toutes les secondes. :
```tsx numbered highlighting="8-10,13"
import { useState, useEffect } from 'react';

const CounterComponent = () => {
  const [count, setCount] = useState(0);

  useEffect(() => {
    // D√©finir un intervalle qui incr√©mente le compteur toutes les secondes
    const interval = setInterval(() => {
      setCount(prevCount => prevCount + 1);
    }, 1000);

    // Nettoyage de l'intervalle pour √©viter des fuites de m√©moire si le composant est d√©mont√©
    return () => clearInterval(interval);
  }, []); // Le tableau vide [] signifie que cet effet s'ex√©cute une seule fois lors du montage

  return (
    <div>
      <p>Compteur: {count}</p>
    </div>
  );
};

export default CounterComponent;
```

# <InternalPageTitle> Exercice 2.14 : Gestion d'√©v√©nement temporel </InternalPageTitle>

Veuillez continuer l'exercice pr√©c√©dent nomm√© `/exercises/2.13-14` afin d'afficher une nouvelle blague toute les 10 secondes.

Une fois tout fonctionnel, veuillez faire un commit avec le message suivant : **`new:ex2.14`**.

# <InternalPageTitle> async / await </InternalPageTitle>

## Introduction

Plut√¥t que d'utiliser des **`.then()`** pour cha√Æner des traitements asynchrones, il est possible de simplifier la syntaxe des promesses √† l'aide de **`async`** et **`await`**.

On va donc √©crire du code d'une mani√®re √©quivalente √† ce qui serait fait en programmation synchrone, tout en b√©n√©ficiant des effets de la programmation asynchrone.

## async / await : les bases

Pour ce nouveau tutoriel, nous allons refactorer l'IHM pour am√©liorer le code associ√© aux appels asynchrones aux API.

Pour ce tutoriel, veuillez cr√©er une copie du tutoriel `fetch-no-proxy`, si n√©cessaire voici le code du tutoriel [fetch-no-proxy](https://github.com/e-vinci/ts-demos/tree/main/front/fetch-no-proxy), et l'appeler `async-await`. Changez le nom du projet dans `package.json`.

Nous allons donc refactorer le code o√π est fait le `fetch`, c'est √† dire `App` :

```tsx numbered highlighting="6,9-22"
const App = () => {
  const [actionToBePerformed, setActionToBePerformed] = useState(false);
  const [pizzas, setPizzas] = useState<Pizza[]>([]);

  useEffect(() => {
    fetchPizzas();
  }, []);

  const fetchPizzas = async () => {
    try {
      const response = await fetch("http://localhost:3000/pizzas");

      if (!response.ok)
        throw new Error(
          `fetch error : ${response.status} : ${response.statusText}`
        );

      const pizzas = await response.json();
      setPizzas(pizzas);
    } catch (err) {
      console.error("HomePage::error: ", err);
    }
  };
```

Pour tester ce code, il ne faut pas oublier de d√©marrer la RESTful API auparavant, la m√™me qu'au tutoriel pr√©c√©dent (t√©l√©chargez, et d√©sarchivez cette API : <LinkFile name="api-json-server.zip" target="_blank" download> RESTful API offerte gr√¢ce √† json-server </LinkFile> & ex√©cutez la).

Voici quelques caract√©ristiques importantes de **`async`** / **`await`** :
- **`await`** est utilis√© pour cha√Æner une t√¢che asynchrone (sur une fonction renvoyant une promesse) et ne peut se faire qu'au sein d'une fonction tagu√©e par **`async`** ; c'est donc le rempla√ßant du **`.then(callback)`**.  
  ‚ö° Attention, il est donc important qu'au niveau de la fonction **`arrow`**, √† la ligne 1 du code donn√© ci-dessus, on indique le **`async`** !  
  ‚ö° Dans le code donn√© ci-dessus, il est aussi tr√®s important de ne pas oublier les **`await`**. N'h√©sitez pas √† faire le test en enlevant le **`await`** de **`const pizzas = await response.json();`**.  
- Toute fonction "tagu√©e" par **`async`** renvoie automatiquement une promesse ; cela signifie dans le code ci-dessus que la fonction **`fetchPizzas`** est elle m√™me asynchrone.  
- On utilise des blocs **`try`** / **`catch`** pour g√©rer les erreur ; c'est donc le rempla√ßant du **`.catch(callback)`**.

üí≠ Il est √† parier, et n'h√©sitez pas √† trouver un moyen de vous en rendre compte visuellement, que le footer s'affiche avant le menu !

üí≠ Pourquoi ne pas avoir mis directement un await dans le `useEffect`, sans cr√©er la fonction `fetchPizza` ? On aurait pu tenter quelque chose du genre :
```ts
useEffect(async () => {
    try {
      const response = await fetch("http://localhost:3000/pizzas");

      if (!response.ok)
        throw new Error(
          `fetch error : ${response.status} : ${response.statusText}`
        );

      const pizzas = await response.json();
      setPizzas(pizzas);
    } catch (err) {
      console.error("HomePage::error: ", err);
    }
  }, []);
```

Cela n'est pas possible car `useEffect`, via TS et le linter, ne permet pas d'avoir une fonction asynchrone en param√®tre ! Ainsi, si l'on souhaite lancer une action asynchrone, nous devons faire preuve d'ing√©nuit√© : il faut cr√©er une fonction, et l'appeler au sein de la callback de `useEffect` ; )

# <InternalPageTitle> Exercice 2.14b : async / await p√©riodique </InternalPageTitle>

Veuillez cr√©er un nouveau projet nomm√© `/exercises/2.14b` dans votre repo git, sur base d'un copier / coller de `/exercises/2.13b`.

Nous allons faire un refactor de l'application permettant d'afficher 3 photos al√©atoires de chiens.

Dans un premier temps, veuillez faire un refactor du **`fetch`** en utilisant **`async`** / **`await`**.

Une fois tout fonctionnel, veuillez faire un commit avec le message suivant : **`new:ex2.14b-refactor`**.

Ensuite, veuillez rafra√Æchir automatiquement les photos de chiens toutes les 5 secondes. Vous devez retirer le bouton de rafra√Æchissement des photos de chiens.

Une fois tout fonctionnel, veuillez faire un commit avec le message suivant : **`new:ex2.14b`**.

#### Challenge

Il vous reste du temps ? Vous √™tes extr√™mement motiv√© ?  
Veuillez faire en sorte que lorsque les utilisateurs passent leur souris sur une photo de chien, la photo reste affich√©e (il n'y a pas de fetch de nouvelles photos pour ce **`RandomDog`**). Lorsque la souris quitte la photo, le comportement initial est r√©tabli, on recommence √† afficher des photos de chiens al√©atoires toutes les 5 secondes.

Une fois tout fonctionnel, veuillez faire un commit avec le message suivant : **`new:ex2.14b+`**.


# <InternalPageTitle> Op√©ration asynchrone d'√©criture d'une ressource </InternalPageTitle>

A pr√©sent, nous souhaiterions que notre IHM puisse cr√©er une ressource au sein de la RESTful API. Dans un premier temps, nous allons mettre √† jour le frontend en acceptant que n'importe quel utilisateur puisse cr√©er une pizza et l'ajouter au menu de la pizzeria.  
Bien entendu, cela est temporaire. Nous verrons plus tard comment s√©curiser cette op√©ration, en autorisant un admin seulement √† r√©aliser l'ajout d'une pizza au menu.

Nous allons maintenant ajouter l'interaction avec l'API au sein de **`AddPizzaPage`**.
Lorsque nous soumettons le formulaire, nous voulons faire une requ√™te de cr√©ation de pizza √† la RESTful API, c'est donc une requ√™te de type **`POST /pizzas`** qui doit √™tre l'√©quivalent de ce que nous faisions avec REST Client. Pour rappel, nous faisions une requ√™te de ce genre :
```http
### Create a pizza
POST {{baseUrl}}/pizzas
Content-Type: application/json

{
    "title":"Magic Green",
    "content":"Epinards, Brocolis, Olives vertes, Basilic"
}
```

Ici, c'est le JS/TS √† rajouter dans la fonction **`addPizza`** de **`App`** qui doit, permettre de r√©cup√©rer les donn√©es de la pizza √† cr√©er et faire un **`fetch`** de l'op√©ration de cr√©ation offerte par l'API.

Pour arriver √† nos fins, veuillez mettre √† jour la fonction `addPizza` dans `Main` :

```tsx numbered highlighting="2-23"
const addPizza = async (newPizza: NewPizza) => {
    try {
      const options = {
        method: "POST",
        body: JSON.stringify(newPizza),
        headers: {
          "Content-Type": "application/json",
        },
      };

      const response = await fetch("http://localhost:3000/pizzas", options); // fetch retourne une "promise" => on attend la r√©ponse

      if (!response.ok)
        throw new Error(
          `fetch error : ${response.status} : ${response.statusText}`
        );

      const createdPizza = await response.json(); // json() retourne une "promise" => on attend les donn√©es

      setPizzas([...pizzas, createdPizza]);
    } catch (err) {
      console.error("AddPizzaPage::error: ", err);
    }
  };
}

export default AddPizzaPage;
```

Pour la nouveaut√© et le **`fetch`** :
- Pour faire une requ√™te de type **`POST`**, tout comme pour les requ√™tes de type **`DELETE`**, **`PATCH`**, **`UPDATE`**..., il faut l'indiquer √† la m√©thode **`fetch`**.  
Cela est indiqu√© dans un objet que nous appelons g√©n√©ralement **`options`** qui doit contenir la propri√©t√© **`method`**.
- Lorsque l'on doit envoyer des donn√©es dans le **`body`** d'une requ√™te, alors il faut le faire au sein de la propri√©t√© **`body`**. Ici, nous souhaitons envoyer un objet contenant les propri√©t√©s **`title`** et **`content`** au format JSON. Nous devons donc utiliser la m√©thode **`JSON.stringify`** qui permet de cr√©er une repr√©sentation JSON d'un objet JS/TS. 
- Il est tr√®s important de sp√©cifier le type de la repr√©sentation de l'objet qui devrait √™tre utilis√© par l'API et qui se trouve dans le body de la requ√™te. Cela est fait via un **`header`** et la propri√©t√© **`Content-Type`** (**`'Content-Type': 'application/json',`**).  
‚ö° Si vous oubliez cela, l'API ne pourra pas parser les donn√©es au format JSON vers des objets JS/TS et donc les op√©rations d'√©criture de ressources √©choueront !

Veuillez v√©rifier que tout fonctionne correctement ; )

üí≠ Comment v√©rifier que les donn√©es persistent bien dans notre API apr√®s avoir soumis une nouvelle pizza ?

Faites un refresh de votre page... Vous pouvez m√™me stopper votre frontend et le red√©marrer (mais pas votre API). La nouvelle pizza devrait toujours √™tre affich√©e. Pour rappel, quand les donn√©es √©taient trait√©e dans un tableau en m√©moire vive via notre frontend, lors d'un refresh, on perdait ces donn√©es.

## Quelques mots sur le type en TypeScript

N'avez-vous pas √©t√© surpris que lorsque nous avons mis √† jour `addPizza`, en la rendant asynchrone √† l'aide du mot cl√© `async`, nous n'ayons pas du changer le type de `addPizza` au sein du type `PizzeriaContext` ?

Pour garder notre typage propre, nous vous recommandons de mettre √† jour le retour de `addPizza` dans `/src/types.ts` :
```ts
interface PizzeriaContext {
  pizzas: Pizza[];
  setPizzas: (pizzas: Pizza[]) => void;
  actionToBePerformed: boolean;
  setActionToBePerformed: (actionToBePerformed: boolean) => void;
  clearActionToBePerformed: () => void;
  drinks: Drink[];
  addPizza: (newPizza: NewPizza) => Promise<void>;
}
```

C'est une `Promise` qui est retourn√©e par la fonction `addPizza`.

# <InternalPageTitle> Cr√©ation de fonctions asynchrones renvoyant une promesse </InternalPageTitle>

A l'aide d'**`async`** / **`await`**, il est tr√®s simple de cr√©er des fonctions asynchrones qui renvoient une promesse.

Nous l'avons d√©j√† fait dans ce tutoriel. Imaginons que nous souhaitons cr√©er une fonction asynchrone qui renvoie toutes les pizzas qui sont offertes par l'op√©ration de lecture des pizzas de la RESTful API.

Voici comment nous √©cririons ce code :

```ts
async function getAllPizzas() {
    try {
      const response = await fetch("http://localhost:3000/pizzas");

      if (!response.ok)
        throw new Error(
          `fetch error : ${response.status} : ${response.statusText}`
        );

      const pizzas = await response.json();

      return pizzas;
    } catch (err) {
      console.error("getAllPizzas::error: ", err);
      throw err;
    }
  }
```

Cette fonction **`getAllPizzas`** ne renvoie pas un array de pizzas, mais une **`Promise`** !  
Si la promesse :
- r√©sout avec succ√®s, alors c'est bien un array de pizzas qui sera renvoy√© par cette fonction.
- √©choue, c'est une exception qui sera renvoy√©e.  
Pour que cela fonctionne, vous devez donc faire en sorte, dans vos fonctions asynchrones, de faire un **`throw`** d'une erreur en cas d'√©chec du traitement asynchrone.

Comment utiliser ce code au sein de `App`?  
Voici comment le code pourrait √™tre mis √† jour pour utiliser la fonction asynchrone `getAllPizzas` au sein de `App` :

```tsx highlighting="1,5"
const App = () => {
  const [actionToBePerformed, setActionToBePerformed] = useState(false);
  const [pizzas, setPizzas] = useState<Pizza[]>([]);

  useEffect(() => {
    fetchPizzas();
  }, []);

  const fetchPizzas = async () => {
    try {
      const pizzas = await getAllPizzas();
      setPizzas(pizzas);
    } catch (err) {
      console.error("HomePage::error: ", err);
    }
  };
```

Si n√©cessaire, vous pouvez trouver le code associ√© √† ce tutoriel ici : [async-await](https://github.com/e-vinci/ts-demos/tree/main/front/async-await).


# <InternalPageTitle> Single Origin Policy & CORS </InternalPageTitle>

La **Single Origin Policy** (**SOP**) sont des r√®gles appliqu√©es par le browser afin :
- de restreindre les interactions entre un document ou script charg√© par une origine avec une ressource d'une autre origine ;
- d'isoler des documents ou scripts malicieux, afin de r√©duire le risque des attaques.

Deux URL ont une m√™me **origine** si ces caract√©ristiques sont les m√™mes :

- **protocole** ;
- **port** ;
- **host** ; l'URL pointe vers le m√™me appareil connect√© √† internet ou √† un r√©seau local.

Il est possible de relaxer la s√©curit√© via des **Cross Origin Resource Sharing** (**CORS**).  
**CORS** est un m√©canisme qui utilise des headers HTTP pour indiquer aux browsers qu'ils peuvent autoriser les acc√®s √† des ressources d'origines diff√©rentes.

Cela signifie qu'une application web qui utilise une API ne peut le faire que si les ressources demand√©es √† l'API proviennent d'une m√™me origine, √† moins que la r√©ponse de l'API inclut les bonnes **CORS** (via des header HTTP).

Si l'on autorise trop d'origines, voici un exemple classique d'attaque :

<ScrollableImage name="cors-issue.png" minWidth="500px" maxWidth="700px" />

Imaginez qu'un site d'une banque ne soit pas s√©curis√© avec des techniques modernes. Ce site utiliserait une IHM (**`https://my-bank.com`**), qui, via un formulaire, permettrait de faire un versement, sous r√©serve d'envoyer un cookie qui contiendrait une variable de session (simple m√©canisme de s√©curit√©) lors d'une requ√™te √† l'API de la banque.

Maintenant, prenons le cas d'un utilisateur qui adore jouer sur le web, un gamer en puissance. Il joue √† un jeu de penguins, mais soudainement, il est redirig√© vers un site malicieux (**`https://malicious.com`**), qui lui offre un nouveau jeu avec des dinosaures. Ce site malicieux, en arri√®re plan, pourrait faire une requ√™te vers la m√™me API utilis√©e par **`https://my-bank.com`**.  
Comme c'est le m√™me browser utilis√© par notre gamer, tant pour faire ses virements, que pour jouer, toute requ√™te faite vers **`https://api.my-bank.com`** enverra d'office les cookies existants et associ√©s au domaine **`api.my-bank.com`**.
Les r√©sultats peuvent √™tre dramatiques : l'attaquant √† la capacit√© de faire des versements jusqu'√† vider le compte de notre pauvre gamer.

Bien s√ªr, gr√¢ce √† la **SOP** appliqu√©e par nos browser, par d√©faut, d√®s que le site malicieux communique avec l'API de la banque, celui-ci bloque l'acc√®s aux ressources de l'API car l'origine du site malicieux est diff√©rente de l'origine de l'API.

Les **CORS** permettent de rel√¢cher la s√©curit√©, afin notamment, dans le sc√©nario √©voqu√©, d'autoriser l'origine **`https://my-bank.com`** √† acc√©der √† l'origine **`https://api.my-bank.com`**. En effet, c'est ce que le site de la banque souhaite.  
Par contre, si la banque poss√®de des d√©veloppeurs nuls au niveau s√©curit√© et que ceux-ci autorisent toutes les origines √† interroger l'API, l√†, nous pourrions arriver au hacking d√©crit ci-dessus.

Dans ce cours, nous allons voir comment nous pouvons communiquer entre un frontend et une API fonctionnant sous deux origines diff√©rentes, √† l'aide de deux techniques diff√©rentes :
- **`proxy`** : le frontend communique avec un serveur qui lui est associ√©, et ce serveur communique avec l'API. Le serveur 'proxy' est donc un interm√©diaire entre le frontend et l'API. Nous allons voir cela dans la suite.
- **`CORS`** : l'API autorise explicitement le frontend √† communiquer avec elle. Cela sera vu plus tard, de mani√®re optionnelle, dans la partie 3 de ce cours.


# <InternalPageTitle> Simulation d'une m√™me origine via un proxy </InternalPageTitle>

Il est possible de mettre en place un proxy au niveau du frontend afin de faire croire au browser que l'API et le frontend ont la m√™me origine.

Veuillez d√©marrer l'API qui n'autorise aucune autre origine : [services](https://github.com/e-vinci/ts-demos/tree/main/back/api/services)).

Nous allons mettre en place un m√©canisme au niveau du frontend pour faire passer toutes les requ√™tes √† destination de l'API par un proxy ; le proxy aura la m√™me origine que le serveur de fichiers statiques ayant offert le frontend.

Pour ce tutoriel, veuillez cr√©er une copie du tutoriel `async-await`, si n√©cessaire voici le code du tutoriel [async-await](https://github.com/e-vinci/ts-demos/tree/main/front/async-await), et l'appeler `fetch-proxy`. Changez le nom du projet dans `package.json`.

Le menu des pizzas ne s'affiche pas et nous avons le probl√®me d√©j√† rencontr√© (`...has been blocked by CORS policy`).


Voici le workflow que nous allons appliquer √† notre site g√©rant la pizzeria :
- Lors du premier appel de notre browser au serveur de d√©veloppement de Vite : on r√©cup√®re notre SPA, c'est √† dire `index.html` & tous les assets associ√©s.
- A chaque fetch, une requ√™te est faite au proxy sur la m√™me origine que le serveur de d√©veloppement qui a offert les fichiers associ√©s √† la SPA.
- Le proxy s'occupe de transf√©rer la requ√™te HTTP √† l'API, puis de renvoyer la r√©ponse au browser.
- Ainsi, pour le browser, il n'y a qu'une seule origine : )

Le serveur de d√©veloppement de `Vite` met √† disposition un proxy. Pour utiliser ce proxy, vous devez configurer `Vite`. Veuillez mettre √† jour le fichier `vite.config.ts` :

```ts numbered highlighting="12-20"
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react-swc";
import checker from "vite-plugin-checker";

export default defineConfig({
  plugins: [
    react(),
    checker({
      typescript: true,
    }),
  ],
  server: {
    proxy: {
      "/api": {
        target: "http://localhost:3000",
        changeOrigin: true,
        rewrite: (path) => path.replace(/^\/api/, ""),
      },
    },
  },
});
```

Cela signifie qu'√† chaque fois qu'une requ√™te sera faite sur **`/api`** (on reste sur la m√™me origine que le serveur de fichiers statiques : **`5173`** est le port par d√©faut d'une application `Vite`), celle-ci sera redirig√©e vers le port **`3000`**, le port de l'API.
Le `rewrite` permet de ne pas reprendre **`/api`** dans l'URL de la redirection :
**`GET /api/pizzas`** devient **`GET http://localhost:3000/pizzas`**.

Pour rappel, pour ajouter les probl√®mes de linter dans le browser ainsi que dans le terminal, apr√®s la transpilation/compilation, vous pouvez utiliser le plugin **`vite-plugin-checker`** (lignes 8 √† 10 ci-dessus, et ligne 3 pour l'import).
Pour cela, il ne faut pas oublier d'installer le plugin :
```bash
npm i vite-plugin-checker -D
```


Il nous reste √† mettre √† jour les `fetch` au sein de `App` :

```ts numbered highlighting="3,29"
async function getAllPizzas() {
    try {
      const response = await fetch("/api/pizzas");

      if (!response.ok)
        throw new Error(
          `fetch error : ${response.status} : ${response.statusText}`
        );

      const pizzas = await response.json();

      return pizzas;
    } catch (err) {
      console.error("getAllPizzas::error: ", err);
      throw err;
    }
  }

  const addPizza = async (newPizza: NewPizza) => {
    try {
      const options = {
        method: "POST",
        body: JSON.stringify(newPizza),
        headers: {
          "Content-Type": "application/json",
        },
      };

      const response = await fetch("/api/pizzas", options); // fetch retourne une "promise" => on attend la r√©ponse

      if (!response.ok)
        throw new Error(
          `fetch error : ${response.status} : ${response.statusText}`
        );

      const createdPizza = await response.json(); // json() retourne une "promise" => on attend les donn√©es

      setPizzas([...pizzas, createdPizza]);
    } catch (err) {
      console.error("AddPizzaPage::error: ", err);
    }
  };
```

A ce stade-ci, tout devrait fonctionner : le menu des pizzas est affich√© suite √† l'appel √† notre RESTful API ne relaxant pas la s√©curit√© !

üç¨ Voici quelques infos non capitales pour ce cours-ci :

- Il existe une multitude de proxy pour un environnement de d√©veloppement : **`Vite development server`** et son proxy, **`VS Code proxy`**, proxy l√©ger de **`Node`** directement configurable via **`package.json`** (**`"proxy": "http://localhost:3000",`**), ...
- Il existe par exemple un proxy complet sous Node : **`http-proxy-middleware`**.
- Pour la production, lorsque vous d√©ployez une application web sur le cloud, il faudra trouver les instructions de votre provider pour voir comment configurer le proxy.  
Par exemple, pour configurer un **static file server** et son **proxy** sous **heroku** (provider de services d'h√©bergements sur le cloud), il faut configurer le fichier **`/static.json`**.

Si n√©cessaire, vous pouvez trouver le code associ√© √† ce tutoriel ici : [fetch-proxy](https://github.com/e-vinci/ts-demos/tree/main/front/fetch-proxy).

# <InternalPageTitle> Exercice 2.15 : Proxy & async / await </InternalPageTitle>

Veuillez partir d'une copie de l'exercice (`/exercises/2.10-11-12`) pour cr√©er un nouveau projet nomm√© `exercises/2.15` afin de compl√©ter l'application `myMovies`.

Nous souhaitons maintenant que toutes les donn√©es de films soient fournies par une API que vous avez d√©velopp√©es lors des premi√®res semaines de cours. Cette API se trouve normalement dans votre repo git, dans le dossier `/exercises/1.8`. Pensez √† d√©marrer cette API.  
Pour la page pr√©sentant les cin√©mas, vous pouvez continuer √† utiliser les donn√©es en dur. Pour toutes les autres pages, vous devez utiliser l'API de films.

NB : Si vous n'avez pas r√©alis√© l'exercice de cr√©ation d'une API de films, vous pouvez utiliser l'API de films fournie ici : https://github.com/e-vinci/ts-exercises/tree/main/ex1.8

A l'aide d'un proxy, et de async / await, veuillez consommer votre API de films afin :
- de lire tous les films offerts par votre API et les afficher dans votre frontend ;
- de cr√©er des films. Une fois un film cr√©√©, vous devez faire un appel √† votre API pour r√©cup√©rer tous les films et les afficher dans votre frontend.

üí≠ Une fois un film ajout√©, pourquoi faire un appel √† l'API afin d'obtenir tous les films et les afficher ? Pourquoi ne pas se satisfaire de simplement consid√©rer tous les films comme √©tant le r√©sultat du fetch pr√©c√©dent l'ajout en y ajoutant le film renvoy√© par l'API lors de l'op√©ration d'ajout ?

Une fois tout fonctionnel, veuillez faire un commit avec le message suivant : **`new:ex2.15`**.

# <InternalPageTitle> Exercice 2.15b : async / await : effacer une ressource </InternalPageTitle>

Veuillez partir d'une copie de l'exercice (`/exercises/2.15`) pour cr√©er un nouveau projet nomm√© `exercises/2.15b` afin de compl√©ter l'application `myMovies`.

Dans la page affichant les films favoris, nous souhaitons offrir la possibilit√© d'effacer un film. Pour ce faire, veuillez ajouter un bouton pour chaque film favori, qui, lorsqu'il est cliqu√©, efface le film de la liste des films favoris.

Attention, pour effacer un film, il faut faire une requ√™te de type **`DELETE`** √† l'API ; )

De m√™me, lorsque dans la HomePage l'utilisateur a s√©lectionn√© un film, la page affichant ce film doit afficher un bouton pour effacer le film.

Une fois tout fonctionnel, veuillez faire un commit avec le message suivant : **`new:ex2.15b`**.

#### üç¨ Challenge
Pensez √† ajouter une ic√¥ne de poubelle pour chaque film favori, afin de rendre l'interface plus intuitive (et plus jolie) ; )

Ainsi, vous pouvez retirer le bouton **`Delete`** et le remplacer par une ic√¥ne de poubelle.

#### Tips
- N'h√©sitez pas √† utiliser ce site qui offre des ic√¥nes sans qu'aucune installation ne soit n√©cessaire : https://heroicons.com/

Une fois tout fonctionnel, veuillez faire un commit avec le message suivant : **`new:ex2.15b+`**.