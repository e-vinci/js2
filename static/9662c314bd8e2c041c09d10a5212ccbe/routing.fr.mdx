---
title: "Routage des √©crans"
description: "Le routage des √©crans en React et l'√©tat"
---

# f) Le routage des √©crans

<InternalPageMenu>
  <PathViewer>
    <PathViewerItem to="/"> web2course </PathViewerItem>
    <PathViewerItem to="/part2"> Partie 2 </PathViewerItem>
    <PathViewerItem selected> f) Le routage des √©crans </PathViewerItem>
  </PathViewer>
  <InternalPageMenuItem> Introduction au routing </InternalPageMenuItem>
  <InternalPageMenuItem> Navigation basique entre pages </InternalPageMenuItem>
  <InternalPageMenuItem> Mise en place de React Router </InternalPageMenuItem>
  <InternalPageMenuItem> Utilisation de useNavigation </InternalPageMenuItem>
  <InternalPageMenuItem> Nested routes </InternalPageMenuItem>
  <InternalPageMenuItem> URL dynamiques </InternalPageMenuItem>
  <InternalPageMenuItem> Exercice 2.10 : React Router de base </InternalPageMenuItem>
  <InternalPageMenuItem> Comment g√©rer l'√©tat avec React Router ? </InternalPageMenuItem>
  <InternalPageMenuItem> Utilisation d'un OutletContext </InternalPageMenuItem>
    <InternalPageMenuItem> Exercice 2.11 : √âtat avec un router </InternalPageMenuItem>
  <InternalPageMenuItem> Exercice 2.12 : Routes dynamiques </InternalPageMenuItem>
</InternalPageMenu>

# <InternalPageTitle> Introduction au routing </InternalPageTitle>

Lorsqu'on parle d'une IHM, nous souhaitons g√©n√©ralement afficher diff√©rents √©crans en r√©agissant aux actions des utilisateurs.

Le routage (ou routing en anglais) est ce qui rend possible l'affichage de diff√©rents √©crans.

Dans les applications "old school" de type **Multi-Page-Application** (**MPA**), pour changer de page, il faudrait :
- Faire un clic sur un √©l√©ment qui permet de faire une requ√™te HTTP au serveur pour demander un page.
- Le browser fait la requ√™te HTTP de type GET au serveur.
- L'application serveur (le backend) s'occupe du rendu de l'HTML et le renvoie au browser (le client).
- Le browser affiche cette page.

Dans les applications que nous allons d√©velopper dans ce cours, l'architecture est compl√®tement diff√©rente. Nous d√©veloppons des **Single-Page-Applications** (**SPA**), pour changer de page :
- Il faut cliquer sur un √©l√©ment de la page permettant la navigation.
- Le JS ex√©cut√© dans le browser s'occupe de cr√©er l'illusion que l'on change de page en faisant lui-m√™me le rendu de la nouvelle page.
- Si des donn√©es sont n√©cessaires pour afficher la page, le JS ex√©cut√© dans le browser s'occupera de faire un "fetch" de celles-ci au format JSON (RESTful API) et g√©n√©rera dynamiquement l'HTML n√©cessaire.

Ainsi, dans une **SPA**, une seule page est charg√©e la toute premi√®re fois que l'on acc√®de au serveur : c'est `index.html` et tous les assets associ√©s (scripts JS, les images, CSS, sons...). Par la suite, on va utiliser un router (qui se trouvera dans un script JS) qui s'occupera de faire du "**Client Side Rendering**" (rendu c√¥t√© client de l'HTML).  

Dans nos applications `Vite + React + TS`, c'est le code transpil√© du TS vers le JS qui s'occupera :
- d'acc√©der √† un container pr√©sent dans la repr√©sentation m√©moire des √©l√©ments HTML de la page (par exemple la `div#root`).
- de mettre √† jour la repr√©sentation m√©moire de ce container avec les √©l√©ments HTML attendu pour la page demand√©.  

Ensuite, le browser n'aura plus qu'√† redessiner la page sur base de la nouvelle repr√©sentation m√©moire des √©l√©ments HTML de la page.

Notons que dans une MPA, on parle de "Server Side Rendering", car c'est le backend qui est responsable de la g√©n√©ration de l'HTML ; cela se fait souvent √† l'aide d'un moteur de templating pour g√©n√©rer des views (par exemple via `Handlebars` qui permet de g√©n√©rer des views dans une application `Node.js`).

# <InternalPageTitle> Navigation basique entre pages </InternalPageTitle>

A notre stade actuel de connaissances, nous pourrions tr√®s facilement organiser la navigation entre plusieurs page, simplement √† l'aide d'une variable d'√©tat et des gestionnaires de clics.

Pour ce tutoriel, nous allons partir d'une base de code minimaliste. Veuillez donc cr√©er un nouveau projet `Vite + React + TS` nomm√© `routing`.  
Vous ne vous souvenez plus comment faire ? Voici la commande :

```bash
npm create vite@latest routing -- --template react-swc-ts
```

Veuillez remplacer le code de `App` :
```tsx
import { useState } from "react";

const HomePage = () => <div>Home Page</div>;
const AboutPage = () => <div>About Page</div>;
const ContactPage = () => <div>Contact Page</div>;

const App = () => {
  const [currentPage, setCurrentPage] = useState("Home");

  const navigateTo = (page: string) => {
    setCurrentPage(page);
  };

  const renderPage = () => {
    switch (currentPage) {
      case "Home":
        return <HomePage />;
      case "About":
        return <AboutPage />;
      case "Contact":
        return <ContactPage />;
      default:
        return <HomePage />;
    }
  };

  return (
    <div>
      <nav>
        <button onClick={() => navigateTo("Home")}>Home</button>
        <button onClick={() => navigateTo("About")}>About</button>
        <button onClick={() => navigateTo("Contact")}>Contact</button>
      </nav>
      {renderPage()}
    </div>
  );
};

export default App;
export { HomePage, AboutPage, ContactPage };
```

Nous avons donc ici d√©fini 3 composants React qui repr√©sentent 3 pages, et une fonction qui permet, lors d'un clic, d'afficher la page associ√©e au bouton.

Veuillez ex√©cuter l'application.

Tout fonctionne bien !

üí≠ Mais qu'est-ce qui nous manque ?

Voici ce qui fait d√©faut :
- Si nous faisons un refresh de la page, nous perdons la page en cours. Par exemple, si nous sommes sur `ContactPage`, nous serons redirig√© vers `HomePage`.
- Nous n'avons pas d'historique des pages visit√©es, nous ne pouvons pas revenir en arri√®re, ni en avant dans le temps.
- Nous n'avons pas une URL sp√©cifique pour chaque √©cran.

Nous allons donc mettre en place en routeur afin de b√©n√©ficier de ces fonctions manquantes.

# <InternalPageTitle> Mise en place de React Router </InternalPageTitle>

## Introduction
`React Router` est une librairie qui fournit une belle solution pour g√©rer la navigation dans une application React.

Sa documentation est disponible ici : https://reactrouter.com/en/main

## Installation de la librairie

Dans un premier temps, il faut donc installer la librairie : 
```sh
npm i react-router-dom
```

## Mise en place de routes basiques

Dans un premier temps, nous allons voir comment cr√©er la configuration la plus simple d'un router. Veuillez mettre √† jour `/src/main.tsx` :
```tsx numbered highlighting="5,7-20,24"
import React from "react";
import ReactDOM from "react-dom/client";
import { AboutPage, ContactPage, HomePage } from "./App.tsx";
import "./index.css";
import { RouterProvider, createBrowserRouter } from "react-router-dom";

const router = createBrowserRouter([
  {
    path: "/",
    element: <HomePage />,
  },
  {
    path: "/about",
    element: <AboutPage />,
  },
  {
    path: "/contact",
    element: <ContactPage />,
  },
]);

ReactDOM.createRoot(document.getElementById("root")!).render(
  <React.StrictMode>
    <RouterProvider router={router}/>  
  </React.StrictMode>
);
```

Ici, nous avons donc `createBrowserRouter` qui cr√©e une configuration pour nos 3 routes, et chaque route va afficher une page.

Ensuite, nous utilisons le `RouterProvider` pour fournir la configuration du routeur √† l'ensemble de l'application et pour permettre aux composants de l'application d'acc√©der au contexte du router.

Pour cette premi√®re utilisation du router, nous n'allons pas tenter d'optimiser la navigation. Nous allons donc int√©grer √† chaque page une `NavBar`.  
Chaque √©l√©ment de navigation va utiliser `<Link>` comme composant pour faire le lien avec les routes que nous avons configur√©es.

Veuillez mettre √† jour le composant `App` :
```tsx numbered highlighting="1,5-7"
import { Link } from "react-router-dom";

const NavBar = () => (
  <nav>
    <Link to="/">Home</Link>
    <Link to="/about">About</Link>
    <Link to="/contact">Contact</Link>
  </nav>
);

const HomePage = () => (
  <div>
    <NavBar />
    <p>Home Page</p>
  </div>
);
const AboutPage = () => (
  <div>
    <NavBar />
    <p>About Page</p>
  </div>
);
const ContactPage = () => (
  <div>
    <NavBar />
    <p>Contact Page</p>
  </div>
);

const App = () => {
  return <div></div>;
};

export default App;
export { HomePage, AboutPage, ContactPage };
```

Veuillez lancer votre application et v√©rifier que tout fonctionne. Lorsque vous cliquez sur un lien, le router d√©tecte qu'il y a eu un changement d'√©tat, et `element` dans la configuration du router est rappel√© pour la route associ√©e, amenant au render du composant.

# <InternalPageTitle> Utilisation de useNavigation </InternalPageTitle>

Si l'on souhaite se rapprocher du design initial, nous pouvons utiliser le hook `useNavigation` qui offre une fonction pour naviguer vers une nouvelle route.

Veuillez mettre `App` √† jour :
```tsx numbered highlighting="1,7-9"
import { useNavigate } from "react-router-dom";

const NavBar = () => {
  const navigate = useNavigate();
  return (
    <nav>
      <button onClick={() => navigate("/")}>Home</button>
      <button onClick={() => navigate("/about")}>About</button>
      <button onClick={() => navigate("/contact")}> Contact</button>
    </nav>
  );
};

const HomePage = () => (
  <div>
    <NavBar />
    <p>Home Page</p>
  </div>
);
const AboutPage = () => (
  <div>
    <NavBar />
    <p>About Page</p>
  </div>
);
const ContactPage = () => (
  <div>
    <NavBar />
    <p>Contact Page</p>
  </div>
);

const App = () => {
  return <div></div>;
};

export default App;
export { HomePage, AboutPage, ContactPage };
```

Voila, nous avons un design qui ressemble au design initial.  
N'h√©sitez pas √† tester le router : 
- Faites un reload quand vous √™tes dans la `ContactPage` pour voir que vous y restez bien.
- Naviguez sur plusieurs pages, puis utiliser les fonctionnalit√©s "Back" and "Forward" pour voyager dans l'historique de votre Browser.
- V√©rifiez bien que l'URL dans le browser correspond bien √† la page demand√©e.

üí≠ Est-ce qu'il n'y a pas quelque chose qui vous d√©range dans la solution actuelle du layout de nos pages ?

Actuellement, nous int√©grons une `NavBar` dans chaque page. Cela signifie qu'√† chaque navigation d'une page √† une autre, c'est l'enti√®ret√© de la page qui doit √™tre rendue, y compris les √©l√©ments de la `Navbar`, qui pourtant ne changent pas !

Il serait int√©ressant de pouvoir d√©finir un layout de tout ce qui devrait √™tre rendu qu'une seule fois dans notre page, comme par exemple une `Navbar`.

Pour ce faire, nous allons voir les "nested routes".

# <InternalPageTitle> Nested routes </InternalPageTitle>

Il est possible de d√©finir une route parent, √ßa serait la route "racine" ici, pour afficher le squelette de nos pages.

Ensuite, nous afficherons des routes "enfants" au sein de la route "parent". Pour indiquer o√π les routes "enfants" devront s'afficher chez le "parent", nous utiliserons un `<Outlet>`.

Voici comment d√©finir la route `/` pour le squelette de l'application qui se trouvera dans `App`, puis les 3 routes "enfants" pour les 3 pages (veuillez mettre √† jour le router au sein de `main.tsx`) :
```tsx numbered highlighting="3-18"
const router = createBrowserRouter([
  {
    path: "/",
    element: <App />,
    children: [
      {
        path: "",
        element: <HomePage />,
      },
      {
        path: "about",
        element: <AboutPage />,
      },
      {
        path: "contact",
        element: <ContactPage />,
      },
    ],
  },
]);
```

Il ne nous reste plus qu'√† mettre √† jour `App` pour int√©grer le `Outlet` et pour enlever l'appel de chaque page √† la `NavBar` : 
```tsx numbered highlighting="1,15-17,21-22"
import { Outlet, useNavigate } from "react-router-dom";

const NavBar = () => {
  const navigate = useNavigate();

  return (
    <nav>
      <button onClick={() => navigate("/")}>Home</button>
      <button onClick={() => navigate("/about")}>About</button>
      <button onClick={() => navigate("/contact")}> Contact</button>
    </nav>
  );
};

const HomePage = () => <p>Home Page</p>;
const AboutPage = () => <p>About Page</p>;
const ContactPage = () => <p>Contact Page</p>;

const App = () => (
  <div>
    <NavBar />
    <Outlet />
  </div>
);

export default App;
export { HomePage, AboutPage, ContactPage };
```

Nous avons l√† un code bien propre, et une navigation parfaitement fonctionnelle !  
Il est √† noter que le code serait encore plus simple si nous utilisions le composant `Link` de la librairie (il suffirait de le styler pour qu'il ressemble √† un bouton).

# <InternalPageTitle> URL dynamiques </InternalPageTitle>

Parfois, il est int√©ressant qu'une m√™me composant soit appel√© sur toute une famille de routes. 

Par exemple, dans le composant `AboutPage`, nous souhaitons afficher une liste d'utilisateurs.  Lorsque nous cliquons sur une utilisatrice ou un utilisateur, nous souhaitons faire appel √† un nouveau composant `UserPage` qui permettra d'afficher sa page associ√©e avec comme url : `/users/:userId`.

Veuillez mettre √† jour le composant `App` pour cr√©er la `UserPage` et mettre √† jour `AboutPage` : 
```tsx numbered highlighting="19-24,29-48,50-65"
import { Link, Outlet, useMatch, useNavigate } from "react-router-dom";

const NavBar = () => {
  const navigate = useNavigate();

  return (
    <nav>
      <button onClick={() => navigate("/")}>Home</button>
      <button onClick={() => navigate("/about")}>About</button>
      <button onClick={() => navigate("/contact")}> Contact</button>
    </nav>
  );
};

const HomePage = () => <p>Home Page</p>;
const AboutPage = () => (
  <div>
    <h1>About Page</h1>
    <h2>Authors:</h2>
    {users.map((user) => (
      <Link key={user.id} to={`/users/${user.id}`} style={{ display: "block" }}>
        {user.name}
      </Link>
    ))}
  </div>
);
const ContactPage = () => <p>Contact Page</p>;

const users: User[] = [
  {
    id: 1,
    name: "John Doe",
    email: "john.doe@example.com",
    phone: "123-456-7890",
  },
  {
    id: 2,
    name: "Jane Smith",
    email: "jane.smith@example.com",
    phone: "234-567-8901",
  },
  {
    id: 3,
    name: "James Brown",
    email: "james.brown@example.com",
    phone: "345-678-9012",
  },
];

const UserPage = () => {
  const match = useMatch("/users/:userId");
  const userId = match?.params.userId;
  if (!userId) return <p>User not found</p>;

  const user = users.find((user) => user.id.toString() === userId);
  if (!user) return <p>User not found</p>;

  return (
    <div>
      <h2>{user.name}</h2>
      <p>Email: {user.email}</p>
      <p>Phone: {user.phone}</p>
    </div>
  );
};

const App = () => (
  <div>
    <NavBar />
    <Outlet />
  </div>
);

export default App;
export { HomePage, AboutPage, ContactPage, UserPage };
```

Le composant `AboutPage` contient des `Link` qui pointent vers des URL qui sont `/users/1` pour le premier user, `/users/2` pour le user qui a l'id `2`...

Pour r√©cup√©rer cette id dans la page des utilisateurs (le composant `UserPage`), nous utilisons le hook `useMatch("/users/:userId")` pour indiquer le segment dynamique de l'URL par une variable qui sera accessible via `match.params.userId`.

Pour que tout cela fonctionne, il ne reste plus qu'√† configurer le router pour cette route dynamique. Veuillez mettre √† jour la configuration du router dans `/src/main.tsx` : 
```tsx numbered highlighting="18-21"
const router = createBrowserRouter([
  {
    path: "/",
    element: <App />,
    children: [
      {
        path: "",
        element: <HomePage />,
      },
      {
        path: "about",
        element: <AboutPage />,
      },
      {
        path: "contact",
        element: <ContactPage />,
      },
      {
        path: "users/:userId",
        element: <UserPage />,
      }
    ],
  },
]);
```

Veuillez v√©rifier que tout fonctionne bien, que vous pouvez afficher la page de `James Brown`.

üí≠ Il est √† noter que si nous n'avions pas voulu cr√©er une nouvelle page mais plut√¥t afficher le d√©tail d'un utilisateur dans le composant `AboutPage`, nous aurions pour cr√©er une route "enfant" de `/about` (en utilisant un `Outlet` dans `AboutPage`).

Si n√©cessaire, vous pouvez trouver le code associ√© √† ce tutoriel ici : [routing](https://github.com/e-vinci/ts-demos/tree/main/front/routing).

# <InternalPageTitle> Exercice 2.10 : React Router de base </InternalPageTitle>

Dans vos exercices pr√©c√©dents, vous avez cr√©er une page pour afficher les films des cin√©mas UGC (`/exercises/2.6`). Vous avez aussi cr√©√© une page pour afficher vos films pr√©f√©r√©s dans un autres exercice (`/exercises/2.7`).

Nous vous proposons ici de cr√©er une nouvelle application `iMovies` qui s'occupera d'int√©grer ces contenus et de mettre en place la navigation.

Veuillez partir d'une copie de l'exercice (`/exercises/2.7`) et y int√©grer le code de l'exercice (`/exercises/2.6`) dans un nouveau projet nomm√© `exercises/2.10-11-12` pour afficher :
- Un header & un footer pour chaque page
- Une navbar (√† vous de choisir o√π la mettre)
- Une nouvelle `HomePage` qui donne quelques explications sur l'application `iMovies` (pas besoin de la peaufiner, l'id√©e est juste de travailler la mise en place de la navigation).
- Une `CinemaPage` qui reprend simplement le contenu de l'exercice (`/exercises/2.6`).
- Une `MovieListPage` qui reprend la liste de vos films selon le design de l'exercise (`/exercises/2.7`).

Une fois tout fonctionnel, veuillez faire un commit avec le message suivant : **`new:ex2.10`**.

# <InternalPageTitle> Comment g√©rer l'√©tat avec React Router ? </InternalPageTitle>

Il est possible que vous ayez remarqu√©, dans le code du router du tutoriel pr√©c√©dent, qu'il semble compliqu√©, voire impossible, de faire passer des variables d'√©tats & des fonctions pour mettre √† jour cet √©tat, entre routes...

Pour la pizzeria, l'IHM que nous avons d√©velopp√©e s'est termin√©e avec le code du tutoriel `ui-library`. N√©anmoins, pour la suite du cours, nous ne souhaitons pas vous imposer d'utiliser des composants de `Material UI`. D√®s lors, nous avons restructur√© le code pour avoir quelque chose de propre, qui contient :
- que du CSS sans composants `MUI`;
- deux pages : `HomePage` & `AddPizzaPage` ; 
- un router et une `NavBar` pour assurer la navigation.
Cette nouvelle version de l'App se trouve dans le projet `routing-starter`.

Pour ce nouveau tutoriel, veuillez cr√©er un nouveau projet `routing-state` sur base d'un copier/coller du projet [routing-starter](https://github.com/e-vinci/ts-demos/tree/main/front/routing-starter)`routing-starter`. Attention, il est normal que votre projet ne s'ex√©cute pas car il manque la gestion de l'√©tat.  
N'h√©sitez pas √† utiliser ce site pour t√©l√©charger le code du dossier routing-starter : https://download-directory.github.io/

Veuillez vous assurer que vous comprenez le code associ√© au routage des pages : `main.tsx`, `App` et `HomePage` et `AddPizzaPage` sont √† bien analyser.

Pour g√©rer l'√©tat entre siblings (deux pages ici, l'√©quivalent de deux routes), nous avons appris pr√©c√©demment qu'il fallait :
- d√©clarer l'√©tat et des fonctions pour mettre √† jour cet √©tat au niveau du parent ;
- passer cet √©tat & fonctions aux enfants (les pages ici) qui vont devoir l'utiliser.

Or ici, la relation "parent/enfant" est compliqu√©e, car :
- il y a un composant `<App>` qui contient tout le squelette de l'application, pour les 2 pages de l'application ;
- il y a un composant `<Outlet>` qui s'occupe d'appeler les composants "enfants" (les pages) en fonction de la route.

Ainsi, il n'est pas vraiment possible de classiquement faire un "drill" des variables d'√©tat et des fonctions. On ne peut pas passer les variables d'√©tat, ainsi que les fonctions pour mettre √† jour cet √©tat, de `App` vers `HomePage` et `AddMoviePage`.

Il existe plusieurs fa√ßon de g√©rer de mani√®re √©l√©gante l'√©tat de l'application. Ici, nous allons voir ce que React Router met √† notre disposition sans devoir utiliser une nouvelle librairie.

# <InternalPageTitle> Utilisation d'un OutletContext </InternalPageTitle>

Dans une route "parent", nous allons d√©finir un contexte √† l'aide du composant `Outlet`. Ce contexte peut √™tre n'importe quelle donn√©e ou fonction que nous souhaitons partager avec les routes "enfants".

Dans une route "enfant", nous pouvons acc√©der au contexte en utilisant le hook `useOutletContext`.

Commen√ßons par mettre √† jour `App` en y ajoutant la d√©finition et le passage du contexte aux routes "enfants" :
```tsx numbered highlighting="18-26,37"
const App = () => {
  const [actionToBePerformed, setActionToBePerformed] = useState(false);
  const [pizzas, setPizzas] = useState(defaultPizzas);

  const addPizza = (newPizza: NewPizza) => {
    const pizzaAdded = { ...newPizza, id: nextPizzaId(pizzas) };
    setPizzas([...pizzas, pizzaAdded]);
  };

  const handleHeaderClick = () => {
    setActionToBePerformed(true);
  };

  const clearActionToBePerformed = () => {
    setActionToBePerformed(false);
  };

  const fullPizzaContext: PizzeriaContext = {
    addPizza,
    pizzas,
    setPizzas,
    actionToBePerformed,
    setActionToBePerformed,
    clearActionToBePerformed,
    drinks,
  };

  return (
    <div className="page">
      <Header
        title="We love Pizza"
        version={0 + 1}
        handleHeaderClick={handleHeaderClick}
      />
      <main>
        <NavBar />
        <Outlet context={fullPizzaContext} />
      </main>
      <Footer />
    </div>
  );
};
```

Pour que TS soit OK au niveau des types, nous avons d√©fini un nouveau type dans `/src/types.ts` :
```ts
interface PizzeriaContext {
  pizzas: Pizza[];
  setPizzas: (pizzas: Pizza[]) => void;
  actionToBePerformed: boolean;
  setActionToBePerformed: (actionToBePerformed: boolean) => void;
  clearActionToBePerformed: () => void;
  drinks: Drink[];
  addPizza: (newPizza: NewPizza) => void;
}

export type { Pizza, NewPizza, Drink, PizzeriaContext };
```

Veuillez importer ce nouveau type dans `App`.

Maintenant, nous souhaitons mettre √† jour `HomePage` pour r√©cup√©rer, via le hook `useOutletContext`, le `PizzeriaContext` : 
```tsx numbered highlighting="2-7"
const HomePage = () => {
  const {
    actionToBePerformed,
    clearActionToBePerformed,
    pizzas,
    drinks,
  }: PizzeriaContext = useOutletContext();

  return (
    <>
      <h1>Ma Pizzeria</h1>
      <p>
        Parce que nous aimons le JS/TS, vous pouvez cliquer sur le header pour
        d√©marrer / stopper la musique ; )
      </p>
      <AudioPlayer
        sound={sound}
        actionToBePerformed={actionToBePerformed}
        clearActionToBePerformed={clearActionToBePerformed}
      />

      <PizzaMenu pizzas={pizzas} />

      <DrinkMenu title="Nos boissons" drinks={drinks} />
    </>
  );
};
```

Puis, nous souhaitons aussi mettre √† jour `AddMoviePage` pour r√©cup√©rer la fonction `addPizza` du contexte : 
```tsx
const AddPizzaPage = () => {
  const { addPizza }: PizzeriaContext = useOutletContext();
```

N'oubliez pas de faire l'import de `useOutletContext` et du type `PizzeriaContext`.
Une fois les changements effectu√©s, vous devriez avoir une application pleinement fonctionnelle, avec un routing moderne et une gestion √©l√©gante de l'√©tat.

Si n√©cessaire, vous pouvez trouver le code associ√© √† ce tutoriel ici : [routing-state](https://github.com/e-vinci/ts-demos/tree/main/front/routing-state).

# <InternalPageTitle> Exercice 2.11 : √âtat avec un router </InternalPageTitle>

Veuillez continuer votre exercice pr√©c√©dent dans le projet existant et nomm√© `exercises/2.10-11-12` en y int√©grant une `AddMoviePage` qui permette d'ajouter un film √† la liste des films. Une fois un film ajout√©, l'utilisateur est automatiquement redirig√© vers la `MovieListPage`.


Une fois tout fonctionnel, veuillez faire un commit avec le message suivant : **`new:ex2.11`**.

# <InternalPageTitle> Exercice 2.12 : Routes dynamiques </InternalPageTitle>

Veuillez continuer l'exercice pr√©c√©dent dans le projet existant et nomm√© `exercises/2.10-11-12`.

Nous vous demandons : 
- De mettre √† jour la `HomePage` afin qu'elle affiche une liste reprenant uniquement les titres de vos films favoris (sans d'autres infos associ√©es aux films telles que la description...).
- Il doit √™tre possible de pouvoir cliquer sur le titre d'un de vos films favoris et de naviguer vers une nouvelle `MoviePage` qui affichera toutes les infos de ce film-ci. Pour ce faire, vous devez ajouter un id √† vos films, et cette id doit √™tre visible dans l'URL quand les utilisateurs cliquent sur un titre donn√© dans la `HomePage`.

Une fois tout fonctionnel, veuillez faire un commit avec le message suivant : **`new:ex2.12`**.