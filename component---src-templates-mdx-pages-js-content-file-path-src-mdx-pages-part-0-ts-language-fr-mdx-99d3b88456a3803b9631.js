"use strict";(self.webpackChunkmyjscourse=self.webpackChunkmyjscourse||[]).push([[452],{7668:function(e,n,t){t.r(n),t.d(n,{default:function(){return N}});var l=t(3905),r=t(7294);function s(e){const n=Object.assign({h1:"h1",p:"p",strong:"strong",a:"a",br:"br",code:"code",ul:"ul",li:"li",h2:"h2",pre:"pre",h3:"h3"},(0,l.ah)(),e.components),{InternalPageMenu:t,PathViewer:s,PathViewerItem:a,InternalPageMenuItem:o,InternalPageTitle:u}=n;return t||i("InternalPageMenu",!0),o||i("InternalPageMenuItem",!0),u||i("InternalPageTitle",!0),s||i("PathViewer",!0),a||i("PathViewerItem",!0),r.createElement(r.Fragment,null,r.createElement(n.h1,null,"c) Introduction au TS"),"\n",r.createElement(t,null,r.createElement(s,null,r.createElement(a,{to:"/"}," web2course "),r.createElement(a,{to:"/part0"}," Partie 0 "),r.createElement(a,{selected:!0}," c) TS ")),r.createElement(o,null," Le TS, c'est quoi ? "),r.createElement(o,null," Quand d√©finir les types ? "),r.createElement(o,null," Comment d√©finir les types ? "),r.createElement(o,null," Comment contr√¥ler le flux en TS ? "),r.createElement(o,null," Comment en savoir plus sur TS ? ")),"\n",r.createElement(n.h1,null,r.createElement(u,null," Le TS, c'est quoi ? ")),"\n",r.createElement(n.p,null,r.createElement(n.strong,null,"Le TypeScript est du JavaScript avec des types"),". Ainsi, toute la syntaxe d√©crite dans l'",r.createElement(n.a,{href:"../js-language"},"introduction du JS")," est valable pour le TS."),"\n",r.createElement(n.p,null,"Le TS s'√©crit tant dans un browser que dans un environnement serveur.",r.createElement(n.br),"\n","On √©crira du TS conforme au standard que l'on souhaite voir associ√© √† JS : ",r.createElement(n.strong,null,r.createElement(n.code,null,"ECMAScript")),", ",r.createElement(n.strong,null,r.createElement(n.code,null,"CommonJS")),"..."),"\n",r.createElement(n.p,null,"Comme le monde de l'entreprise va de plus en plus vers ",r.createElement(n.code,null,"ECMAScript 6")," (ou ",r.createElement(n.code,null,"ES6"),"), nous avons choisi ",r.createElement(n.code,null,"ECMAScript")," comme standard pour ce cours."),"\n",r.createElement(n.p,null,"Nous allons voir dans cette partie les sp√©cificit√©s utiles du TS."),"\n",r.createElement(n.p,null,"Notons que le TS permet d'am√©liorer l'orient√© objet en JS, mais nous ne verrons pas ces aspects dans ce cours sauf pour quelques exceptions. Nous estimons que le d√©veloppement web moderne ne n√©cessite pas de ma√Ætriser l'orient√© objet en JS ; il nous semble plus int√©ressant de faire de la programmation fonctionnelle, tout en manipulant des objets et des types."),"\n",r.createElement(n.h1,null,r.createElement(u,null," A quel moment le TS intervient ? ")),"\n",r.createElement(n.p,null,"En TypeScript, l'intervention se fait principalement au moment de la ",r.createElement(n.strong,null,"transpilation")," (on parle aussi de compilation par abus de langage) :"),"\n",r.createElement(n.ul,null,"\n",r.createElement(n.li,null,r.createElement(n.strong,null,"Type Checking"),": TypeScript intervient lors de la transpilation, v√©rifiant les types et s'assurant que le code respecte les d√©finitions de types fournies. Cela permet de d√©tecter les erreurs de type avant l'ex√©cution."),"\n",r.createElement(n.li,null,r.createElement(n.strong,null,"Type Safety")," : TypeScript aide √† maintenir la s√©curit√© des types en obligeant √† d√©finir des types pr√©cis pour les variables, les fonctions, etc. Cela √©vite l'utilisation du type ",r.createElement(n.code,null,"any"),", qui d√©sactive les v√©rifications de type, et r√©duit les risques d'erreurs li√©es aux pointeurs nuls (null pointers)."),"\n",r.createElement(n.li,null,"Le code TypeScript est transpil√© en JavaScript. Les annotations de type sont supprim√©es et le ",r.createElement(n.strong,null,"code r√©sultant est du pur JavaScript"),"."),"\n"),"\n",r.createElement(n.p,null,"Il y a d'autres aspects importants o√π TypeScript peut intervenir, principalement :"),"\n",r.createElement(n.ul,null,"\n",r.createElement(n.li,null,r.createElement(n.strong,null,"Intellisense")," : Les √©diteurs de code et IDE qui supportent TypeScript (comme Visual Studio Code) utilisent les informations de type pour fournir des suggestions de code, auto-compl√©ter les noms de variables et de fonctions, et offrir des informations sur les signatures de fonctions."),"\n",r.createElement(n.li,null,r.createElement(n.strong,null,"Erreurs en temps r√©el")," : Pendant l'√©criture du code, les √©diteurs peuvent afficher des erreurs de type en temps r√©el, avant m√™me que le code ne soit compil√©."),"\n",r.createElement(n.li,null,r.createElement(n.strong,null,"Documentation")," : Les annotations de type servent de documentation vivante, aidant les d√©veloppeurs √† comprendre les interfaces et les attentes des fonctions."),"\n",r.createElement(n.li,null,r.createElement(n.strong,null,"Refactoring")," : Les outils de refactoring utilisent les informations de type pour effectuer des transformations de code de mani√®re s√©curis√©e (comme par exemple le ",r.createElement(n.code,null,"Quick Fix...")," de VS Code)."),"\n",r.createElement(n.li,null,r.createElement(n.strong,null,"Linting")," : Les outils comme ESLint utilisent les types pour imposer des r√®gles de style et de bonnes pratiques de code."),"\n",r.createElement(n.li,null,r.createElement(n.strong,null,"Tests")," : Les frameworks de tests peuvent utiliser les types pour g√©n√©rer des cas de test ou v√©rifier les types des donn√©es manipul√©es."),"\n",r.createElement(n.li,null,r.createElement(n.strong,null,"Runtime (indirectement)")," : M√™me si TypeScript ne v√©rifie pas les types √† l'ex√©cution, les d√©veloppeurs peuvent utiliser des gardes de type (type guards) et des assertions pour v√©rifier les types √† l'ex√©cution, ce qui ajoute une couche suppl√©mentaire de s√©curit√©."),"\n"),"\n",r.createElement(n.h1,null,r.createElement(u,null," Quand d√©finir les types ? ")),"\n",r.createElement(n.h2,null,"Introduction"),"\n",r.createElement(n.p,null,"Pour maintenir la s√©curit√© des types, il est important d'√©viter que TypeScript inf√®re le type ",r.createElement(n.code,null,"any")," pour les variables, les fonctions, les param√®tres, etc."),"\n",r.createElement(n.p,null,"Il y a beaucoup de cas o√π TS est capable d'inf√©rer le type d'une variable, d'une fonction, etc. sans que l'on ait besoin de le sp√©cifier explicitement."),"\n",r.createElement(n.h2,null,"Cas o√π il est inutile de sp√©cifier le type"),"\n",r.createElement(n.p,null,"üëç Lorsque l'inf√©rence de type est claire et √©vidente, ou lorsque l'annotation (de type) n'apporte pas de valeur ajout√©e significative en termes de lisibilit√© ou de documentation, il n'est pas recommand√© de sp√©cifier le type explicitement. Cela peut rendre le code plus verbeux et moins lisible."),"\n",r.createElement(n.p,null,"Voici quelques exemples o√π il est inutile de sp√©cifier le type :"),"\n",r.createElement(n.pre,null,r.createElement(n.code,{className:"language-ts"},"const x = 10; // TypeScript inf√®re que x est de type number\nconst y = 'hello'; // TypeScript inf√®re que y est de type string\nconst z = [1, 2, 3]; // TypeScript inf√®re que z est de type number[]\n\nfunction greet(name: string) { \n  return `Hello, ${name}!`; // Le type string est √©vident ici\n}\n")),"\n",r.createElement(n.h2,null,"Cas o√π il est important de sp√©cifier le type"),"\n",r.createElement(n.h3,null,"Type Checking"),"\n",r.createElement(n.p,null,"üëç Il est recommand√© de sp√©cifier le type lorsque TypeScript ne peut pas inf√©rer le type correctement, ou lorsque l'inf√©rence de type peut entra√Æner des erreurs potentielles difficiles √† d√©tecter."),"\n",r.createElement(n.p,null,"Voici un exemple concret o√π il est recommand√© de sp√©cifier le type :"),"\n",r.createElement(n.pre,null,r.createElement(n.code,{className:"language-ts"},"let value; // TypeScript inf√®re que value est de type any\n\nfunction setValue(newValue) { \n  value = newValue; \n}\n\nsetValue(42);\n\n// Plus tard dans le code\nconsole.log(value.toFixed(2)); // Erreur √† la compilation/transpilation : toFixed n'est pas une fonction sur type 'any'\n")),"\n",r.createElement(n.p,null,"TypeScript d√©tectera l'erreur lors de la transpilation/compilation, car value est de type ",r.createElement(n.code,null,"any")," et n'a pas de m√©thode ",r.createElement(n.code,null,"toFixed"),".\nC'est l'√©diteur de code qui indiquera cette erreur avant que le code ne soit transpil√© en JavaScript."),"\n",r.createElement(n.p,null,"Pour √©viter ce probl√®me, voici comment on peut sp√©cifier le type de ",r.createElement(n.code,null,"value")," :"),"\n",r.createElement(n.pre,null,r.createElement(n.code,{className:"language-ts"},"let value: number;\n\nfunction setValue(newValue: number) {\n    value = newValue;\n}\n\nsetValue(42);\n\n// Maintenant, TypeScript sait que value est de type number\nconsole.log(value.toFixed(2)); // Correct : affiche '42.00'\n")),"\n",r.createElement(n.p,null,"En sp√©cifiant ",r.createElement(n.code,null,"value")," comme √©tant de type ",r.createElement(n.code,null,"number"),", TypeScript peut v√©rifier statiquement que les op√©rations ult√©rieures sur ",r.createElement(n.code,null,"value")," (comme ",r.createElement(n.code,null,"toFixed(2)"),") sont appropri√©es et √©viter les erreurs potentielles qui seraient r√©v√©l√©es √† l'ex√©cution."),"\n",r.createElement(n.h3,null,"Documentation & lisibilit√©"),"\n",r.createElement(n.p,null,"üëç Pour l'aspect documentation et lisibilit√©, il est recommand√© de sp√©cifier le type des param√®tres de fonction. Concernant les valeurs de retour, m√™me si TypeScript peut les inf√©rer correctement, il est conseill√© de sp√©cifier le type de retour lorsque le corps de la fonction est volumineux. Cela rend le code plus explicite et aide les autres d√©veloppeurs √† comprendre comment utiliser la fonction sans avoir √† lire son impl√©mentation."),"\n",r.createElement(n.p,null,"Voici un exemple d'une fonction assez volumineuse o√π il est recommand√© de sp√©cifier le type de retour :"),"\n",r.createElement(n.pre,null,r.createElement(n.code,{className:"language-ts"},"function processData(data: string[]): { averageLength: number, maxLength: number } {\n    let totalLength = 0;\n    let maxLength = 0;\n\n    for (let item of data) {\n        totalLength += item.length;\n        if (item.length > maxLength) {\n            maxLength = item.length;\n        }\n    }\n\n    const averageLength = data.length > 0 ? totalLength / data.length : 0;\n\n    return { averageLength, maxLength };\n}\n")),"\n",r.createElement(n.p,null,"En sp√©cifiant le type de retour ",r.createElement(n.code,null,"{ averageLength: number, maxLength: number }"),", on documente clairement que la fonction processData produit un objet avec ces deux propri√©t√©s. Cela rend le code plus explicite et facilite la compr√©hension pour les autres d√©veloppeurs qui utilisent ou maintiennent cette fonction."),"\n",r.createElement(n.h3,null,"Maintenabilit√©"),"\n",r.createElement(n.p,null,"üëç Dans le cas o√π le type de retour est complexe ou utilis√© √† plusieurs endroits dans le code, il est int√©ressant de d√©finir une interface ou un type pour ce type de retour. Cela permet de r√©utiliser le type de retour dans d'autres parties du code et de garantir la coh√©rence des types."),"\n",r.createElement(n.p,null,"Voici ce que √ßa donnerait pour notre exemple :"),"\n",r.createElement(n.pre,null,r.createElement(n.code,{className:"language-ts"},"interface DataProcessingResult {\n  averageLength: number;\n  maxLength: number;\n}\n\nfunction processData(data: string[]): DataProcessingResult {\n  let totalLength = 0;\n  let maxLength = 0;\n\n  for (let item of data) {\n      totalLength += item.length;\n      if (item.length > maxLength) {\n          maxLength = item.length;\n      }\n  }\n\n  const averageLength = data.length > 0 ? totalLength / data.length : 0;\n\n  return { averageLength, maxLength };\n}\n")),"\n",r.createElement(n.p,null,"En d√©finissant l'interface ",r.createElement(n.code,null,"DataProcessingResult"),", on peut r√©utiliser ce type de retour dans d'autres parties du code, ce qui rend le code plus maintenable et √©vite les erreurs de type."),"\n",r.createElement(n.h1,null,r.createElement(u,null," Comment d√©finir les types ? ")),"\n",r.createElement(n.p,null,"Il existe plusieurs fa√ßons de d√©finir des types en TypeScript. Voici les principales m√©thodes :"),"\n",r.createElement(n.h2,null,"Les annotations de type"),"\n",r.createElement(n.p,null,"Les annotations de type sont des instructions qui indiquent au compilateur TypeScript le type d'une variable, d'un param√®tre de fonction, d'une valeur de retour, etc. Les annotations de type sont plac√©es apr√®s le nom de la variable, du param√®tre ou de la fonction, suivies de deux points ",r.createElement(n.strong,null,r.createElement(n.code,null,":"))," et du type souhait√©."),"\n",r.createElement(n.p,null,"Voici quelques exemples d'annotations de type :"),"\n",r.createElement(n.pre,null,r.createElement(n.code,{className:"language-ts"},'let x: number; // x est de type number\nlet y: string; // y est de type string\nlet z: number[]; // z est de type number[]\nconst numbers: number[] = [1, 2, 3]; // numbers est de type number[]\nlet isActive: boolean; // isActive est de type boolean\nlet greet: (name: string) => string; \n// greet est une fonction qui prend un param√®tre de type string et retourne une valeur de type string\nconst person: { name: string, age: number } = { name: "Alice", age: 30 };\n')),"\n",r.createElement(n.h2,null,"Les interfaces"),"\n",r.createElement(n.p,null,"Les interfaces sont des contrats qui d√©finissent la structure des objets en TypeScript. Elles permettent de d√©finir des types personnalis√©s pour les objets, les fonctions, les classes, etc. Les interfaces sont largement utilis√©es pour d√©finir des types complexes et r√©utilisables."),"\n",r.createElement(n.p,null,"Voici un exemple d'interface pour d√©finir un type de donn√©es :"),"\n",r.createElement(n.pre,null,r.createElement(n.code,{className:"language-ts"},'interface Person {\n    readonly id: number; // Propri√©t√© en lecture seule\n    name: string;\n    age: number;\n    email?: string; // Propri√©t√© optionnelle\n}\n\nconst alice: Person = { id:1, name: "Alice", age: 30 };\nconst bob: Person = { id:2, name: "Bob", age: 25, email: "bob@vinci.be" };\n\n// Tentative de modification d\'une propri√©t√© en lecture seule (erreur)\n// alice.id = 3; // Erreur: Cannot assign to \'id\' because it is a read-only property.\n')),"\n",r.createElement(n.p,null,"Notons qu'une interface peut √©tendre un type d√©fini ou une autre interface. Voici un exemple d'interface qui √©tend un type d√©fini:"),"\n",r.createElement(n.pre,null,r.createElement(n.code,{className:"language-ts"},'type Employee = { // fonctionne aussi avec une interface (interface Employee { ... })\n  name: string;\n  age: number;\n};\n\ninterface Manager extends Employee {\n  department: string;\n  manageTeam(): void;\n}\n\nconst manager: Manager = {\n  name: "Bob",\n  age: 35,\n  department: "HR",\n  manageTeam() {\n      console.log("Managing team...");\n  }\n};\n')),"\n",r.createElement(n.h2,null,"Les types"),"\n",r.createElement(n.p,null,"Les types sont similaires aux interfaces, mais ils peuvent √©galement √™tre utilis√©s pour d√©finir des types primitifs, des unions, des intersections, des tuples, etc."),"\n",r.createElement(n.p,null,"Voici un exemple de type pour d√©finir un type de donn√©es :"),"\n",r.createElement(n.pre,null,r.createElement(n.code,{className:"language-ts"},'type Person = {\n    name: string;\n    age: number;\n    email?: string; // Propri√©t√© optionnelle\n    readonly id: number; // Propri√©t√© en lecture seule\n}\n\nconst person: Person = {\n    name: "Alice",\n    age: 30,\n    id: 1\n    // email est optionnel et peut √™tre omis si n√©cessaire\n};\n')),"\n",r.createElement(n.p,null,"Notons que les types peuvent √™tre utilis√©s pour d√©finir des types primitifs, des unions, des intersections, des tuples, etc. :"),"\n",r.createElement(n.pre,null,r.createElement(n.code,{className:"language-ts"},'type ID = string | number; // Unions type\n\ntype Printable = {\n    print(): void;\n};\n\ntype Loggable = {\n    log(): void;\n};\n\ntype LoggableAndPrintable = Printable & Loggable; // Intersections de type\n\n// Utilisation du type intersection\nlet obj: LoggableAndPrintable = {\n    print() {\n        console.log("Printing...");\n    },\n    log() {\n        console.log("Logging...");\n    }\n};\n\nfunction readPizzaById(id: number): Pizza | undefined {\n  const pizzas = parse(jsonDbPath, defaultPizzas);\n  return pizzas.find((pizza) => pizza.id === id);\n} // Fonction qui retourne un type Pizza ou undefined\n')),"\n",r.createElement(n.h2,null,"Les classes"),"\n",r.createElement(n.p,null,"Les classes en TypeScript peuvent √©galement √™tre utilis√©es pour d√©finir des types. Les classes peuvent √™tre utilis√©es pour d√©finir des types d'objets avec des propri√©t√©s et des m√©thodes."),"\n",r.createElement(n.p,null,"Voici un exemple de classe pour d√©finir un type de donn√©es :"),"\n",r.createElement(n.pre,null,r.createElement(n.code,{className:"language-ts"},"class Person {\n    name: string;\n    age: number;\n    email?: string; // Propri√©t√© optionnelle\n\n    constructor(name: string, age: number, email?: string) {\n        this.name = name;\n        this.age = age;\n        this.email = email;\n    }\n}\n")),"\n",r.createElement(n.p,null,"üëç Dans ce cours, nous avons volontairement choisi de ne pas faire d'orient√© objet en JS/TS. Nous vous recommandons de ne pas utiliser les classes pour d√©finir des types, mais plut√¥t d'utiliser des interfaces ou des types."),"\n",r.createElement(n.h2,null,"Les enums"),"\n",r.createElement(n.p,null,"Les √©num√©rations (enums) sont des types de donn√©es qui permettent de d√©finir un ensemble de valeurs nomm√©es. Les √©num√©rations sont largement utilis√©es pour d√©finir des types de donn√©es avec des valeurs pr√©d√©finies."),"\n",r.createElement(n.p,null,"Voici un exemple d'√©num√©ration pour d√©finir un type de donn√©es :"),"\n",r.createElement(n.pre,null,r.createElement(n.code,{className:"language-ts"},"enum Color {\n    Red = 'red',\n    Green = 'green',\n    Blue = 'blue'\n}\n\nconst color: Color = Color.Red;\n\nif (color === Color.Red) {\n    console.log(\"It's red!\");\n}\n")),"\n",r.createElement(n.h2,null,"Generics"),"\n",r.createElement(n.p,null,"Les g√©n√©riques (generics) sont des types de donn√©es param√©tr√©s qui permettent de d√©finir des types r√©utilisables et flexibles. Les g√©n√©riques sont utilis√©s pour d√©finir des types de donn√©es qui peuvent accepter diff√©rents types de param√®tres."),"\n",r.createElement(n.p,null,"Voici un exemple de g√©n√©rique pour d√©finir un type de donn√©es :"),"\n",r.createElement(n.pre,null,r.createElement(n.code,{className:"language-ts"},'// D√©finition d\'une interface g√©n√©rique\ninterface Box<T> {\n    value: T;\n}\n\n// Utilisation de l\'interface g√©n√©rique\nconst box1: Box<number> = { value: 10 };\nconst box2: Box<string> = { value: "Hello, TypeScript!" };\nconst box3: Box = { value: true }; // le type de T est inf√©r√© comme boolean\n\nconsole.log(box1.value); // Output: 10\nconsole.log(box2.value); // Output: "Hello, TypeScript!"\nconsole.log(box3.value); // Output: true\n')),"\n",r.createElement(n.h2,null,"Interfaces vs Types"),"\n",r.createElement(n.p,null,"Les interfaces et les types sont deux fa√ßons de d√©finir des types en TypeScript. Les interfaces sont principalement utilis√©es pour d√©finir des structures d'objets (et leur contrat), tandis que les types sont utilis√©s pour d√©finir des types primitifs, des unions, des intersections..."),"\n",r.createElement(n.p,null,"üëç Dans ce cours, nous vous recommandons d'utiliser les interfaces pour d√©finir des types d'objets."),"\n",r.createElement(n.p,null,"Voici un exemple :"),"\n",r.createElement(n.pre,null,r.createElement(n.code,{className:"language-ts"},'interface Pizza {\nid: number;\ntitle: string;\ncontent: string;\n}\n\nconst pizza: Pizza = {\nid: 1,\ntitle: "Margherita",\ncontent: "Tomato, mozzarella, basilique"\n};\n')),"\n",r.createElement(n.p,null,"üëç Dans ce cours, nous vous recommandons d'utiliser les types pour d√©finir des types primitifs, des unions et des intersections, des types sur base d'interfaces..."),"\n",r.createElement(n.p,null,"Voici quelques exemples :"),"\n",r.createElement(n.pre,null,r.createElement(n.code,{className:"language-ts"},'interface AuthenticatedUser {\nusername: string;\ntoken: string;\n}\n\ntype MaybeAuthenticatedUser = AuthenticatedUser | undefined; // Union type\n\n\ninterface Pizza {\nid: number;\ntitle: string;\ncontent: string;\n}\n\ntype NewPizza = Omit<Pizza, "id">;  // Omet la propri√©t√© "id" de l\'interface Pizza\n\nfunction updatePizza(\nid: number,\nupdatedPizza: Partial<NewPizza> // Partial permet de rendre les propri√©t√©s de NewPizza optionnelles\n): Pizza {\n// ...\n}\n')),"\n",r.createElement(n.p,null,r.createElement(n.code,null,"Omit")," est un utilitaire TS qui permet de cr√©er un nouveau type en omettant certaines propri√©t√©s d'un type existant."),"\n",r.createElement(n.p,null,r.createElement(n.code,null,"Partial")," est un utilitaire TS qui permet de rendre toutes les propri√©t√©s d'un type optionnel."),"\n",r.createElement(n.h1,null,r.createElement(u,null," Comment contr√¥ler le flux en TS ? ")),"\n",r.createElement(n.h2,null,"Introduction"),"\n",r.createElement(n.p,null,"Le contr√¥le de flux vise √† garantir la s√©curit√© et la pr√©cision des types en fonction des chemins d'ex√©cution possibles."),"\n",r.createElement(n.p,null,"Le contr√¥le de flux en TypeScript se r√©f√®re g√©n√©ralement √† l'ensemble des m√©canismes par lesquels le transpilateur/compilateur analyse les chemins d'ex√©cution possibles d'un programme pour d√©terminer les types des variables. Cela inclut les v√©rifications de type conditionnelles telles que ",r.createElement(n.code,null,"if"),", ",r.createElement(n.code,null,"else"),", ",r.createElement(n.code,null,"switch"),", ainsi que les op√©rateurs de v√©rification de type comme ",r.createElement(n.code,null,"typeof"),", ",r.createElement(n.code,null,"instanceof"),", ",r.createElement(n.code,null,"in"),", et les assertions de type via ",r.createElement(n.code,null,"as"),"."),"\n",r.createElement(n.h2,null,"V√©rification de type conditionnelle"),"\n",r.createElement(n.p,null,"La v√©rification de type conditionnelle est une technique courante pour garantir la s√©curit√© des types en fonction des conditions. TypeScript utilise les instructions ",r.createElement(n.code,null,"if"),", ",r.createElement(n.code,null,"else"),", ",r.createElement(n.code,null,"switch")," pour effectuer des v√©rifications de type conditionnelles."),"\n",r.createElement(n.p,null,"Voici un exemple d'utilisation de la v√©rification de type conditionnelle avec ",r.createElement(n.code,null,"if")," :"),"\n",r.createElement(n.pre,null,r.createElement(n.code,{className:"language-ts"},'function greet(name: string | undefined) {\n    if (name) { // TypeScript sait que name est de type string ici\n        console.log(`Hello, ${name}!`); \n    } else { // TypeScript sait que name est de type undefined ici\n        console.log("Hello, stranger!");\n    }\n}\n')),"\n",r.createElement(n.p,null,"Dans cet exemple, TypeScript inf√®re que ",r.createElement(n.code,null,"name")," est de type ",r.createElement(n.code,null,"string | undefined"),". La v√©rification ",r.createElement(n.code,null,"if (name)")," permet de v√©rifier si ",r.createElement(n.code,null,"name")," est d√©fini (non ",r.createElement(n.code,null,"undefined"),") avant d'afficher le message de salutation."),"\n",r.createElement(n.h2,null,"Op√©rateurs de v√©rification de type"),"\n",r.createElement(n.p,null,"Les op√©rateurs de v√©rification de type sont des outils puissants pour garantir la s√©curit√© des types en TypeScript. Ces op√©rateurs permettent de v√©rifier le type d'une variable ou d'une expression √† l'ex√©cution."),"\n",r.createElement(n.p,null,"Voici quelques exemples d'op√©rateurs de v√©rification de type :"),"\n",r.createElement(n.h3,null,r.createElement(n.code,null,"typeof")),"\n",r.createElement(n.p,null,"L'op√©rateur ",r.createElement(n.code,null,"typeof")," permet de v√©rifier le type d'une variable ou d'une expression √† l'ex√©cution. TypeScript utilise ",r.createElement(n.code,null,"typeof")," pour effectuer des v√©rifications de type sur les variables."),"\n",r.createElement(n.pre,null,r.createElement(n.code,{className:"language-ts"},'function logType(value: unknown) {\n    if (typeof value === "string") {  // V√©rifie si value est une string\n        console.log("It\'s a string!");\n    } else if (typeof value === "number") {\n        console.log("It\'s a number!");\n    } else {\n        console.log("Unknown type!");\n    }\n}\n')),"\n",r.createElement(n.p,null,"Dans cet exemple, TypeScript utilise ",r.createElement(n.code,null,"typeof")," pour v√©rifier le type de ",r.createElement(n.code,null,"value")," et afficher un message en fonction du type d√©tect√©."),"\n",r.createElement(n.h3,null,r.createElement(n.code,null,"instanceof")),"\n",r.createElement(n.p,null,"L'op√©rateur ",r.createElement(n.code,null,"instanceof")," permet de v√©rifier si un objet est une instance d'une classe."),"\n",r.createElement(n.p,null,"Voici un exemple :"),"\n",r.createElement(n.pre,null,r.createElement(n.code,{className:"language-ts"},'class Person {\n  name: string;\n\n  constructor(name: string) {\n      this.name = name;\n  }\n}\n\nfunction greet(person: Person | unknown) {\n  if (person instanceof Person) { // V√©rifie si person est une instance de Person\n      console.log(`Hello, ${person.name}!`);\n  } else {\n      console.log("Hello, stranger!");\n  }\n}\n')),"\n",r.createElement(n.p,null,"Dans cet exemple, TypeScript utilise ",r.createElement(n.code,null,"instanceof")," pour v√©rifier si ",r.createElement(n.code,null,"person")," est une instance de ",r.createElement(n.code,null,"Person")," avant d'afficher le message de salutation. Vous ne verrez pas ce genre de code dans ce cours, car nous ne faisons pas d'orient√© objet en JS/TS."),"\n",r.createElement(n.h3,null,r.createElement(n.code,null,"in")),"\n",r.createElement(n.p,null,"L'op√©rateur ",r.createElement(n.code,null,"in")," permet de v√©rifier si une propri√©t√© existe dans un objet. TypeScript utilise ",r.createElement(n.code,null,"in")," pour effectuer des v√©rifications de type sur les propri√©t√©s d'un objet."),"\n",r.createElement(n.p,null,"Voici un exemple avec une interface ",r.createElement(n.code,null,"Person")," :"),"\n",r.createElement(n.pre,null,r.createElement(n.code,{className:"language-ts"},'interface Person {\nname: string;\nage: number;\n}\n\nfunction greet(person: Person | unknown) {\nif (person && typeof person === "object"  && "name" in person) {\n    console.log(`Hello, ${person.name}!`);\n} else {\n    console.log("Hello, stranger!");\n}\n}\n')),"\n",r.createElement(n.p,null,"Dans cet exemple, TypeScript utilise ",r.createElement(n.code,null,"in")," pour v√©rifier si la propri√©t√© ",r.createElement(n.code,null,"name")," existe dans ",r.createElement(n.code,null,"person")," avant d'afficher le message de salutation."),"\n",r.createElement(n.h3,null,"Assertions de type"),"\n",r.createElement(n.p,null,"Les assertions de type (type assertions) permettent de forcer le type d'une variable ou d'une expression √† un type sp√©cifique. TypeScript utilise les assertions de type pour effectuer des v√©rifications de type manuelles."),"\n",r.createElement(n.p,null,"Voici un exemple d'assertion de type avec ",r.createElement(n.code,null,"as")," :"),"\n",r.createElement(n.pre,null,r.createElement(n.code,{className:"language-ts"},"interface Person {\nid: number;\nusername: string;\nemail: string;\n}\n\n// Exemple de donn√©es re√ßues de l'API (simplifi√©)\nconst apiResponse: unknown = {\nid: 1,\nusername: \"john_doe\",\nemail: \"john.doe@example.com\",\n// D'autres propri√©t√©s qui ne nous int√©ressent pas pour cet exemple\n};\n\n// V√©rification de type pour garantir que 'apiResponse' est bien de type 'User'\nif (\napiResponse &&\ntypeof apiResponse === \"object\" &&\n\"id\" in apiResponse &&\n\"username\" in apiResponse &&\n\"email\" in apiResponse\n) {\nconst user: Person = {\n  id: apiResponse.id as number, // Assertion de type pour 'id'\n  username: apiResponse.username as string,   // Assertion de type pour 'username'\n  email: apiResponse.email as string,  // Assertion de type pour 'email'\n};\n\nconsole.log(user);\n}\n")),"\n",r.createElement(n.p,null,"Dans cet exemple, TypeScript utilise des assertions de type avec ",r.createElement(n.code,null,"as")," pour forcer le type des propri√©t√©s de ",r.createElement(n.code,null,"apiResponse")," √† ",r.createElement(n.code,null,"number")," et ",r.createElement(n.code,null,"string")," respectivement. Cela garantit que ",r.createElement(n.code,null,"user")," est de type ",r.createElement(n.code,null,"Person")," et √©vite les erreurs de type potentielles."),"\n",r.createElement(n.h2,null,"Conclusion"),"\n",r.createElement(n.p,null,"Le contr√¥le de flux en TypeScript est un outil puissant pour garantir la s√©curit√© des types en fonction des chemins d'ex√©cution possibles. En utilisant des v√©rifications de type conditionnelles, des op√©rateurs de v√©rification de type et des assertions de type, les d√©veloppeurs peuvent s'assurer que leur code respecte les d√©finitions de types fournies et √©viter les erreurs de type potentielles."),"\n",r.createElement(n.p,null,"Nous avons vu les fa√ßons les plus directes de contr√¥ler le flux en TS ; il existe d'autre fa√ßons (type guards, assertion functions), mais nous ne les verrons pas dans ce cours."),"\n",r.createElement(n.h1,null,r.createElement(u,null," Comment en savoir plus sur TS ? ")),"\n",r.createElement(n.p,null,"Si vous souhaitez en savoir plus sur ce langage, nous vous recommandons de consulter la documentation en ligne de ",r.createElement(n.a,{href:"https://www.typescriptlang.org"},"typescriptlang.org"),"."))}var a=function(e){void 0===e&&(e={});const{wrapper:n}=Object.assign({},(0,l.ah)(),e.components);return n?r.createElement(n,e,r.createElement(s,e)):s(e)};function i(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}var o=t(4160),u=t(5583),c=t(5679),p=t(307),d=t(7410),m=t(9523),f=t(8075),g=t(9063),E=t(1631),y=t(5772),v=t(2770),b=t(7008),h=t(9771),x=t(1218),S=(t(5258),t(9394)),q=t(4579),T=t(7743),L=t(9256),P=t(6488),z=t(5175),I=t(6387),V=t(6044);const C={Link:o.Link,Image:c.Z,Section:p.Z,Content:d.Z,Background:m.Z,SectionHeader:f.Z,SectionFooter:g.Z,PageHeader:E.Z,CodeBlock:v.Z,LinkFile:b.Z,ScrollableImage:h.Z,PublicProjectsView:x.Z,AuthenticatedBlock:S.Z,UnAuthenticatedBlock:q.Z,NestedMdxBlock:T.Z,YoutubeImage:L.Z,InternalPageMenu:P.Z,InternalPageMenuItem:z.Z,InternalPageTitle:I.Z,PathViewer:V.k,PathViewerItem:V.F};function w(e){var n,t,s,a,i;let{data:{mdx:o,allImages:c},children:p}=e;return C.PageHeader=(0,y.u)(E.Z,null==o?void 0:o.frontmatter),r.createElement(u.Z,Object.assign({},null!=o&&o.frontmatter?{frontmatter:o.frontmatter}:{},null!=o&&null!==(n=o.frontmatter)&&void 0!==n&&n.navbarExtraStyles?{navbarExtraStyles:o.frontmatter.navbarExtraStyles}:{},null!=o&&null!==(t=o.frontmatter)&&void 0!==t&&t.headerImage?{headerImage:o.frontmatter.headerImage}:{},null!=o&&null!==(s=o.frontmatter)&&void 0!==s&&s.featuredImage?{featuredImage:o.frontmatter.featuredImage}:{},null!=o&&null!==(a=o.frontmatter)&&void 0!==a&&a.title?{pageTitle:o.frontmatter.title}:{},c&&c.length>0?{allImages:c}:{}),r.createElement(l.Zo,{components:C},r.createElement("div",{className:null!=o&&null!==(i=o.frontmatter)&&void 0!==i&&i.autoMargin?"page page--auto-margin ":"page"},p)))}function N(e){return r.createElement(w,e,r.createElement(a,e))}}}]);
//# sourceMappingURL=component---src-templates-mdx-pages-js-content-file-path-src-mdx-pages-part-0-ts-language-fr-mdx-99d3b88456a3803b9631.js.map