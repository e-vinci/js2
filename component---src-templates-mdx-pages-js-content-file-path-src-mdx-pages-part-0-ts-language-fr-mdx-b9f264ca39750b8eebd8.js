"use strict";(self.webpackChunkmyjscourse=self.webpackChunkmyjscourse||[]).push([[7834],{6258:function(e,n,t){t.r(n),t.d(n,{default:function(){return j}});var r=t(5680),l=t(6540);function a(e){const n=Object.assign({h1:"h1",p:"p",strong:"strong",a:"a",br:"br",code:"code",ul:"ul",li:"li",h2:"h2",pre:"pre",h3:"h3",h4:"h4"},(0,r.RP)(),e.components),{InternalPageMenu:t,PathViewer:a,PathViewerItem:s,InternalPageMenuItem:o,InternalPageTitle:u}=n;return t||i("InternalPageMenu",!0),o||i("InternalPageMenuItem",!0),u||i("InternalPageTitle",!0),a||i("PathViewer",!0),s||i("PathViewerItem",!0),l.createElement(l.Fragment,null,l.createElement(n.h1,null,"c) Introduction au TS"),"\n",l.createElement(t,null,l.createElement(a,null,l.createElement(s,{to:"/"}," web2course "),l.createElement(s,{to:"/part0"}," Partie 0 "),l.createElement(s,{selected:!0}," c) TS ")),l.createElement(o,null," Le TS, c'est quoi ? "),l.createElement(o,null," A quel moment le TS intervient ? "),l.createElement(o,null," Quand d√©finir les types ? "),l.createElement(o,null," Comment d√©finir les types ? "),l.createElement(o,null," Comment contr√¥ler le flux en TS ? "),l.createElement(o,null," R√©duction de type plus avanc√©e "),l.createElement(o,null," Comment en savoir plus sur TS ? ")),"\n",l.createElement(n.h1,null,l.createElement(u,null," Le TS, c'est quoi ? ")),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"Le TypeScript est du JavaScript avec des types"),". Ainsi, toute la syntaxe d√©crite dans l'",l.createElement(n.a,{href:"../js-language"},"introduction du JS")," est valable pour le TS."),"\n",l.createElement(n.p,null,"Le TS s'√©crit tant dans un browser que dans un environnement serveur.",l.createElement(n.br),"\n","On √©crira du TS conforme au standard que l'on souhaite voir associ√© √† JS : ",l.createElement(n.strong,null,l.createElement(n.code,null,"ECMAScript")),", ",l.createElement(n.strong,null,l.createElement(n.code,null,"CommonJS")),"..."),"\n",l.createElement(n.p,null,"Comme le monde de l'entreprise va de plus en plus vers ",l.createElement(n.code,null,"ECMAScript 6")," (ou ",l.createElement(n.code,null,"ES6"),"), nous avons choisi ",l.createElement(n.code,null,"ECMAScript")," comme standard pour ce cours."),"\n",l.createElement(n.p,null,"Nous allons voir dans cette partie les sp√©cificit√©s utiles du TS."),"\n",l.createElement(n.p,null,"Notons que le TS permet d'am√©liorer l'orient√© objet en JS, mais nous ne verrons pas ces aspects dans ce cours sauf pour quelques exceptions. Nous estimons que le d√©veloppement web moderne ne n√©cessite pas de ma√Ætriser l'orient√© objet en JS ; il nous semble plus int√©ressant de faire de la programmation fonctionnelle, tout en manipulant des objets et des types."),"\n",l.createElement(n.h1,null,l.createElement(u,null," A quel moment le TS intervient ? ")),"\n",l.createElement(n.p,null,"En TypeScript, l'intervention se fait principalement au moment de la ",l.createElement(n.strong,null,"transpilation")," (on parle aussi de compilation par abus de langage) :"),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Type Checking"),": TypeScript intervient lors de la transpilation, v√©rifiant les types et s'assurant que le code respecte les d√©finitions de types fournies. Cela permet de d√©tecter les erreurs de type avant l'ex√©cution."),"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Type Safety")," : TypeScript aide √† maintenir la s√©curit√© des types en obligeant √† d√©finir des types pr√©cis pour les variables, les fonctions, etc. Cela √©vite l'utilisation du type ",l.createElement(n.code,null,"any"),", qui d√©sactive les v√©rifications de type, et r√©duit les risques d'erreurs li√©es aux pointeurs nuls (null pointers)."),"\n",l.createElement(n.li,null,"Le code TypeScript est transpil√© en JavaScript. Les annotations de type sont supprim√©es et le ",l.createElement(n.strong,null,"code r√©sultant est du pur JavaScript"),"."),"\n"),"\n",l.createElement(n.p,null,"Il y a d'autres aspects importants o√π TypeScript peut intervenir, principalement :"),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Intellisense")," : Les √©diteurs de code et IDE qui supportent TypeScript (comme Visual Studio Code) utilisent les informations de type pour fournir des suggestions de code, auto-compl√©ter les noms de variables et de fonctions, et offrir des informations sur les signatures de fonctions."),"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Erreurs en temps r√©el")," : Pendant l'√©criture du code, les √©diteurs peuvent afficher des erreurs de type en temps r√©el, avant m√™me que le code ne soit compil√©."),"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Documentation")," : Les annotations de type servent de documentation vivante, aidant les d√©veloppeurs √† comprendre les interfaces et les attentes des fonctions."),"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Refactoring")," : Les outils de refactoring utilisent les informations de type pour effectuer des transformations de code de mani√®re s√©curis√©e (comme par exemple le ",l.createElement(n.code,null,"Quick Fix...")," de VS Code)."),"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Linting")," : Les outils comme ESLint utilisent les types pour imposer des r√®gles de style et de bonnes pratiques de code."),"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Tests")," : Les frameworks de tests peuvent utiliser les types pour g√©n√©rer des cas de test ou v√©rifier les types des donn√©es manipul√©es."),"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Runtime (indirectement)")," : M√™me si TypeScript ne v√©rifie pas les types √† l'ex√©cution, les d√©veloppeurs peuvent utiliser des gardes de type (type guards) et des assertions pour v√©rifier les types √† l'ex√©cution, ce qui ajoute une couche suppl√©mentaire de s√©curit√©."),"\n"),"\n",l.createElement(n.h1,null,l.createElement(u,null," Quand d√©finir les types ? ")),"\n",l.createElement(n.h2,null,"Introduction"),"\n",l.createElement(n.p,null,"Pour maintenir la s√©curit√© des types, il est important d'√©viter que TypeScript inf√®re le type ",l.createElement(n.code,null,"any")," pour les variables, les fonctions, les param√®tres, etc."),"\n",l.createElement(n.p,null,"Il y a beaucoup de cas o√π TS est capable d'inf√©rer le type d'une variable, d'une fonction, etc. sans que l'on ait besoin de le sp√©cifier explicitement."),"\n",l.createElement(n.h2,null,"Cas o√π il est inutile de sp√©cifier le type"),"\n",l.createElement(n.p,null,"üëç Lorsque l'inf√©rence de type est claire et √©vidente, ou lorsque l'annotation (de type) n'apporte pas de valeur ajout√©e significative en termes de lisibilit√© ou de documentation, il n'est pas recommand√© de sp√©cifier le type explicitement. Cela peut rendre le code plus verbeux et moins lisible."),"\n",l.createElement(n.p,null,"Voici quelques exemples o√π il est inutile de sp√©cifier le type :"),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-ts"},"const x = 10; // TypeScript inf√®re que x est de type number\r\nconst y = 'hello'; // TypeScript inf√®re que y est de type string\r\nconst z = [1, 2, 3]; // TypeScript inf√®re que z est de type number[]\r\n\r\nfunction greet(name: string) { \r\n  return `Hello, ${name}!`; // Le type string est √©vident ici\r\n}\n")),"\n",l.createElement(n.h2,null,"Cas o√π il est important de sp√©cifier le type"),"\n",l.createElement(n.h3,null,"Type Checking"),"\n",l.createElement(n.p,null,"üëç Il est recommand√© de sp√©cifier le type lorsque TypeScript ne peut pas inf√©rer le type correctement, ou lorsque l'inf√©rence de type peut entra√Æner des erreurs potentielles difficiles √† d√©tecter."),"\n",l.createElement(n.p,null,"Voici un exemple concret o√π il est recommand√© de sp√©cifier le type :"),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-ts"},"let value; // TypeScript inf√®re que value est de type any\r\n\r\nfunction setValue(newValue) { \r\n  value = newValue; \r\n}\r\n\r\nsetValue(42);\r\n\r\n// Plus tard dans le code\r\nconsole.log(value.toFixed(2)); // Erreur √† la compilation/transpilation : toFixed n'est pas une fonction sur type 'any'\n")),"\n",l.createElement(n.p,null,"TypeScript d√©tectera l'erreur lors de la transpilation/compilation, car value est de type ",l.createElement(n.code,null,"any")," et n'a pas de m√©thode ",l.createElement(n.code,null,"toFixed"),".\r\nC'est l'√©diteur de code qui indiquera cette erreur avant que le code ne soit transpil√© en JavaScript."),"\n",l.createElement(n.p,null,"Pour √©viter ce probl√®me, voici comment on peut sp√©cifier le type de ",l.createElement(n.code,null,"value")," :"),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-ts"},"let value: number;\r\n\r\nfunction setValue(newValue: number) {\r\n    value = newValue;\r\n}\r\n\r\nsetValue(42);\r\n\r\n// Maintenant, TypeScript sait que value est de type number\r\nconsole.log(value.toFixed(2)); // Correct : affiche '42.00'\n")),"\n",l.createElement(n.p,null,"En sp√©cifiant ",l.createElement(n.code,null,"value")," comme √©tant de type ",l.createElement(n.code,null,"number"),", TypeScript peut v√©rifier statiquement que les op√©rations ult√©rieures sur ",l.createElement(n.code,null,"value")," (comme ",l.createElement(n.code,null,"toFixed(2)"),") sont appropri√©es et √©viter les erreurs potentielles qui seraient r√©v√©l√©es √† l'ex√©cution."),"\n",l.createElement(n.h3,null,"Documentation & lisibilit√©"),"\n",l.createElement(n.p,null,"üëç Pour l'aspect documentation et lisibilit√©, il est recommand√© de sp√©cifier le type des param√®tres de fonction. Concernant les valeurs de retour, m√™me si TypeScript peut les inf√©rer correctement, il est conseill√© de sp√©cifier le type de retour lorsque le corps de la fonction est volumineux. Cela rend le code plus explicite et aide les autres d√©veloppeurs √† comprendre comment utiliser la fonction sans avoir √† lire son impl√©mentation."),"\n",l.createElement(n.p,null,"Voici un exemple d'une fonction assez volumineuse o√π il est recommand√© de sp√©cifier le type de retour :"),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-ts"},"function processData(data: string[]): { averageLength: number, maxLength: number } {\r\n    let totalLength = 0;\r\n    let maxLength = 0;\r\n\r\n    for (let item of data) {\r\n        totalLength += item.length;\r\n        if (item.length > maxLength) {\r\n            maxLength = item.length;\r\n        }\r\n    }\r\n\r\n    const averageLength = data.length > 0 ? totalLength / data.length : 0;\r\n\r\n    return { averageLength, maxLength };\r\n}\n")),"\n",l.createElement(n.p,null,"En sp√©cifiant le type de retour ",l.createElement(n.code,null,"{ averageLength: number, maxLength: number }"),", on documente clairement que la fonction processData produit un objet avec ces deux propri√©t√©s. Cela rend le code plus explicite et facilite la compr√©hension pour les autres d√©veloppeurs qui utilisent ou maintiennent cette fonction."),"\n",l.createElement(n.h3,null,"Maintenabilit√©"),"\n",l.createElement(n.p,null,"üëç Dans le cas o√π le type de retour est complexe ou utilis√© √† plusieurs endroits dans le code, il est int√©ressant de d√©finir une interface ou un type pour ce type de retour. Cela permet de r√©utiliser le type de retour dans d'autres parties du code et de garantir la coh√©rence des types."),"\n",l.createElement(n.p,null,"Voici ce que √ßa donnerait pour notre exemple :"),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-ts"},"interface DataProcessingResult {\r\n  averageLength: number;\r\n  maxLength: number;\r\n}\r\n\r\nfunction processData(data: string[]): DataProcessingResult {\r\n  let totalLength = 0;\r\n  let maxLength = 0;\r\n\r\n  for (let item of data) {\r\n      totalLength += item.length;\r\n      if (item.length > maxLength) {\r\n          maxLength = item.length;\r\n      }\r\n  }\r\n\r\n  const averageLength = data.length > 0 ? totalLength / data.length : 0;\r\n\r\n  return { averageLength, maxLength };\r\n}\n")),"\n",l.createElement(n.p,null,"En d√©finissant l'interface ",l.createElement(n.code,null,"DataProcessingResult"),", on peut r√©utiliser ce type de retour dans d'autres parties du code, ce qui rend le code plus maintenable et √©vite les erreurs de type."),"\n",l.createElement(n.h1,null,l.createElement(u,null," Comment d√©finir les types ? ")),"\n",l.createElement(n.p,null,"Il existe plusieurs fa√ßons de d√©finir des types en TypeScript. Voici les principales m√©thodes :"),"\n",l.createElement(n.h2,null,"Les annotations de type"),"\n",l.createElement(n.p,null,"Les annotations de type sont des instructions qui indiquent au compilateur TypeScript le type d'une variable, d'un param√®tre de fonction, d'une valeur de retour, etc. Les annotations de type sont plac√©es apr√®s le nom de la variable, du param√®tre ou de la fonction, suivies de deux points ",l.createElement(n.strong,null,l.createElement(n.code,null,":"))," et du type souhait√©."),"\n",l.createElement(n.p,null,"Voici quelques exemples d'annotations de type :"),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-ts"},'let x: number; // x est de type number\r\nlet y: string; // y est de type string\r\nlet z: number[]; // z est de type number[]\r\nconst numbers: number[] = [1, 2, 3]; // numbers est de type number[]\r\nlet isActive: boolean; // isActive est de type boolean\r\nlet greet: (name: string) => string; \r\n// greet est une fonction qui prend un param√®tre de type string et retourne une valeur de type string\r\nconst person: { name: string, age: number } = { name: "Alice", age: 30 };\n')),"\n",l.createElement(n.h2,null,"Les interfaces"),"\n",l.createElement(n.p,null,"Les interfaces sont des contrats qui d√©finissent la structure des objets en TypeScript. Elles permettent de d√©finir des types personnalis√©s pour les objets, les fonctions, les classes, etc. Les interfaces sont largement utilis√©es pour d√©finir des types complexes et r√©utilisables."),"\n",l.createElement(n.p,null,"Voici un exemple d'interface pour d√©finir un type de donn√©es :"),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-ts"},'interface Person {\r\n    readonly id: number; // Propri√©t√© en lecture seule\r\n    name: string;\r\n    age: number;\r\n    email?: string; // Propri√©t√© optionnelle\r\n}\r\n\r\nconst alice: Person = { id:1, name: "Alice", age: 30 };\r\nconst bob: Person = { id:2, name: "Bob", age: 25, email: "bob@vinci.be" };\r\n\r\n// Tentative de modification d\'une propri√©t√© en lecture seule (erreur)\r\n// alice.id = 3; // Erreur: Cannot assign to \'id\' because it is a read-only property.\n')),"\n",l.createElement(n.p,null,"Notons qu'une interface peut √©tendre un type d√©fini ou une autre interface. Voici un exemple d'interface qui √©tend un type d√©fini:"),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-ts"},'type Employee = { // fonctionne aussi avec une interface (interface Employee { ... })\r\n  name: string;\r\n  age: number;\r\n};\r\n\r\ninterface Manager extends Employee {\r\n  department: string;\r\n  manageTeam(): void;\r\n}\r\n\r\nconst manager: Manager = {\r\n  name: "Bob",\r\n  age: 35,\r\n  department: "HR",\r\n  manageTeam() {\r\n      console.log("Managing team...");\r\n  }\r\n};\n')),"\n",l.createElement(n.h2,null,"Les types"),"\n",l.createElement(n.p,null,"Les types sont similaires aux interfaces, mais ils peuvent √©galement √™tre utilis√©s pour d√©finir des types primitifs, des unions, des intersections, des tuples, etc."),"\n",l.createElement(n.p,null,"Voici un exemple de type pour d√©finir un type de donn√©es :"),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-ts"},'type Person = {\r\n    name: string;\r\n    age: number;\r\n    email?: string; // Propri√©t√© optionnelle\r\n    readonly id: number; // Propri√©t√© en lecture seule\r\n}\r\n\r\nconst person: Person = {\r\n    name: "Alice",\r\n    age: 30,\r\n    id: 1\r\n    // email est optionnel et peut √™tre omis si n√©cessaire\r\n};\n')),"\n",l.createElement(n.p,null,"Notons que les types peuvent √™tre utilis√©s pour d√©finir des types primitifs, des unions, des intersections, des tuples, etc. :"),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-ts"},'type ID = string | number; // Unions type\r\n\r\ntype Printable = {\r\n    print(): void;\r\n};\r\n\r\ntype Loggable = {\r\n    log(): void;\r\n};\r\n\r\ntype LoggableAndPrintable = Printable & Loggable; // Intersections de type\r\n\r\n// Utilisation du type intersection\r\nlet obj: LoggableAndPrintable = {\r\n    print() {\r\n        console.log("Printing...");\r\n    },\r\n    log() {\r\n        console.log("Logging...");\r\n    }\r\n};\r\n\r\nfunction readPizzaById(id: number): Pizza | undefined {\r\n  const pizzas = parse(jsonDbPath, defaultPizzas);\r\n  return pizzas.find((pizza) => pizza.id === id);\r\n} // Fonction qui retourne un type Pizza ou undefined\n')),"\n",l.createElement(n.h2,null,"Les classes"),"\n",l.createElement(n.p,null,"Les classes en TypeScript peuvent √©galement √™tre utilis√©es pour d√©finir des types. Les classes peuvent √™tre utilis√©es pour d√©finir des types d'objets avec des propri√©t√©s et des m√©thodes."),"\n",l.createElement(n.p,null,"Voici un exemple de classe pour d√©finir un type de donn√©es :"),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-ts"},"class Person {\r\n    name: string;\r\n    age: number;\r\n    email?: string; // Propri√©t√© optionnelle\r\n\r\n    constructor(name: string, age: number, email?: string) {\r\n        this.name = name;\r\n        this.age = age;\r\n        this.email = email;\r\n    }\r\n}\n")),"\n",l.createElement(n.p,null,"üëç Dans ce cours, nous avons volontairement choisi de ne pas faire d'orient√© objet en JS/TS. Nous vous recommandons de ne pas utiliser les classes pour d√©finir des types, mais plut√¥t d'utiliser des interfaces ou des types."),"\n",l.createElement(n.h2,null,"Les enums"),"\n",l.createElement(n.p,null,"Les √©num√©rations (enums) sont des types de donn√©es qui permettent de d√©finir un ensemble de valeurs nomm√©es. Les √©num√©rations sont largement utilis√©es pour d√©finir des types de donn√©es avec des valeurs pr√©d√©finies."),"\n",l.createElement(n.p,null,"Voici un exemple d'√©num√©ration pour d√©finir un type de donn√©es :"),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-ts"},"enum Color {\r\n    Red = 'red',\r\n    Green = 'green',\r\n    Blue = 'blue'\r\n}\r\n\r\nconst color: Color = Color.Red;\r\n\r\nif (color === Color.Red) {\r\n    console.log(\"It's red!\");\r\n}\n")),"\n",l.createElement(n.h2,null,"Generics"),"\n",l.createElement(n.p,null,"Les g√©n√©riques (generics) sont des types de donn√©es param√©tr√©s qui permettent de d√©finir des types r√©utilisables et flexibles. Les g√©n√©riques sont utilis√©s pour d√©finir des types de donn√©es qui peuvent accepter diff√©rents types de param√®tres."),"\n",l.createElement(n.p,null,"Voici un exemple de g√©n√©rique pour d√©finir un type de donn√©es :"),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-ts"},'// D√©finition d\'une interface g√©n√©rique\r\ninterface Box<T> {\r\n    value: T;\r\n}\r\n\r\n// Utilisation de l\'interface g√©n√©rique\r\nconst box1: Box<number> = { value: 10 };\r\nconst box2: Box<string> = { value: "Hello, TypeScript!" };\r\nconst box3: Box = { value: true }; // le type de T est inf√©r√© comme boolean\r\n\r\nconsole.log(box1.value); // Output: 10\r\nconsole.log(box2.value); // Output: "Hello, TypeScript!"\r\nconsole.log(box3.value); // Output: true\n')),"\n",l.createElement(n.h2,null,"Interfaces vs Types"),"\n",l.createElement(n.p,null,"Les interfaces et les types sont deux fa√ßons de d√©finir des types en TypeScript. Les interfaces sont principalement utilis√©es pour d√©finir des structures d'objets (et leur contrat), tandis que les types sont utilis√©s pour d√©finir des types primitifs, des unions, des intersections..."),"\n",l.createElement(n.p,null,"üëç Dans ce cours, nous vous recommandons d'utiliser les interfaces pour d√©finir des types d'objets."),"\n",l.createElement(n.p,null,"Voici un exemple :"),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-ts"},'interface Pizza {\r\nid: number;\r\ntitle: string;\r\ncontent: string;\r\n}\r\n\r\nconst pizza: Pizza = {\r\nid: 1,\r\ntitle: "Margherita",\r\ncontent: "Tomato, mozzarella, basilique"\r\n};\n')),"\n",l.createElement(n.p,null,"üëç Dans ce cours, nous vous recommandons d'utiliser les types pour d√©finir des types primitifs, des unions et des intersections, des types sur base d'interfaces..."),"\n",l.createElement(n.p,null,"Voici quelques exemples :"),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-ts"},'interface AuthenticatedUser {\r\nusername: string;\r\ntoken: string;\r\n}\r\n\r\ntype MaybeAuthenticatedUser = AuthenticatedUser | undefined; // Union type\r\n\r\n\r\ninterface Pizza {\r\nid: number;\r\ntitle: string;\r\ncontent: string;\r\n}\r\n\r\ntype NewPizza = Omit<Pizza, "id">;  // Omet la propri√©t√© "id" de l\'interface Pizza\r\n\r\nfunction updatePizza(\r\nid: number,\r\nupdatedPizza: Partial<NewPizza> // Partial permet de rendre les propri√©t√©s de NewPizza optionnelles\r\n): Pizza {\r\n// ...\r\n}\n')),"\n",l.createElement(n.p,null,l.createElement(n.code,null,"Omit")," est un utilitaire TS qui permet de cr√©er un nouveau type en omettant certaines propri√©t√©s d'un type existant."),"\n",l.createElement(n.p,null,l.createElement(n.code,null,"Partial")," est un utilitaire TS qui permet de rendre toutes les propri√©t√©s d'un type optionnel."),"\n",l.createElement(n.h1,null,l.createElement(u,null," Comment contr√¥ler le flux en TS ? ")),"\n",l.createElement(n.h2,null,"Introduction"),"\n",l.createElement(n.p,null,"Le contr√¥le de flux vise √† garantir la s√©curit√© et la pr√©cision des types en fonction des chemins d'ex√©cution possibles."),"\n",l.createElement(n.p,null,"Le contr√¥le de flux en TypeScript se r√©f√®re g√©n√©ralement √† l'ensemble des m√©canismes par lesquels le transpilateur/compilateur analyse les chemins d'ex√©cution possibles d'un programme pour d√©terminer les types des variables. Cela inclut les v√©rifications de type conditionnelles telles que ",l.createElement(n.code,null,"if"),", ",l.createElement(n.code,null,"else"),", ",l.createElement(n.code,null,"switch"),", ainsi que les op√©rateurs de v√©rification de type comme ",l.createElement(n.code,null,"typeof"),", ",l.createElement(n.code,null,"instanceof"),", ",l.createElement(n.code,null,"in"),", et les assertions de type via ",l.createElement(n.code,null,"as"),"."),"\n",l.createElement(n.h2,null,"V√©rification de type conditionnelle"),"\n",l.createElement(n.p,null,"La v√©rification de type conditionnelle est une technique courante pour garantir la s√©curit√© des types en fonction des conditions. TypeScript utilise les instructions ",l.createElement(n.code,null,"if"),", ",l.createElement(n.code,null,"else"),", ",l.createElement(n.code,null,"switch")," pour effectuer des v√©rifications de type conditionnelles."),"\n",l.createElement(n.p,null,"Voici un exemple d'utilisation de la v√©rification de type conditionnelle avec ",l.createElement(n.code,null,"if")," :"),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-ts"},'function greet(name: string | undefined) {\r\n    if (name) { // TypeScript sait que name est de type string ici\r\n        console.log(`Hello, ${name}!`); \r\n    } else { // TypeScript sait que name est de type undefined ici\r\n        console.log("Hello, stranger!");\r\n    }\r\n}\n')),"\n",l.createElement(n.p,null,"Dans cet exemple, TypeScript inf√®re que ",l.createElement(n.code,null,"name")," est de type ",l.createElement(n.code,null,"string | undefined"),". La v√©rification ",l.createElement(n.code,null,"if (name)")," permet de v√©rifier si ",l.createElement(n.code,null,"name")," est d√©fini (non ",l.createElement(n.code,null,"undefined"),") avant d'afficher le message de salutation."),"\n",l.createElement(n.h2,null,"Op√©rateurs de v√©rification de type"),"\n",l.createElement(n.p,null,"Les op√©rateurs de v√©rification de type sont des outils puissants pour garantir la s√©curit√© des types en TypeScript. Ces op√©rateurs permettent de v√©rifier le type d'une variable ou d'une expression √† l'ex√©cution."),"\n",l.createElement(n.p,null,"Voici quelques exemples d'op√©rateurs de v√©rification de type :"),"\n",l.createElement(n.h3,null,l.createElement(n.code,null,"typeof")),"\n",l.createElement(n.p,null,"L'op√©rateur ",l.createElement(n.code,null,"typeof")," permet de v√©rifier le type d'une variable ou d'une expression √† l'ex√©cution. TypeScript utilise ",l.createElement(n.code,null,"typeof")," pour effectuer des v√©rifications de type sur les variables."),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-ts"},'function logType(value: unknown) {\r\n    if (typeof value === "string") {  // V√©rifie si value est une string\r\n        console.log("It\'s a string!");\r\n    } else if (typeof value === "number") {\r\n        console.log("It\'s a number!");\r\n    } else {\r\n        console.log("Unknown type!");\r\n    }\r\n}\n')),"\n",l.createElement(n.p,null,"Dans cet exemple, TypeScript utilise ",l.createElement(n.code,null,"typeof")," pour v√©rifier le type de ",l.createElement(n.code,null,"value")," et afficher un message en fonction du type d√©tect√©."),"\n",l.createElement(n.h3,null,l.createElement(n.code,null,"instanceof")),"\n",l.createElement(n.p,null,"L'op√©rateur ",l.createElement(n.code,null,"instanceof")," permet de v√©rifier si un objet est une instance d'une classe."),"\n",l.createElement(n.p,null,"Voici un exemple :"),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-ts"},'class Person {\r\n  name: string;\r\n\r\n  constructor(name: string) {\r\n      this.name = name;\r\n  }\r\n}\r\n\r\nfunction greet(person: Person | unknown) {\r\n  if (person instanceof Person) { // V√©rifie si person est une instance de Person\r\n      console.log(`Hello, ${person.name}!`);\r\n  } else {\r\n      console.log("Hello, stranger!");\r\n  }\r\n}\n')),"\n",l.createElement(n.p,null,"Dans cet exemple, TypeScript utilise ",l.createElement(n.code,null,"instanceof")," pour v√©rifier si ",l.createElement(n.code,null,"person")," est une instance de ",l.createElement(n.code,null,"Person")," avant d'afficher le message de salutation. Vous ne verrez pas ce genre de code dans ce cours, car nous ne faisons pas d'orient√© objet en JS/TS."),"\n",l.createElement(n.h3,null,l.createElement(n.code,null,"in")),"\n",l.createElement(n.p,null,"L'op√©rateur ",l.createElement(n.code,null,"in")," permet de v√©rifier si une propri√©t√© existe dans un objet. TypeScript utilise ",l.createElement(n.code,null,"in")," pour effectuer des v√©rifications de type sur les propri√©t√©s d'un objet."),"\n",l.createElement(n.p,null,"Voici un exemple avec une interface ",l.createElement(n.code,null,"Person")," :"),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-ts"},'interface Person {\r\nname: string;\r\nage: number;\r\n}\r\n\r\nfunction greet(person: Person | unknown) {\r\nif (person && typeof person === "object"  && "name" in person) {\r\n    console.log(`Hello, ${person.name}!`);\r\n} else {\r\n    console.log("Hello, stranger!");\r\n}\r\n}\n')),"\n",l.createElement(n.p,null,"Dans cet exemple, TypeScript utilise ",l.createElement(n.code,null,"in")," pour v√©rifier si la propri√©t√© ",l.createElement(n.code,null,"name")," existe dans ",l.createElement(n.code,null,"person")," avant d'afficher le message de salutation."),"\n",l.createElement(n.h3,null,"Assertions de type"),"\n",l.createElement(n.p,null,"Les assertions de type (type assertions) permettent de forcer le type d'une variable ou d'une expression √† un type sp√©cifique. TypeScript utilise les assertions de type pour effectuer des v√©rifications de type manuelles."),"\n",l.createElement(n.p,null,"Attention, les assertions de type ne changent pas le comportement √† l'ex√©cution de votre code ! Il est donc important d'utiliser les assertions de type que quand vous √™tes s√ªr du type de la variable ! A utiliser avec pr√©caution et parcimonie."),"\n",l.createElement(n.h4,null,"Assertions de type avec ",l.createElement(n.code,null,"as")),"\n",l.createElement(n.p,null,"Voici un exemple d'assertion de type avec ",l.createElement(n.code,null,"as")," :"),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-ts"},"interface Person {\r\nid: number;\r\nusername: string;\r\nemail: string;\r\n}\r\n\r\n// Exemple de donn√©es re√ßues de l'API (simplifi√©)\r\nconst apiResponse: unknown = {\r\nid: 1,\r\nusername: \"john_doe\",\r\nemail: \"john.doe@example.com\",\r\n// D'autres propri√©t√©s qui ne nous int√©ressent pas pour cet exemple\r\n};\r\n\r\n// V√©rification de type pour garantir que 'apiResponse' est bien de type 'User'\r\nif (\r\napiResponse &&\r\ntypeof apiResponse === \"object\" &&\r\n\"id\" in apiResponse &&\r\n\"username\" in apiResponse &&\r\n\"email\" in apiResponse\r\n) {\r\nconst user: Person = {\r\n  id: apiResponse.id as number, // Assertion de type pour 'id'\r\n  username: apiResponse.username as string,   // Assertion de type pour 'username'\r\n  email: apiResponse.email as string,  // Assertion de type pour 'email'\r\n};\r\n\r\nconsole.log(user);\r\n}\n")),"\n",l.createElement(n.p,null,"Dans cet exemple, TypeScript utilise des assertions de type avec ",l.createElement(n.code,null,"as")," pour forcer le type des propri√©t√©s de ",l.createElement(n.code,null,"apiResponse")," √† ",l.createElement(n.code,null,"number")," et ",l.createElement(n.code,null,"string")," respectivement. Cela garantit que ",l.createElement(n.code,null,"user")," est de type ",l.createElement(n.code,null,"Person")," et √©vite les erreurs de type potentielles √† la transpilation."),"\n",l.createElement(n.h4,null,"Assertion de type non-null"),"\n",l.createElement(n.p,null,"L'assertion de type non-null (",l.createElement(n.code,null,"!"),") affirme (au transpiler et aux lecteurs du code) que la valeur d'une variable n'est pas ",l.createElement(n.code,null,"null")," ou ",l.createElement(n.code,null,"undefined"),' (on dit "nullish").'),"\n",l.createElement(n.p,null,"Voici un exemple d'assertion de type non-null :"),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-ts"},'let value: string | undefined = "Hello, TypeScript!";\r\nconst length = value!.length; // Assertion de type non-null(ish)\r\nconsole.log(length); // Output: 17\n')),"\n",l.createElement(n.p,null,"Dans cet exemple, TypeScript utilise l'assertion de type non-null (",l.createElement(n.code,null,"!"),") pour garantir que ",l.createElement(n.code,null,"value")," n'est pas ",l.createElement(n.code,null,"null")," avant d'acc√©der √† sa propri√©t√© ",l.createElement(n.code,null,"length"),"."),"\n",l.createElement(n.h2,null,"Conclusion"),"\n",l.createElement(n.p,null,"Le contr√¥le de flux en TypeScript est un outil puissant pour garantir la s√©curit√© des types en fonction des chemins d'ex√©cution possibles. En utilisant des v√©rifications de type conditionnelles, des op√©rateurs de v√©rification de type et des assertions de type, les d√©veloppeurs peuvent s'assurer que leur code respecte les d√©finitions de types fournies et √©viter les erreurs de type potentielles."),"\n",l.createElement(n.p,null,"Nous avons vu les fa√ßons les plus directes de contr√¥ler le flux en TS ; il existe d'autre fa√ßons (type guards, assertion functions), mais nous ne les verrons pas dans ce cours."),"\n",l.createElement(n.h1,null,l.createElement(u,null," R√©duction de type plus avanc√©e ")),"\n",l.createElement(n.h2,null,"Introduction"),"\n",l.createElement(n.p,null,"En TypeScript, la ",l.createElement(n.strong,null,"r√©duction de type"),' ("type narrowing") permet de contr√¥ler le flux d\'ex√©cution (vu √† la section pr√©c√©dente) en ajustant dynamiquement le type des variables, facilitant ainsi des d√©cisions conditionnelles bas√©es sur des types pr√©cis dans le code.'),"\n",l.createElement(n.p,null,"La ",l.createElement(n.strong,null,"r√©duction de type")," (\"type narrowing\") en TypeScript fait r√©f√©rence au processus par lequel TypeScript restreint le type d'une variable ou d'une expression √† un sous-type plus sp√©cifique. Cela se produit g√©n√©ralement apr√®s une v√©rification de type, ce qui permet au compilateur TypeScript de savoir plus pr√©cis√©ment quel type de valeur vous manipulez √† un moment donn√© dans votre code."),"\n",l.createElement(n.p,null,"Nous allons voir quelques exemples courants de ",l.createElement(n.strong,null,"r√©duction de type")," plus avanc√© en TypeScript dans une application Express."),"\n",l.createElement(n.h2,null,"Tentative n¬∞1 de r√©duction de type du body d'une requ√™te : assertion de type"),"\n",l.createElement(n.p,null,"En TS, lorsqu'on utilise Express, le type du ",l.createElement(n.code,null,"body")," d'une requ√™te est ",l.createElement(n.code,null,"any")," par d√©faut. Cela peut √™tre probl√©matique, car cela signifie que le type du ",l.createElement(n.code,null,"body")," n'est pas v√©rifi√© par TypeScript."),"\n",l.createElement(n.p,null,"Pour r√©duire le type du body √† un type plus sp√©cifique, on pourrait utiliser une assertion de type :"),"\n",l.createElement(n.pre,{numbered:!0,highlighting:"2"},l.createElement(n.code,{className:"language-ts"},'router.post("/", (req, res) => {\r\n  const { title, content } = req.body as NewPizza;\r\n\r\n  if (\r\n    !title ||\r\n    !content ||\r\n    !isString(title) ||\r\n    !isString(content) ||\r\n    !title.trim() ||\r\n    !content.trim()\r\n  ) {\r\n    return res.sendStatus(400);\r\n  }\r\n\r\n  const pizzas = parse(jsonDbPath, defaultPizzas);\r\n  // Use reduce() to find the highest id in the pizzas array\r\n  const nextId =\r\n    pizzas.reduce((maxId, pizza) => (pizza.id > maxId ? pizza.id : maxId), 0) +\r\n    1; // 0 is the initial value of maxId\r\n\r\n  const addedPizza: Pizza = {\r\n    id: nextId,\r\n    title,\r\n    content,\r\n  };\r\n\r\n  pizzas.push(addedPizza);\r\n\r\n  serialize(jsonDbPath, pizzas);\r\n\r\n  return res.json(addedPizza);\r\n});\n')),"\n",l.createElement(n.p,null,"N√©anmoins, cette approche n'est pas optimale, car il est impossible d'assurer que le type du ",l.createElement(n.code,null,"body")," est bien ",l.createElement(n.code,null,"NewPizza"),". En effet, une API n'a pas d'influence sur ce que les clients d√©cident d'envoyer."),"\n",l.createElement(n.p,null,"Pour des raisons de robustesse de l'API, on se doit de valider le type du ",l.createElement(n.code,null,"body")," avant de l'utiliser. Cela sera fait √† l'ex√©cution ici (lignes 4 √† 13) via des v√©rifications de type, mais on prend le risque d'oublier une validation qui pourrait √™tre d√©tect√©e √† la transpilation/compilation."),"\n",l.createElement(n.p,null,"üëé D√®s lors, nous vous d√©conseillons d'utiliser l'assertion de type (avec ",l.createElement(n.code,null,"as"),") pour r√©duire le type du ",l.createElement(n.code,null,"body")," d'une requ√™te Express.",l.createElement(n.br),"\n","M√™me si le code est tr√®s concis, √ßa n'est pas une bonne pratique de faire des v√©rifications de type apr√®s avoir utilis√© une assertion de type juste pour se simplifier la vie en TS."),"\n",l.createElement(n.h2,null,"Tentative n¬∞2 de r√©duction de type du body d'une requ√™te : v√©rification de type uniquement"),"\n",l.createElement(n.p,null,"Pour r√©duire le type du ",l.createElement(n.code,null,"body")," √† un type plus sp√©cifique, on pourrait tenter d'utiliser une v√©rification de type :"),"\n",l.createElement(n.pre,{highlighting:"9-10"},l.createElement(n.code,{className:"language-ts"},"router.post(\"/\", (req, res) => {\r\n  if (\r\n      !req.body ||\r\n      typeof req.body !== 'object' ||\r\n      !(\"title\" in req.body) || \r\n      !(\"content\" in req.body) ||\r\n      typeof req.body.title !== 'string' ||\r\n      typeof req.body.content !== 'string' ||\r\n      !req.body.title.trim() || // Unsafe call of an `any` typed value.\r\n      !req.body.content.trim() // Unsafe call of an `any` typed value.\r\n    ) {\r\n      return res.sendStatus(400);\r\n    }\r\n    //... \n")),"\n",l.createElement(n.p,null,"‚ö°Ô∏è Ici, ",l.createElement(n.code,null,"req.body")," est de type ",l.createElement(n.code,null,"any"),". TS ne reconna√Æt pas la r√©duction de type pour une variable de type ",l.createElement(n.code,null,"any"),". Ce code ne peut donc pas transpiler/ compiler !",l.createElement(n.br),"\n","Ainsi, il est n√©cessaire de typer la variable ",l.createElement(n.code,null,"req.body")," pour que TS puisse reconna√Ætre les propri√©t√©s ",l.createElement(n.code,null,"title")," et ",l.createElement(n.code,null,"content")," et les types de ces propri√©t√©s."),"\n",l.createElement(n.h2,null,"R√©duction de type du body d'une requ√™te : assertion de type avec ",l.createElement(n.code,null,"unknown")),"\n",l.createElement(n.p,null,"Nous allons cr√©er une variable de type ",l.createElement(n.code,null,"unknown")," qui est une forme plus strictement typ√©e d'",l.createElement(n.code,null,"any"),", car TypeScript n√©cessite que vous effectuiez une v√©rification de type avant d'acc√©der √† ses propri√©t√©s ou de l'assigner √† un autre type :"),"\n",l.createElement(n.pre,{numbered:!0,highlighting:"2"},l.createElement(n.code,{className:"language-ts"},'router.post("/", (req, res) => {\r\n  const body: unknown = req.body;\r\n  if (\r\n    !body ||\r\n    typeof body !== "object" ||\r\n    !("title" in body) ||\r\n    !("content" in body) ||\r\n    typeof body.title !== "string" ||\r\n    typeof body.content !== "string" ||\r\n    !body.title.trim() ||\r\n    !body.content.trim()\r\n  ) {\r\n    return res.sendStatus(400);\r\n  }\r\n\r\nconst { title, content } = body;\r\n//...\n')),"\n",l.createElement(n.p,null,"üëç Ici, ",l.createElement(n.code,null,"title")," et ",l.createElement(n.code,null,"content")," sont reconnues par TypeScript comme de type ",l.createElement(n.code,null,"string")," apr√®s la v√©rification de type. C'est donc une solution robuste qui peut √™tre utilis√©e dans ce cours."),"\n",l.createElement(n.p,null,"üí≠  Notons ici que pour TS, le type de ",l.createElement(n.code,null,"body")," est : ",l.createElement(n.code,null,'object & Record<"title", unknown> & Record<"content", unknown>'),". C'est un type tr√®s complexe, mais qui permet de garantir que ",l.createElement(n.code,null,"title")," et ",l.createElement(n.code,null,"content")," sont bien des propri√©t√©s de ",l.createElement(n.code,null,"body"),"."),"\n",l.createElement(n.p,null,"Le type ",l.createElement(n.code,null,'Record<"title", unknown>')," repr√©sente un objet qui a une propri√©t√© obligatoire nomm√©e ",l.createElement(n.code,null,"title")," avec une valeur de type inconnu (",l.createElement(n.code,null,"unknown"),"). De m√™me pour ",l.createElement(n.code,null,"content"),".",l.createElement(n.br),"\n","Pourtant, TS d√©tecte que le type de ",l.createElement(n.code,null,"title")," est ",l.createElement(n.code,null,"string"),"... Mais au niveau de l'objet ",l.createElement(n.code,null,"body"),", √ßa n'est pas le cas...",l.createElement(n.br),"\n","On peut retenir cela : ",l.createElement(n.strong,null,"en TS, la r√©duction de type des propri√©t√©s d'un objet ne r√©duit pas le type de l'objet lui-m√™me.")),"\n",l.createElement(n.p,null,"Nous ne pourrions pas √©crire :"),"\n",l.createElement(n.pre,{numbered:!0,highlighting:"16"},l.createElement(n.code,{className:"language-ts"},'router.post("/", (req, res) => {\r\n  const body: unknown = req.body;\r\n  if (\r\n    !body ||\r\n    typeof body !== "object" ||\r\n    !("title" in body) ||\r\n    !("content" in body) ||\r\n    typeof body.title !== "string" ||\r\n    typeof body.content !== "string" ||\r\n    !body.title.trim() ||\r\n    !body.content.trim()\r\n  ) {\r\n    return res.sendStatus(400);\r\n  }\r\n\r\nconst { title, content } : NewPizza = body;\r\n//...\n')),"\n",l.createElement(n.p,null,"Ce code ne transpile pas car TS ne peut pas garantir que ",l.createElement(n.code,null,"title")," et ",l.createElement(n.code,null,"content")," sont bien de type ",l.createElement(n.code,null,"string")," apr√®s la v√©rification de type. Comme vu pr√©c√©demment, ",l.createElement(n.code,null,"body")," est complexe et TS ne peut pas r√©duire le type de ",l.createElement(n.code,null,"body")," √† ",l.createElement(n.code,null,"NewPizza"),"."),"\n",l.createElement(n.p,null,"D√®s lors, dans ce cas, comme on est s√ªr du type, on pourrait utiliser une assertion de type pour r√©duire le type de ",l.createElement(n.code,null,"body")," √† un type plus sp√©cifique :"),"\n",l.createElement(n.pre,{numbered:!0,highlighting:"16"},l.createElement(n.code,{className:"language-ts"},'router.post("/", (req, res) => {\r\n  const body: unknown = req.body;\r\n  if (\r\n    !body ||\r\n    typeof body !== "object" ||\r\n    !("title" in body) ||\r\n    !("content" in body) ||\r\n    typeof body.title !== "string" ||\r\n    typeof body.content !== "string" ||\r\n    !body.title.trim() ||\r\n    !body.content.trim()\r\n  ) {\r\n    return res.sendStatus(400);\r\n  }\r\n\r\n  const { title, content } = body as NewPizza;\r\n  //...\n')),"\n",l.createElement(n.p,null,"üëç Ici, ",l.createElement(n.code,null,"body")," est r√©duit √† ",l.createElement(n.code,null,"NewPizza")," via une assertion de type. C'est une solution robuste qui peut aussi √™tre utilis√©e dans ce cours. L'avantage par rapport au m√™me code mais sans l'assertion de type (",l.createElement(n.code,null,"as NewPizza"),"), c'est que TS informera le d√©veloppeur si ",l.createElement(n.code,null,"body")," n'est plus de type ",l.createElement(n.code,null,"NewPizza")," √† la transpilation/compilation."),"\n",l.createElement(n.p,null,"üí≠ En effet, si le type ",l.createElement(n.code,null,"NewPizza")," venait √† changer (si l'on ajoutait une propri√©t√© par exemple), alors le linter afficherait qu'il manque une propri√©t√© partout o√π ce type est utilis√©.",l.createElement(n.br),"\n","Par exemple, si on ajoute une propri√©t√© ",l.createElement(n.code,null,"price")," √† ",l.createElement(n.code,null,"NewPizza"),", alors TS afficherait une erreur √† la ligne 16 car ",l.createElement(n.code,null,"body")," n'a pas de propri√©t√© ",l.createElement(n.code,null,"price"),"."),"\n",l.createElement(n.h2,null,'üç¨ R√©duction de type du body d\'une requ√™te : fonction de type "guard"'),"\n",l.createElement(n.p,null,"Parfois, on souhaiterait que TypeScript puisse inf√©rer le type de ",l.createElement(n.code,null,"req.body")," sans avoir √† le typer explicitement (avec ",l.createElement(n.code,null,"as"),")."),"\n",l.createElement(n.p,null,"La seule fa√ßon actuelle de le faire est de cr√©er une ",l.createElement(n.strong,null,'fonction de type "guard"')," qui permet de v√©rifier si un objet a les propri√©t√©s ",l.createElement(n.code,null,"title")," et ",l.createElement(n.code,null,"content")," et que ces propri√©t√©s sont des cha√Ænes de caract√®res non vides."),"\n",l.createElement(n.p,null,"Une ",l.createElement(n.strong,null,'fonction de type "guard"'),' retourne un type qui est un "predicate", un type qui permet de v√©rifier si une valeur est d\'un certain type.'),"\n",l.createElement(n.p,null,"Par exemple, on pourrait cr√©er une fonction ",l.createElement(n.code,null,"isNewPizza")," qui v√©rifie si un objet a les propri√©t√©s ",l.createElement(n.code,null,"title")," et ",l.createElement(n.code,null,"content")," et que ces propri√©t√©s sont des cha√Ænes de caract√®res non vides.",l.createElement(n.br),"\n",l.createElement(n.code,null,"isNewPizza")," retournerait un type pr√©dicat ",l.createElement(n.code,null,"body is NewPizza")," qui  permettrait √† TypeScript de reconna√Ætre que ",l.createElement(n.code,null,"req.body")," est de type ",l.createElement(n.code,null,"NewPizza"),". Imaginez cette fonction d√©finie dans un fichier ",l.createElement(n.code,null,"/src/utils/type-guards.ts")," :"),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-ts"},'const isNewPizza = (body: unknown): body is NewPizza => {\r\nif (\r\n  !body ||\r\n  typeof body !== "object" ||\r\n  !("title" in body) ||\r\n  !("content" in body) ||\r\n  body.title !== "string" ||\r\n  body.content !== "string" ||\r\n  !body.title.trim() ||\r\n  !body.content.trim()\r\n) {\r\n  return false;\r\n}\r\n\r\nreturn true;\r\n};\n')),"\n",l.createElement(n.p,null,"Ensuite, on pourrait utiliser cette fonction pour r√©duire le type de ",l.createElement(n.code,null,"req.body")," √† ",l.createElement(n.code,null,"NewPizza")," :"),"\n",l.createElement(n.pre,{numbered:!0,highlighting:"2"},l.createElement(n.code,{className:"language-ts"},'router.post("/", (req, res) => {\r\n  if(!isNewPizza(req.body)) return res.sendStatus(400);\r\n  const { title, content } : NewPizza = body;\r\n  //...\n')),"\n",l.createElement(n.p,null,"Pour ce cours, nous avons choisi de ne pas mettre les fonctions de type guard en avant car m√™me si cela offre un code concis et lisible, cela implique une compr√©hension approfondie de TS qui d√©passe les objectifs de ce cours."),"\n",l.createElement(n.h1,null,l.createElement(u,null," Comment en savoir plus sur TS ? ")),"\n",l.createElement(n.p,null,"Si vous souhaitez en savoir plus sur ce langage, nous vous recommandons de consulter la documentation en ligne de ",l.createElement(n.a,{href:"https://www.typescriptlang.org"},"typescriptlang.org"),"."))}var s=function(e){void 0===e&&(e={});const{wrapper:n}=Object.assign({},(0,r.RP)(),e.components);return n?l.createElement(n,e,l.createElement(a,e)):a(e)};function i(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}var o=t(4810),u=t(2662),c=t(9640),p=t(5938),d=t(9460),m=t(7929),y=t(794),E=t(4092),f=t(4262),g=t(3528),b=t(9942),v=t(4698),h=t(2214),q=t(9838),x=(t(1262),t(1731)),S=t(7050),z=t(2483),P=t(4902),T=t(9294),L=t(7828),w=t(2035),N=t(5590);const I={Link:o.Link,Image:c.A,Section:p.A,Content:d.A,Background:m.A,SectionHeader:y.A,SectionFooter:E.A,PageHeader:f.A,CodeBlock:b.A,LinkFile:v.A,ScrollableImage:h.A,PublicProjectsView:q.A,AuthenticatedBlock:x.A,UnAuthenticatedBlock:S.A,NestedMdxBlock:z.A,YoutubeImage:P.A,InternalPageMenu:T.A,InternalPageMenuItem:L.A,InternalPageTitle:w.A,PathViewer:N.E,PathViewerItem:N.F};function A(e){var n,t,a,s,i;let{data:{mdx:o,allImages:c},children:p}=e;return I.PageHeader=(0,g.R)(f.A,null==o?void 0:o.frontmatter),l.createElement(u.A,Object.assign({},null!=o&&o.frontmatter?{frontmatter:o.frontmatter}:{},null!=o&&null!==(n=o.frontmatter)&&void 0!==n&&n.navbarExtraStyles?{navbarExtraStyles:o.frontmatter.navbarExtraStyles}:{},null!=o&&null!==(t=o.frontmatter)&&void 0!==t&&t.headerImage?{headerImage:o.frontmatter.headerImage}:{},null!=o&&null!==(a=o.frontmatter)&&void 0!==a&&a.featuredImage?{featuredImage:o.frontmatter.featuredImage}:{},null!=o&&null!==(s=o.frontmatter)&&void 0!==s&&s.title?{pageTitle:o.frontmatter.title}:{},c&&c.length>0?{allImages:c}:{}),l.createElement(r.xA,{components:I},l.createElement("div",{className:null!=o&&null!==(i=o.frontmatter)&&void 0!==i&&i.autoMargin?"page page--auto-margin ":"page"},p)))}function j(e){return l.createElement(A,e,l.createElement(s,e))}}}]);
//# sourceMappingURL=component---src-templates-mdx-pages-js-content-file-path-src-mdx-pages-part-0-ts-language-fr-mdx-b9f264ca39750b8eebd8.js.map