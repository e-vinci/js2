---
title: "JWT auths API & bcrypt"
description: "S√©curisation d'une RESTful API : Authentification et autorisation d'acc√®s aux op√©rations d'une RESTful API via JWT & bcrypt"
---

# b) S√©curisation d'une RESTful API

<InternalPageMenu>
  <PathViewer>
    <PathViewerItem to="/"> web2course </PathViewerItem>
    <PathViewerItem to="/part3"> Partie 3 </PathViewerItem>
    <PathViewerItem selected> b) API & JWT & bcrypt </PathViewerItem>
  </PathViewer>
  <InternalPageMenuItem> C'est quoi l'authentification et l'autorisation ? </InternalPageMenuItem>
  <InternalPageMenuItem> Stateful VS stateless authentication </InternalPageMenuItem>
  <InternalPageMenuItem> C'est quoi les tokens JWT ? </InternalPageMenuItem>
  <InternalPageMenuItem> Authentification et cr√©ation de token </InternalPageMenuItem>
  <InternalPageMenuItem> Autorisation et v√©rification de token </InternalPageMenuItem>
  <InternalPageMenuItem> Client REST avec JWT </InternalPageMenuItem>
  <InternalPageMenuItem> Protection des op√©rations d'√©criture d'une API </InternalPageMenuItem> 
  <InternalPageMenuItem> S√©curisation des passwords </InternalPageMenuItem>
  <InternalPageMenuItem> Exercice 3.1 : Authentification & autorisation d'op√©rations </InternalPageMenuItem>
  <InternalPageMenuItem> üç¨ Exercice 3.2 : une autre API s√©curis√©e </InternalPageMenuItem> 
  <InternalPageMenuItem> üç¨ Authentification & autorisation JWT √† l'aide de cookies </InternalPageMenuItem> 
  <InternalPageMenuItem> üç¨ Test via REST Client d'une RESTful API attendant des cookies </InternalPageMenuItem>
</InternalPageMenu>

<div className="card card__simple-youtube-container">
    <YoutubeImage src="https://youtu.be/jCUyii3hcwY" />
</div>

# <InternalPageTitle> C'est quoi l'authentification et l'autorisation ? </InternalPageTitle>

## Authentification, c'est quoi ?
L'authentification, c'est le processus de **v√©rifier qui est l'utilisateur** d'une application.

Pour authentifier un utilisateur, on va g√©n√©ralement passer via un formulaire de connexion, lui demandant un username et un password.

## Autorisation, c'est quoi ?
L'autorisation, c'est le processus de **v√©rifier ce √† quoi un utilisateur √† acc√®s**.

Une API va autoriser les acc√®s √† certaines op√©rations en fonction des privil√®ges associ√©s aux utilisateurs. Il y aura des op√©rations qui seront autoris√©es : 
- **pour tous les utilisateurs**, tant anonymes qu'authentifi√©s ;  
*imaginez par exemple les op√©rations de lecture de produits sur un site "vitrine". Il ne faut pas devoir cr√©er de compte utilisateur pour pouvoir afficher les produits du site.*
- **pour tous les utilisateurs authentifi√©s**, peu importe leurs privil√®ges ;  
*imaginez le fait de pouvoir poster des messages dans un forum ; il faut avoir un compte pour pouvoir le faire, mais il ne faut pas de privil√®ges sp√©cifiques (pas besoin d'√™tre admin).*
- **pour seulement un ou plusieurs utilisateur(s) authentifi√©(s)** ayant les privil√®ges requis ;  
*imaginez une op√©ration de lecture de tous les profils des utilisateurs d'une banque ; il faut avoir un compte admin de la banque pour pouvoir le faire. Ca serait catastrophique si n'importe quel utilisateur authentifi√© pourrait acc√©der aux profils de tous les utilisateurs !*

## Diff√©rents moyens d'authentification

### Authentification stateful

Traditionnellement, ou anciennement, nous avons l'authentification qui est support√©e √† l'aide de cookies. L'utilisateur envoie via un formulaire son username et password, le serveur v√©rifie ceux-ci et cr√©e un id de session et le renvoie √† l'utilisateur via un cookie.  
Apr√®s l'authentification, √† chaque requ√™te du client sur ce serveur, le cookie est envoy√©, et le serveur, qui a sauvegard√© la session, va la retrouver sur base de l'id de session pr√©sent dans le cookie et va autoriser ou non l'acc√®s √† l'op√©ration demand√©e par le client.  
C'est ce qu'on appelle une authentification **stateful**.

Un m√©canisme d'authentification **stateful** indique que le serveur est responsable de sauvegarder les donn√©es de session des utilisateurs. 

On parle de **session** d'un utilisateur comme √©tant toute la dur√©e o√π le client s'authentifie √† l'application web jusqu'√† ce qu'il quitte cette application, lorsqu'il ferme son browser.

### Authentification stateless 

De mani√®re plus moderne, nous avons des m√©canismes d'authentification qui sont dits **stateless**. Dans ce genre de m√©canisme, c'est le client qui doit sauvegarder les donn√©es de session, et donc le browser. L'authentification √† l'aide de **tokens** devient tr√®s populaire.  
Il existe diff√©rents moyen de l'impl√©menter. Dans le cadre de ce cours, nous focaliserons sur la fa√ßon la plus habituelle, les **JSON Web Tokens**, ou **JWT**.

Il existe d'autres m√©canismes tr√®s modernes qui utilisent des tokens, et qui sont mis en place par des tiers : **OAuth**, **OpenId**... Ces m√©canismes sont offerts par Microsoft, Google, Facebook... Nous ne les verrons pas dans le cadre de cours. N√©anmoins, √† la fin de ce cours, vous devriez √™tre apte √† pouvoir les utiliser, sous r√©serve de bien lire la documentation üòâ.

# <InternalPageTitle> Stateful VS stateless authentication  </InternalPageTitle>

Quels sont les avantages & inconv√©nients d'une authentification stateful ? et d'une authentification stateless ?

#### Authentification stateful
**Inconv√©nients** :
- La session utilise de la m√©moire pour chaque utilisateur.
- Le backend n'a aucune mani√®re de d√©terminer si le frontend s'est d√©connect√© du site ou non : gestion de l'expiration d'une session plus compliqu√©e, notamment si le frontend revient apr√®s une longue dur√©e.
- Toutes les sessions sont perdues en cas de red√©marrage du serveur (r√©-authentification).
- Load balancing compliqu√© ; en effet, si un client fait une requ√™te, pendant toute la dur√©e de la session, s'il y a plusieurs serveurs qui peuvent y r√©pondre, comment est g√©r√©e la session de ce client ? Par quel(s) serveur(s) ? Comment se partagent-ils les donn√©es de session ? Est-ce que √ßa doit toujours √™tre le m√™me serveur qui r√©ponde au m√™me client ?

**Avantages** :
- Peu gourmand en ressource point de vue processing et tr√®s rapide ; en effet, une fois qu'une session est en place, la v√©rification que le cookie contient le bon id de session se fait vite.

#### Authentification stateless
**Inconv√©nients** : 
Comme le serveur ne retient plus l'utilisateur en m√©moire, il doit utiliser de la cryptographie pour cr√©er et valider les token ; c'est donc consommateur en ressource point de vue processing.

**Avantages** : 
- Pas de session √† g√©rer, m√™me apr√®s red√©marrage du serveur, il n'y a pas de r√©-authentification n√©cessaire.
- √âvolutif, utilisation facile de plusieurs serveurs si du load balancing est n√©cessaire ; en effet, comme chaque requ√™te du client contient toutes les infos pour se faire autoriser, il n'est pas n√©cessaire de savoir quel serveur va prendre en charge la requ√™te.

Notons que la "scalability" horizontale, la possibilit√© de permettre √† une application d'augmenter sa capacit√© de r√©pondre √† une charge grandissante simplement en ajoutant des machines, est quelque chose de tr√®s important √† notre √©poque.  
Certaines applications web ont des centaines de millions d'utilisateurs ; pour celles-ci, on ne peut pas compter sur la "scalability" verticale, c'est-√†-dire le fait d'augmenter les ressources d'une machine, en augmentant sa RAM, son processeur, son espace de stockage...

D√®s lors, dans le cadre de ce cours, nous allons pr√©f√©rer les applications web qui peuvent tourner sur des serveurs **stateless**.

# <InternalPageTitle> C'est quoi les tokens JWT ? </InternalPageTitle>

Les **JSON Web token**, ou **JWT**, appartiennent √† un standard internet permettant l'√©change s√©curis√© de tokens entre plusieurs parties.

Un **JWT** contient **trois parties encod√©es en base64** et ressemble √† qqch du style :  
**`eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.`**  
**`eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.`**   
**`SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c`**

Voici les 3 parties d'un JWT et leurs caract√©ristiques :
- l'**ent√™te** (ou header) : un objet JSON identifiant le type de token (JWT) et l'algorithme utilis√© pour g√©n√©rer la signature du token (HS256), un algorithme de hachage. 
- le **payload** : un objet JSON permettant de sp√©cifier le **claim** ; ce sont des param√®tres optionnels pr√©cisant les affirmations associ√©es au token, comme la date d'expiration du token, son cr√©ateur, le fait que l'utilisateur est admin... g√©n√©ralement, on y met pas trop d'info, principalement l'identifiant de l'utilisateur ; si l'API a besoin de plus d'info concernant l'utilisateur, elle ira g√©n√©ralement les chercher dans ses donn√©es.
- la **signature** : c'est une signature num√©rique construite √† partir d'un secret priv√© ou d'une cl√© publique/priv√©e, via l'algorithme pr√©cis√© dans la signature.

üí≠ C'est bien joli tout √ßa, mais comment √ßa permet de s√©curiser la session d'un utilisateur ?  
G√©n√©ralement, l'API, et elle uniquement, conna√Æt le secret priv√©. Elle va donc cr√©er le token d'un utilisateur authentifi√©, en y ajoutant le claim (ou les affirmations) qu'elle juge utile.  
Lorsque le client re√ßoit son token, il va le sauvegarder dans son browser.  
Pour chaque requ√™te n√©cessitant une autorisation de l'API, le client enverra son token au sein du header de la requ√™te.  
L'API utilisera le secret priv√©, connu d'elle-m√™me uniquement, pour v√©rifier la signature du token. Si tout est OK, c'est que l'utilisateur est bien authentifi√© et que son claim est OK.

Imaginez maintenant qu'un hacker tente de modifier le token, pour modifier le claim, notamment en changeant l'id de l'utilisateur pr√©sent dans le payload du token.
Et bien la signature ne correspondra plus √† ce token l√† ! L'API le d√©tectera.  
Pour que le hacker r√©ussisse son acte malicieux, il est oblig√© de conna√Ætre le secret priv√© qui ne doit √™tre connu que de l'API. Ca ne serait que sur base du secret priv√© que les hackers pourraient g√©n√©rer un nouveau token qui serait valid√© par l'API. Pas √©vident √† faire...

Ainsi, on peut imaginer un token comme une enveloppe s√©curis√© par un cadenas tr√®s sp√©cial : ce cadenas, qui est mis sur l'enveloppe contenant, par exemple, l'identifiant d'un utilisateur, est ferm√© par la cl√© üîë que seulement conna√Æt l'API.
Si quelqu'un touche √† l'enveloppe, le cadenas ne s'ouvrira plus avec la üîë de l'API : la tentative de hack sera d√©tect√©e ! 
Si quelqu'un tente de cr√©er une enveloppe s√©curis√©, il le fera avec une autre cl√©, **üóù** par exemple, car il ne conna√Æt pas üîë. L'API, tentant d'ouvrir l'enveloppe s√©curis√©e √† l'aide de üîë, elle ne s'ouvrira pas : la tentative de hacking sera d√©tect√©e ! 

üí≠ Est-ce que cette m√©taphore d'enveloppe s√©curis√©e vous parle ?
Attention que dans la r√©alit√©, le payload classique d'un token sera decodable, que l'on connaisse ou pas le secret priv√©. Il est encod√© en base64 ! Ne mettez donc jamais de secrets dans le payload d'un token !  
Si vraiment un jour vous deviez mettre un secret dans un payload, bien que d√©conseill√©, vous pourriez toujours le faire en cryptant le payload.

üëç Le m√©canisme de token assure que l'on aie une tr√®s haute probabilit√© de d√©tecter les alt√©rations faites sur les tokens, les tentatives de forgeage, gr√¢ce √† la signature de ceux-ci.  

‚ö° Par contre, si nous laissions tra√Æner des informations dans le payload d'un token, comme un password d'un utilisateur et son username, alors l√†, c'est juste un beau cadeau que l'on offre aux hackers ; ils n'auraient plus qu'√† trouver un moyen de voler √† distance nos donn√©es de session ; ils pourraient ensuite utiliser le formulaire de connexion et prendre possession de notre identit√© üò®.

Il existe un site fort int√©ressant qui montre la structure d'un token et qui permet de les d√©coder : [jwt.io](https://jwt.io/) [[R.63]](/references/#r63). Nous l'utiliserons plus tard pour d√©coder les tokens g√©n√©r√©s par nos RESTful API.

# <InternalPageTitle> Authentification et cr√©ation de token </InternalPageTitle>

## Introduction

Via un exemple concret associ√© √† notre RESTful API qui g√®re les ressources de type "pizzas" et de type "boisson", nous allons mettre en place un processus d'authentification et d'autorisation JWT.

La librairie que nous allons utiliser dans le cadre de ce cours pour g√©rer des tokens JWT est [jsonwebtoken](https://www.npmjs.com/package/jsonwebtoken).

Dans ce nouveau tutoriel, nous allons continuer le d√©veloppement de l'API [services](https://github.com/e-vinci/ts-demos/tree/main/back/api/services) pour ajouter des op√©rations permettant l'authentification et l'autorisation d'utilisateurs.

Veuillez cr√©er un nouveau projet nomm√© **`auths`** (dans votre repo git **`/web2/tutorials/pizzeria/api/auths`**) sur base d'un copi√©/coll√© du tutoriel [services](https://github.com/e-vinci/ts-demos/tree/main/back/api/services).

Veuillez installer la librairie **`jsonwebtoken`** au sein de votre nouveau projet **`auths`** :
```bash
npm i jsonwebtoken
```

Comme nous utilisons TS, nous devons aussi installer les types de cette librairie :
```bash
npm i -D @types/jsonwebtoken
```

## M√©canisme d'authentification et cr√©ation du token

Toujours √† l'aide d'Express, nous allons cr√©er un router **`auths`** qui mettra √† disposition les op√©rations de **`login`** et de **`register`**. 
Voici le contrat associ√© √† ces nouvelles op√©rations :

##### Op√©rations sur les ressources de type "auths"
| URI | M√©thode HTTP | Op√©ration |
|---|---|---|
| **`auths/login`** | **POST** | V√©rifier les credentials d'une ressource de type "users" et renvoyer le username et un token JWT si les credentials sont OK |
| **`auths/register`** | **POST** | Cr√©er une ressource de type "users" et renvoyer le username et un token JWT |

<br/>

Le service **`users`** s'occupera de cr√©er les utilisateur, de v√©rifier leurs credentials ainsi que de cr√©er des tokens.

Voici le workflow attendu pour une op√©ration de **`login`** ou de **`register`** :

<ScrollableImage name="login.png" minWidth="879px" maxWidth="879x" />
<figcaption>Appel √† une RESTful API pour s'authentifier et obtenir un JWT</figcaption>

Ce que l'on voit dans l'image ci-dessus : 
- si le service consid√®re que l'utilisateur est authentifiable, que ses credentials sont OK, alors il va utiliser la m√©thode **`sign`** de l'objet **`jwt`** pour cr√©er un token. 
- le token est envoy√© dans le body de la r√©ponse √† l'utilisateur. 

Ce que l'on ne voit pas dans l'image ci-dessus :
- c'est le job du client de sauvegarder le token. Si l'application cliente est un browser, alors celui-ci pourra √™tre sauvegard√© dans le web storage du browser.
- l'application cliente peut √™tre faite avec n'importe quelle technologie. Par exemple, nous pourrons utiliser REST Client pour faire une requ√™te √† l'API...

Dans notre RESTful API, nous avons d√©cid√© que lorsqu'un client s'enregistre, quand il fait appel √† l'op√©ration **`register`** pour cr√©er un compte, l'API consid√®re automatiquement que cet utilisateur est authentifi√©. Tout comme la m√©thode **`login`**, la m√©thode **`register`** cr√©era et renverra un token JWT √† l'utilisateur.

NB : Il est possible d'envisager un workflow diff√©rent : apr√®s le **`register`**, l'application demanderait √† l'utilisateur un **`login`**, **`register`** ne renvoyant jamais de token √† l'utilisateur.

## Impl√©mentation de login & register

Nous allons √† pr√©sent mettre en place le code permettant d'impl√©menter le workflow que l'on vient de d√©couvrir.

Veuillez cr√©er le service **`users`** en cr√©ant le fichier **`/services/users.ts`** et y inclure ce code :
```ts numbered highlighting="1,5-6,27-31,33-36,50-54,56-59"
import jwt from "jsonwebtoken";
import path from "node:path";
import { parse, serialize } from "../utils/json";
import { AuthenticatedUser, User } from "../types";

const jwtSecret = "ilovemypizza!";
const lifetimeJwt = 24 * 60 * 60 * 1000; // in ms : 24 * 60 * 60 * 1000 = 24h

const jsonDbPath = path.join(__dirname, "/../data/users.json");

const defaultUsers: User[] = [
  {
    id: 1,
    username: "admin",
    password: "admin",
  },
];

function login(
  username: string,
  password: string
): AuthenticatedUser | undefined {
  const userFound = readOneUserFromUsername(username);
  if (!userFound) return undefined;
  if (userFound.password !== password) return undefined;

  const token = jwt.sign(
    { username }, // session data added to the payload (payload : part 2 of a JWT)
    jwtSecret, // secret used for the signature (signature part 3 of a JWT)
    { expiresIn: lifetimeJwt } // lifetime of the JWT (added to the JWT payload)
  );

  const authenticatedUser: AuthenticatedUser = {
    username,
    token,
  };

  return authenticatedUser;
}

function register(
  username: string,
  password: string
): AuthenticatedUser | undefined {
  const userFound = readOneUserFromUsername(username);
  if (userFound) return undefined;

  createOneUser(username, password);

  const token = jwt.sign(
    { username }, // session data added to the payload (payload : part 2 of a JWT)
    jwtSecret, // secret used for the signature (signature part 3 of a JWT)
    { expiresIn: lifetimeJwt } // lifetime of the JWT (added to the JWT payload)
  );

  const authenticatedUser: AuthenticatedUser = {
    username,
    token,
  };

  return authenticatedUser;
}

function readOneUserFromUsername(username: string) {
  const users = parse(jsonDbPath, defaultUsers);
  const userFound = users.find((user) => user.username === username);
  if (!userFound) return undefined;

  return userFound;
}

function createOneUser(username: string, password: string) {
  const users = parse(jsonDbPath, defaultUsers);

  const nextId =
    users.reduce((acc, user) => (user.id > acc ? user.id : acc), 0) + 1;

  const createdUser: User = {
    id: nextId,
    username,
    password,
  };

  users.push(createdUser);

  serialize(jsonDbPath, users);

  return createdUser;
}

export { login, register, readOneUserFromUsername };
```

Dans le code ci-dessus, **`jwtSecret`** est le secret priv√© connu uniquement du serveur. C'est la m√™me secret qu'il faudra utiliser pour v√©rifier un token.  

**`jwt.sign()`** permet de cr√©er le token et ses 3 parties :
- le payload du token, la 2√®me partie du token, est compl√©t√© principalement via le permier argument de **`sign()`** ; ici, le token affirme que l'utilisateur poss√©dant le **`username`** donn√© est authentifi√©.
- le payload du token sera aussi modifi√© sur base de la dur√©e d'expiration du token, selon l'argument **`expiresIn`**.
- **`jwtSecret`** est utilis√© pour cr√©er la 3√®me partie du token, sa signature.

Pour le service **`users`**, nous avons du cr√©er deux nouveaux types : **`AuthenticatedUser`** et **`User`**. Veuillez mettre √† jour le fichier **`/types.ts`** et y inclure ce code :
```ts numbered highlighting="1-4,6-10,18-19"
interface AuthenticatedUser {
  username: string;
  token: string;
}

interface User {
  id: number;
  username: string;
  password: string;
}

export type {
  Pizza,
  NewPizza,
  PizzaToUpdate,
  Drink,
  NewDrink,
  AuthenticatedUser,
  User,
};
```

Il faut maintenant que nous cr√©ions le router **`auths`** offrant les op√©rations de **`login`** et de **`register`**, en faisant appel au service **`users`**.  
Veuillez cr√©er le fichier **`/routes/auths.ts`** et y inclure le code suivant :
```ts
import { Router } from "express";
import { PotentialUser } from "../types";
import { login, register } from "../services/users";
const router = Router();

/* Register a user */
router.post("/register", (req, res) => {
  const body: unknown = req.body;
  if (
    !body ||
    typeof body !== "object" ||
    !("username" in body) ||
    !("password" in body) ||
    typeof body.username !== "string" ||
    typeof body.password !== "string" ||
    !body.username.trim() ||
    !body.password.trim()
  ) {
    return res.sendStatus(400);
  }

  const { username, password } = body as PotentialUser;

  const authenticatedUser = register(username, password);

  if (!authenticatedUser) {
    return res.sendStatus(409);
  }

  return res.json(authenticatedUser);
});

/* Login a user */
router.post("/login", (req, res) => {
  const body: unknown = req.body;
  if (
    !body ||
    typeof body !== "object" ||
    !("username" in body) ||
    !("password" in body) ||
    typeof body.username !== "string" ||
    typeof body.password !== "string" ||
    !body.username.trim() ||
    !body.password.trim()
  ) {
    return res.sendStatus(400);
  }

  const { username, password } = body as PotentialUser;

  const authenticatedUser = login(username, password);

  if (!authenticatedUser) {
    return res.sendStatus(401);
  }

  return res.json(authenticatedUser);
});

export default router;
```

Il n'y a rien de bien sp√©cial √† ce code. On fait simplement appel aux op√©rations du service **`users`**.  
Nous avons n√©anmoins du cr√©er un nouveau type **`PotentialUser`**. Veuillez mettre √† jour le fichier **`/types.ts`** et y inclure ce code :
```ts highlighting="1,11"
type PotentialUser = Omit<User, "id">;

export type {
  Pizza,
  NewPizza,
  PizzaToUpdate,
  Drink,
  NewDrink,
  AuthenticatedUser,
  User,
  PotentialUser,
};
```

Attention, il faut rajouter le nouveau router au sein de **`app.js`** pour que notre API puisse offrir les nouvelles op√©rations ; veuillez donc ajouter ce code dans **`/app.ts`** :
```ts numbered highlighting="6,24"
import express, { ErrorRequestHandler } from "express";

import usersRouter from "./routes/users";
import pizzaRouter from "./routes/pizzas";
import drinkRouter from "./routes/drinks";
import authsRouter from "./routes/auths";

const app = express();

app.use((_req, _res, next) => {
  console.log(
    "Time:",
    new Date().toLocaleString("fr-FR", { timeZone: "Europe/Brussels" })
  );
  next();
});

app.use(express.json());
app.use(express.urlencoded({ extended: false }));

app.use("/users", usersRouter);
app.use("/pizzas", pizzaRouter);
app.use("/drinks", drinkRouter);
app.use("/auths", authsRouter);

const errorHandler: ErrorRequestHandler = (err, _req, res, _next) => {
  console.error(err.stack);
  return res.status(500).send("Something broke!");
};

app.use(errorHandler);
export default app;
```

## Utilisation de Rest Client pour tester les nouvelles op√©rations

Veuillez d√©marrer votre API **`auths`**.

On va utiliser REST Client pour tester ces nouvelles op√©rations.

Veuillez cr√©er le fichier **`/REST Client/auths.http`** et y ajouter le code suivant :
```http
@baseUrl = http://localhost:3000

### Try to login an unknown user
POST {{baseUrl}}/auths/login
Content-Type: application/json

{
    "username":"unknown",
    "password":"admin"
}

### Login the default admin
POST {{baseUrl}}/auths/login
Content-Type: application/json

{
    "username":"admin",
    "password":"admin"
}


### Create the manager user
POST {{baseUrl}}/auths/register
Content-Type: application/json

{
    "username":"manager",
    "password":"manager"
}

### Login the manager user
POST {{baseUrl}}/auths/login
Content-Type: application/json

{
    "username":"manager",
    "password":"manager"
}
```

Veuillez ex√©cuter les diff√©rentes requ√™tes. Tout devrait fonctionner, vous devriez r√©cup√©rer le username et le token d'un utilisateur authentifi√©.

Pour le fun, nous allons d√©coder un token : 
- Veuillez copier le token de ce que renvoie votre API pour la requ√™te de login de l'utilisateur **`manager`** (qqch qui doit ressembler √† une string du genre : **`eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6Im1hbmFnZXIiLCJpYXQiOjE2NjEyNDg1MjksImV4cCI6MTc0NzY0ODUyOX0.JvYzM0gtmVkqFr9R3f1Bf6ow_QuyHJY-vedJ39N7JKw`**).
- Veuillez vous rendre sur le site [JWT](https://jwt.io/) et coller votre token dans le champs **`Encoded`**. Dans la colonne **`Decoded`**, vous devriez voir l'algorithme utilis√© par la m√©thode **`sign`**, ainsi que les donn√©es pr√©sentes dans le payload, dont **`"username": "manager"`** ! 

Vous comprenez maintenant pourquoi on n'ajoute pas des secrets dans un token üòâ.

# <InternalPageTitle> Autorisation et v√©rification de token </InternalPageTitle>

## M√©canisme d'autorisation d'utilisateurs √† des op√©rations d'une API 

### Intro

Dans le workflow que nous avons choisi, les utilisateurs re√ßoivent un token lors du **`register`** ou du **`login`**. C'est le job de l'application cliente de trouver un moyen de sauvegarder ce token. 

Lorsqu'une application client souhaite cr√©er une pizza, on souhaite autoriser cette op√©ration qu'√† l'administrateur du site g√©rant la pizzeria.  
Nous d√©cidons donc pour l'**op√©ration de cr√©ation de pizza que l'utilisateur doit** non seulement √™tre **authentifi√©**, mais qu'en plus, il doit √™tre l'**admin** du site.

### M√©canisme d'autorisation quand le token JWT est valide

Pour que l'application client qui fait la requ√™te √† l'API puisse s'autoriser, elle doit ajouter un **`authorization header`** √† sa requ√™te contenant comme valeur le token re√ßu lors du **`login`** ou du **`register`** :

<ScrollableImage name="authorizeOK.png" minWidth="879px" maxWidth="879x" />
<figcaption>Appel √† une op√©ration d'une RESTful API n√©cessitant une autorisation JWT : autorisation valide</figcaption>

Le router de "pizzas", avant m√™me de passer la requ√™te √† la route **`POST /pizzas`**, va lancer la fonction middleware d'autorisation nomm√©e **`authorize`**. La fonction middleware **`authorize`** va s'occuper de v√©rifier le token envoy√© par le client dans un header √† l'aide de la m√©thode **`verifiy`** de l'objet **`jwt`** (de la librairie **`jsonwebtoken`**).

üí≠ Si le token est valide, est-ce que √ßa signifie que l'utilisateur est bien authentifi√© ?  
*H√© bien non, car imaginez qu'entre le moment o√π l'utilisateur se soit logu√©, il ait √©t√© supprim√© de l'application par un admin... dans ce cas-ci, on ne veut pas l'autoriser √† ajouter une pizza au menu de la pizzeria ! Il n'est p-e m√™me plus un employ√©, il souhaite p-e √©crire du contenu malicieux üò®*

Donc si le token est valide, **`authorize`** fera appel au service **`users`** pour v√©rifier que l'utilisateur existe bien dans le support de donn√©es (fichiers JSON, base de donn√©es ou autres) et pour obtenir toutes les infos sur cet utilisateur. Si l'utilisateur existe, alors cela signifie que l'utilisateur est bien authentifi√©. La fonction middleware **`authorize`** va passer la main √† une autre fonction middleware pour v√©rifier que l'utilisateur est bien l'admin.

üí≠ Comment est-ce que **`authorize`** peut faire appel au service pour v√©rifier que l'utilisateur existe bien ? Est-ce que cela signifie que le token doit contenir tout un tas de donn√©es sur l'utilisateur ?

üëç En r√®gle g√©n√©rale, on va juste mettre un identifiant de l'utilisateur dans ce qu'on appelle le **payload** du token. C'est ensuite l'API, suite au d√©codage de l'identifiant de l'utilisateur, qui fera appel aux donn√©es pour retrouver tout ce qui concerne l'utilisateur.

La fonction middleware **`isAdmin`** va v√©rifier que l'utilisateur est bien l'admin. Si c'est OK, elle passera la main √† la fonction middleware qui g√®re la route **`POST /pizzas`** au sein du router de pizzas en faisant l'appel √† la fonction **`next`**.  
*üç¨ NB : on pourrait aussi laisser la fonction **`creatPizza`** s'occuper de v√©rifier que l'utilisateur demandant la cr√©ation de la pizza soit bien l'admin. Ici, comme il s'agit de v√©rifier que le contrat de l'API soit respect√©, c'est-√†-dire que l'utilisateur soit bien authentifi√© & admin, alors on pr√©f√®re r√©aliser cette action en dehors du service. Dans nos choix architecturaux pour nos RESTful API, nous avons d√©cid√© que ce n'est pas le service qui s'occupe de pr√©senter les donn√©es aux clients, c'est le r√¥le des routers (et les fonctions middleware associ√©es).*

Maintenant que le client a les bons privil√®ges, l'op√©ration de cr√©ation de la pizza peut donc √™tre autoris√©e. L'op√©ration de **`createPizza`** du service renverra la nouvelle pizza au router qui s'occupera de pr√©senter la nouvelle pizza au client, au format JSON.

### M√©canisme d'autorisation quand le token JWT est invalide

Voici le workflow d'autorisation si le token n'est pas valide :

<ScrollableImage name="authorizeNOK.png" minWidth="879px" maxWidth="879x" />
<figcaption>Appel √† une op√©ration d'une RESTful API n√©cessitant une autorisation JWT : autorisation invalide</figcaption>

Dans ce cas l√†, **`authorize`** ne passe pas la main √† **`isAdmin`** ni m√™me √† la fonction middleware qui g√®re la route **`POST /pizzas`**.  
La fonction middleware **`authorize`** renvoie directement un code d'erreur **`401 Unauthorized`** au client. 

### M√©canisme d'autorisation quand l'utilisateur n'est pas admin

Vous pourriez aussi imaginer le workflow o√π le client envoie un token valide, mais l'utilisateur associ√© n'est pas admin. Dans ce cas-ci, **`authorize`** ferait appel √† **`isAdmin`**, mais **`isAdmin`** renverrait directement un code d'erreur **`403 Forbidden`** au client.  
En effet, l'API indiquerait ainsi qu'elle aurait v√©rifi√© que l'utilisateur est bien authentifi√©, mais que celui ne poss√®de pas les privil√®ges suffisant pour acc√©der √† l'op√©ration demand√©e.

## Impl√©mentation du m√©canisme d'autorisation

üò® Wow, le workflow d'autorisation pour la cr√©ation d'une pizza est assez long.  
Nous allons maintenant l'impl√©menter dans notre tutoriel en cours.  
Nous vous inqui√©tez pas, ce qui importe dans le code qui va suivre, ce n'est pas de savoir √©crire tout le code, mais de bien comprendre les m√©canismes associ√©s. En effet, en r√®gle g√©n√©rale, vous allez utiliser des librairies vous permettant d'autoriser les acc√®s aux op√©rations de vos API. Vous √©crirez donc rarement les m√©canismes d'autorisation, par contre, vous devrez pouvoir les utiliser.

Veuillez cr√©er les nouvelles fonctions middleware **`authorize`** et **`isAdmin`** au sein d'un nouveau fichier **`/utils/auths.ts`** :
```ts numbered highlighting="1,6,13,19-20,28,37"
import jwt from "jsonwebtoken";
import { readOneUserFromUsername } from "../services/users";
import { NextFunction, RequestHandler, Response } from "express";
import { AuthenticatedRequest, JwtPayload, User } from "../types";

const jwtSecret = "ilovemypizza!";

const authorize = (
  req: AuthenticatedRequest,
  res: Response,
  next: NextFunction
) => {
  const token = req.get("authorization");
  if (!token) {
    return res.sendStatus(401);
  }

  try {
    const decoded = jwt.verify(token, jwtSecret) as JwtPayload;
    const { username } = decoded;

    const existingUser = readOneUserFromUsername(username);

    if (!existingUser) {
      return res.sendStatus(401);
    }

    req.user = existingUser; // request.user object is available in all other middleware functions
    return next();
  } catch (err) {
    console.error("authorize: ", err);
    return res.sendStatus(401);
  }
};

const isAdmin: RequestHandler = (req: AuthenticatedRequest, res, next) => {
  const { username } = req.user as User;

  if (username !== "admin") {
    return res.sendStatus(403);
  }
  return next();
};

export { authorize, isAdmin };
```

Voici quelques explications sur le code de la fonction middleware **`authorize`** : 
- Gr√¢ce √† **`req.get('authorization')`** (ligne 13), on r√©cup√®re le token qui a √©t√© envoy√© par le client au sein de l'**`authorization header`** de la requ√™te sous forme de string.
- La m√©thode **`jwt.verify(token, jwtSecret)`** (ligne 19) v√©rifie tant la signature du token que son √©ventuelle expiration. Elle utilise le secret **`jwtSecret`** qui doit √™tre le m√™me que celui pris en compte lors de la cr√©ation du token.
- Elle charge toutes les donn√©es de l'utilisateur authentifi√© au sein de l'objet **`req`** (ligne 28), dans **`user`**. Cela est une bonne pratique, cela permet, pour toute la dur√©e du traitement de cette requ√™te, de mettre √† disposition ces donn√©es √† toutes les fonctions middleware.    
üí≠ Mais pourquoi faire cela ?
*Imaginez que vous faites un appel √† une base de donn√©es externes √† chaque fois que vous souhaitez obtenir les informations d'un utilisateur... Cela est tr√®s consommateur en temps... Lorsque vous allez utiliser d'autres fonctions middleware comme **`isAdmin`**, vous n'avez plus besoin de faire appel √† la base de donn√©es.*

La fonction middleware **`isAdmin`** r√©cup√®re les donn√©es de l'utilisateur authentifi√© via l'objet **`req.user`**.  
Si l'utilisateur n'est pas **`admin`**, c'est le code **`403 Forbidden`** qui est renvoy√© √† l'application cliente, signifiant que l'utilisateur est bien authentifi√©, mais il n'a pas les privil√®ges pour acc√©der √† l'op√©ration demand√©e (cr√©ation de pizza).  
Si tout est OK, **`isAdmin`** fait appel √† **`next()`**, ce qui consiste √† ex√©cuter la prochaine fonction middleware qui est pr√©sente apr√®s l'appel de **`isAdmin`**.

Pour cr√©er ces deux fonctions middleware, nous avons du cr√©er deux nouveaux types : **`AuthenticatedRequest`** et **`JwtPayload`**. Veuillez mettre √† jour le fichier **`/types.ts`** et y inclure ce code :
```ts numbered highlighting="1,5-7,9-13,24-25"
import { Request } from "express";

// Reste du code

interface AuthenticatedRequest extends Request {
  user?: User;
}

interface JwtPayload {
  username: string;
  exp: number; // Expiration time (in seconds since the epoch)
  iat: number; // Issued at time (in seconds since the epoch)
}

export type {
  Pizza,
  NewPizza,
  PizzaToUpdate,
  Drink,
  NewDrink,
  AuthenticatedUser,
  User,
  PotentialUser,
  AuthenticatedRequest,
  JwtPayload,
};

```

Ici nous avons ajout√© un nouveau type **`AuthenticatedRequest`** qui √©tend le type **`Request`** d'Express, ceci afin de pouvoir ajouter un objet de type **`User`** √† **`req`**.

Nous avons aussi ajout√© un nouveau type **`JwtPayload`** qui repr√©sente le payload d'un token JWT. Ce type est utilis√© pour typer l'objet **`decoded`** retourn√© par la m√©thode **`jwt.verify`**.

O√π allons-nous utiliser les nouvelles fonctions middleware **`authorize`** et **`isAdmin`** ?

Nous pouvons le faire au niveau que nous souhaitons, soit au niveau :
- de l'**application**, pour toutes les routes, via **`app.use(authorize)`**.
- d'un **router**, pour toutes les routes associ√©es ; par exemple, on pourrait dire que toutes les routes du router de pizzas sont prot√©g√©es par une autorisation JWT. On √©crirait : **`app.use("/pizzas", authorize, pizzaRouter);`**.  
Cela signifierait que toutes les op√©rations sur des ressources de type "pizzas" ne seraient autoris√©es que si l'utilisateur √©tait authentifi√©. Cela serait probl√©matique pour deux raisons :
    - On veut pouvoir afficher le menu des pizzas pour tous les utilisateurs, m√™me s'ils sont anonymes.
    - On ne veut pas simplement v√©rifier qu'un utilisateur est authentifi√© pour cr√©er une pizza, on veut aussi v√©rifier qu'il est admin.
- d'une route, pour une op√©ration de notre RESTful API. C'est ce que nous souhaitons faire ici. Veuillez mettre √† jour le code du router de "pizzas" au sein de **`/routes/pizzas.ts`** :
```js highlighting="2,7"
// Code existant...
import { authorize, isAdmin } from "../utils/auths";

// Code existant...

// Create a pizza to be added to the menu.
router.post("/", authorize, isAdmin, (req, res) => {
  const body: unknown = req.body;
  if (
    !body ||
    typeof body !== "object" ||
    !("title" in body) ||
    !("content" in body) ||
    typeof body.title !== "string" ||
    typeof body.content !== "string" ||
    !body.title.trim() ||
    !body.content.trim()
  ) {
    return res.sendStatus(400);
  }

  const { title, content } = body as NewPizza;

  const addedPizza = createPizza({ title, content });

  return res.json(addedPizza);
});
```

Ainsi, nous avons juste fait l'appel de deux fonctions middleware pour v√©rifier :
- **que l'utilisateur est authentifi√©** via **`authorize`** ; si tout est OK au niveau du token fournit par l'application cliente, **`authorize`** fait appel via **`next()`** √† la prochaine fonction middleware. Dans ce cas-ci, c'est **`isAdmin`**. S'il y a un probl√®me, **`authorize`** termine le traitement de la requ√™te en envoyant un code d'erreur au client et les prochaines fonctions middleware (**`isAdmin`**, puis la fonction **`arrow`**) ne sont pas ex√©cut√©es.
- **que l'utilisateur est admin** via **`isAdmin`** ; si tout est OK, que l'utilisateur authentifi√© est l'admin, **`isAdmin`** fait appel via **`next()`** √† la prochaine fonction middleware. Dans ce cas-ci, c'est la fonction **`arrow`** qui appelle l'op√©ration demand√©e pour cr√©er la pizza : **`createPizza`**. Si l'utilisateur authentifi√© n'est pas l'admin, alors **`isAdmin`** termine le traitement en envoyant un code d'erreur au client et la fonction traitant de l'op√©ration de cr√©ation n'est pas ex√©cut√©e.

Comment pouvons-nous tester l'op√©ration de cr√©ation d'une pizza ? Via REST Client.
Tentons le coup √† l'aide de cette requ√™te (elle est d√©j√† pr√©sente dans **`/REST Client/pizzas.http`**) :
```http
POST {{baseUrl}}/pizzas
Content-Type: application/json

{
    "title":"Magic Green",
    "content":"Epinards, Brocolis, Olives vertes, Basilic"
}
```

Apr√®s avoir ex√©cut√© cette requ√™te, vous devriez avoir re√ßu un status code **`401 Unauthorized`**.
C'est normal, comme nous n'avons pas envoy√© de token, nous ne pouvons donc pas √™tre autoris√©.  
Au prochain point nous allons voir comment utiliser REST Client pour sauvegarder de l'information, comme un token, suite √† une requ√™te vers une API.

# <InternalPageTitle> Client REST avec JWT </InternalPageTitle>

Pr√©c√©demment, nous avons appris √† utiliser REST Client, l'extension de VS Code, pour faire des requ√™tes vers des API.

Voici quelques notions suppl√©mentaire pour utiliser REST Client avec des **`JWT`** :
- Il est possible de cr√©er des **`Request Variables`** afin de **r√©cup√©rer la r√©ponse** associ√©e 
√† une requ√™te au sein d'une variable.
- On va donc pouvoir r√©cup√©rer le token, suite √† une requ√™te d'authentification, 
au sein d'une **`Request Variable`**, pour ensuite fournir ce token dans le **`Authorization header`** de toutes les requ√™tes demandant une autorisation JWT.

Si vous souhaitez plus d'infos sur les **`Request Variables`**, vous pouvez consulter la [documentation de REST Client](https://github.com/Huachao/vscode-restclient#request-variables) [[R.55]](/references/#r55).

Voici comment mettre √† jour le script **`/REST Client/pizzas.http`** pour cr√©er une pizza en passant le token de l'utilisateur **`admin`** :

```http
### Create a pizza by using the admin account
#### First login as the admin
##### Define a request variable named admin :
# @name admin
POST {{baseUrl}}/auths/login
Content-Type: application/json

{
    "username":"admin",
    "password":"admin"
}

#### Create a pizza with the admin token
POST {{baseUrl}}/pizzas
Content-Type: application/json
Authorization: {{admin.response.body.token}}

{
    "title":"Magic Green",
    "content":"Epinards, Brocolis, Olives vertes, Basilic"
}
```

Pour tester l'op√©ration de cr√©ation de pizza, veuillez d'abord ex√©cuter la premi√®re requ√™te, puis la seconde donn√©e ci-dessus.

A ce stade-ci, il serait aussi int√©ressant de tester certains cas d'erreurs associ√©s aux tokens. Veuillez compl√©ter le script **`/REST Client/pizzas.http`** avec :
```http
### 1. Create a pizza without a token
POST {{baseUrl}}/pizzas
Content-Type: application/json

{
    "title":"Magic Green",
    "content":"Epinards, Brocolis, Olives vertes, Basilic"
}

### 2. Create a pizza without being the admin, use manager account
#### 2.1 First login as the manager
##### 2.1.1 Define a request variable nammed manager
# @name manager
POST {{baseUrl}}/auths/login
Content-Type: application/json

{
    "username":"manager",
    "password":"manager"
}

##### 2.1.2 Define a file variable to simplify the access to the token of manager
@managerToken = {{manager.response.body.token}}

#### 2.2 Try to create a pizza with the manager token
POST {{baseUrl}}/pizzas
Content-Type: application/json
Authorization: {{managerToken}}

{
    "title":"Magic Green",
    "content":"Epinards, Brocolis, Olives vertes, Basilic"
}
```

Nous voyons qu'√† l'aide de REST Client, nous pouvons utiliser une **`File Variable`** pour allouer une partie de la r√©ponse faite √† une requ√™te.  
Dans ce cas, on peut faire appel √† l'API en passant le token via la **`File Variable`** nomm√© **`managerToken`** (code associ√© : **`Authorization: {{managerToken}}`**) au lieu d'utiliser une partie seulement de la **`Request Variable`** nomm√©e **`manager`** (code possible : **`Authorization: {{manager.response.body.token}}`**).  
Cela permet de cr√©er des requ√™tes plus concises.

# <InternalPageTitle> Protection des op√©rations d'√©criture d'une API </InternalPageTitle>

Veuillez mettre √† jour votre RESTful API g√©rant les pizzas afin que toutes les op√©rations d'√©criture soient prot√©g√©es par une autorisation JWT, n'autorisant que l'utilisateur **admin**.

Voici le code √† mettre √† jour dans **`/routes/pizzas`** pour correctement autoriser les op√©rations de suppression et de modification sur des ressources de type "pizzas":
```js highlighting="2,11"
// Delete a pizza from the menu based on its id
router.delete("/:id", authorize, isAdmin, (req, res) => {
  const id = Number(req.params.id);
  const deletedPizza = deletePizza(id);
  if (!deletedPizza) return res.sendStatus(404);

  return res.json(deletedPizza);
});

// Update a pizza based on its id and new values for its parameters
router.patch("/:id", authorize, isAdmin, (req, res) => {
  const body: unknown = req.body;
  if (
    !body ||
    typeof body !== "object" ||
    ("title" in body &&
      (typeof body.title !== "string" || !body.title.trim())) ||
    ("content" in body &&
      (typeof body.content !== "string" || !body.content.trim()))
  ) {
    return res.sendStatus(400);
  }

  const pizzaToUpdate: PizzaToUpdate = body;

  const id = Number(req.params.id);
  const updatedPizza = updatePizza(id, pizzaToUpdate);
  if (!updatedPizza) return res.sendStatus(404);

  return res.json(updatedPizza);
});
```

Pour vous assurer que les op√©rations de suppression et de modification sont bien fonctionnelles, veuillez mettre √† jour les requ√™tes associ√©es afin d'utiliser un token. Veuillez mettre √† jour **`/REST Client/pizzas.http`** en ajoutant ces lignes :

```http numbered highlighting="25,30"
### Delete pizza identified by 2 with the admin token
DELETE {{baseUrl}}/pizzas/2
Authorization: {{admin.response.body.token}}

### Update the pizza identified by 6 with the admin token
PATCH {{baseUrl}}/pizzas/6
Content-Type: application/json
Authorization: {{admin.response.body.token}}

{
    "title":"Magic Green 2"
}
```

Veuillez ex√©cutez les requ√™tes de type **DELETE** et de type **PATCH** afin de vous assurer que l'API est en ordre.

En cas de souci, vous pouvez utiliser le code du tutoriel [auths](https://github.com/e-vinci/ts-demos/tree/main/back/api/auths).

Si vous le souhaitez, vous pouvez aussi faire les modifications pour les ressources de type "drinks".

Veuillez mettre √† jour **`/routes/drinks`** pour ajouter l'appel aux fonctions middleware **`authorize`** et **`isAdmin`** pour les op√©rations de cr√©ation, suppression et de modification :

```ts numbered highlighting="1,25,34"
router.post("/", authorize, isAdmin, (req, res) => {
  const body: unknown = req.body;
  if (
    !body ||
    typeof body !== "object" ||
    !("title" in body) ||
    !("image" in body) ||
    !("volume" in body) ||
    !("price" in body) ||
    typeof body.title !== "string" ||
    typeof body.image !== "string" ||
    typeof body.volume !== "number" ||
    typeof body.price !== "number" ||
    !body.title.trim() ||
    !body.image.trim() ||
    body.volume <= 0 ||
    body.price <= 0
  ) {
    return res.sendStatus(400);
  }

  const { title, image, volume, price } = body as NewDrink;

  const newDrink = createOneDrink({ title, image, volume, price });
  return res.json(newDrink);
});

router.delete("/:id", authorize, isAdmin, (req, res) => {
  const id = Number(req.params.id);
  const deletedDrink = deleteOneDrink(id);
  if (!deletedDrink) {
    return res.sendStatus(404);
  }
  return res.json(deletedDrink);
});

router.patch("/:id", authorize, isAdmin, (req, res) => {
  const id = Number(req.params.id);

  const body: unknown = req.body;

  if (
    !body ||
    typeof body !== "object" ||
    ("title" in body &&
      (typeof body.title !== "string" || !body.title.trim())) ||
    ("image" in body &&
      (typeof body.image !== "string" || !body.image.trim())) ||
    ("volume" in body &&
      (typeof body.volume !== "number" || body.volume <= 0)) ||
    ("price" in body && (typeof body.price !== "number" || body.price <= 0))
  ) {
    return res.sendStatus(400);
  }

  const { title, image, volume, price }: Partial<NewDrink> = body;

  const updatedDrink = updateOneDrink(id, { title, image, volume, price });

  if (!updatedDrink) {
    return res.sendStatus(404);
  }

  return res.json(updatedDrink);
});
```

N'oubliez pas de faire l'import de **`authorize`** et **`isAdmin`** au d√©but du fichier **`/routes/drinks.ts`**.

Pour tester les op√©rations de cr√©ation, de suppression et de modification sur des ressources de type "drinks", veuillez mettre √† jour le script **`/REST Client/drinks.http`** :
  
```http numbered highlighting="12-20,25,38,49,55"
### Read all drinks with File variable
@baseUrl = http://localhost:3000
GET {{baseUrl}}/drinks

### Read a single drink
GET {{baseUrl}}/drinks/3

### Read all drinks cheaper or equal to 3 ‚Ç¨
GET {{baseUrl}}/drinks/?budget-max=3

### Create a drink
##### Define a request variable named admin :
# @name admin
POST {{baseUrl}}/auths/login
Content-Type: application/json

{
    "username":"admin",
    "password":"admin"
}

### Create a drink with the admin token
POST {{baseUrl}}/drinks
Content-Type: application/json
Authorization: {{admin.response.body.token}}

{
    "title":"Virgin Tonic",
    "image":"https://plus.unsplash.com/premium_photo-1668771899398-1cdd763f745e?q=80&w=1374&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D",
    "volume":0.25,
    "price":4.5    
}


### Try to create a drink with incomplete data
POST {{baseUrl}}/drinks
Content-Type: application/json
Authorization: {{admin.response.body.token}}


{
    "title":"Missing Data Drink",
    "volume":0.25,
    "price":4.5    
}

### Delete a drink
DELETE {{baseUrl}}/drinks/5
Authorization: {{admin.response.body.token}}


### Update a drink
PATCH {{baseUrl}}/drinks/3
Content-Type: application/json
Authorization: {{admin.response.body.token}}

{
    "title":"Citronnade"
}
```

# <InternalPageTitle> S√©curisation des passwords </InternalPageTitle>

Nous souhaitons maintenant assurer que les passwords enregistr√©s dans un support de donn√©es (un fichier ou une base de donn√©es) ne puissent pas √™tre r√©cup√©r√©s.

üëç Pour ce faire, il est recommand√© d'hacher les passwords avant de les enregistrer au niveau d'une API.

Afin de se prot√©ger contre les "hash attacks", on utilise du **salt** :
- un **salt** : c'est une donn√©e al√©atoire qui est utilis√© en entr√©e d'une fonction qui hache des donn√©es. Ainsi, si un hacker utilise une base de donn√©es de passwords hach√©s, il devra en plus trouver le bon **salt** pour que son attaque puisse fonctionner.
- **salt round** : nombre de fois que l'op√©ration de hachage est faite, rendant les attaques de force brute plus lente et donc difficile ; une valeur de **10** semble √™tre g√©n√©ralement raisonnable et recommand√©e. 

Pour hacher sous Node.js, nous utiliserons la librairie [bcrypt](https://www.npmjs.com/package/bcrypt).

Veuillez installer la librairie **`bcrypt`** et les types associ√©s √† bcrypt au sein de votre API **`auths`** :
```bash
npm i bcrypt 
npm i @types/bcrypt -D
```

En r√©sum√©, nous allons utiliser :
- la fonction asynchrone **`hash`** de **`bcrypt`** pour **hacher un password** ;
- la fonction asynchrone **`compare`** de **`bcrypt`** pour **comparer un password en clair √† un password hach√©** ; si le r√©sultat est positif, cela signifie que le password fournit pour un utilisateur correspond au password initial.

Nous pr√©f√©rons utiliser les librairies asynchrone afin que l'API reste disponible √† g√©rer des requ√™tes clientes et ne bloque pas celles-ci jusqu'√† la fin d'une op√©ration de **`bcrypt`** !

Veuillez effacer le fichier **`/data/users.json`** contenant les credentials d'utilisateurs o√π les passwords sont donn√©s en clair.

Nous allons maintenant mettre √† jour le service "users" pour utiliser **`bcrypt`**. Veuillez modifier **`/services/users.ts`** :
```ts numbered highlighting="2,10,18,22,25,28-29,45,48,52,76,79,87"
import jwt from "jsonwebtoken";
import bcrypt from "bcrypt";
import path from "node:path";
import { parse, serialize } from "../utils/json";
import { AuthenticatedUser, User } from "../types";

const jwtSecret = "ilovemypizza!";
const lifetimeJwt = 24 * 60 * 60 * 1000; // in ms : 24 * 60 * 60 * 1000 = 24h

const saltRounds = 10;

const jsonDbPath = path.join(__dirname, "/../data/users.json");

const defaultUsers: User[] = [
  {
    id: 1,
    username: "admin",
    password: bcrypt.hashSync("admin", saltRounds),
  },
];

async function login(
  username: string,
  password: string
): Promise<AuthenticatedUser | undefined> {
  const userFound = readOneUserFromUsername(username);
  if (!userFound) return undefined;
  const passwordMatch = await bcrypt.compare(password, userFound.password);
  if (!passwordMatch) return undefined;

  const token = jwt.sign(
    { username }, // session data added to the payload (payload : part 2 of a JWT)
    jwtSecret, // secret used for the signature (signature part 3 of a JWT)
    { expiresIn: lifetimeJwt } // lifetime of the JWT (added to the JWT payload)
  );

  const authenticatedUser: AuthenticatedUser = {
    username,
    token,
  };

  return authenticatedUser;
}

async function register(
  username: string,
  password: string
): Promise<AuthenticatedUser | undefined> {
  const userFound = readOneUserFromUsername(username);
  if (userFound) return undefined;

  await createOneUser(username, password);

  const token = jwt.sign(
    { username }, // session data added to the payload (payload : part 2 of a JWT)
    jwtSecret, // secret used for the signature (signature part 3 of a JWT)
    { expiresIn: lifetimeJwt } // lifetime of the JWT (added to the JWT payload)
  );

  const authenticatedUser: AuthenticatedUser = {
    username,
    token,
  };

  return authenticatedUser;
}

function readOneUserFromUsername(username: string) {
  const users = parse(jsonDbPath, defaultUsers);
  const userFound = users.find((user) => user.username === username);
  if (!userFound) return undefined;

  return userFound;
}

async function createOneUser(username: string, password: string) {
  const users = parse(jsonDbPath, defaultUsers);

  const hashedPassword = await bcrypt.hash(password, saltRounds);

  const nextId =
    users.reduce((acc, user) => (user.id > acc ? user.id : acc), 0) + 1;

  const createdUser: User = {
    id: nextId,
    username,
    password: hashedPassword,
  };

  users.push(createdUser);

  serialize(jsonDbPath, users);

  return createdUser;
}

export { login, register, readOneUserFromUsername };
```

Voici les modifications apport√©es :
- **pour cr√©er un password hach√©** : on utilise la fonction asynchrone **`hash`** pour cr√©er le password hach√©. D√®s lors, **`createOneUser`** devient asynchrone. De plus, comme **`createOneUser`** est devenue asynchrone, dans **`register`**, pour cha√Æner le traitement de cr√©ation du token, on met un **`await`** √† l'appel de **`createOneUser`**. Et comme un **`await`** est ajout√© au sein de **`register`**, il faut mettre un **`async`** √† la m√©thode **`register`**. Attention, du coup, comme **`register`** est devenue asynchrone, il faudra aussi bien cha√Æner les traitements o√π **`register`** est appel√©, dans le router **`auths`**. Notez aussi que nous avons chang√© le type de retour des fonctions asynchrones qui renvoient maintenant des **`Promise`**.
- **pour v√©rifier qu'un password en clair "match" √† un password hach√©** : on utilise la fonction asynchrone **`compare`** que l'on cha√Æne √† la cr√©ation du token √† l'aide de **`await`**. D√®s lors, la fonction **`login`** doit elle aussi √™tre d√©clar√©e **`async`**. Attention, du coup, comme `login` est devenue asynchrone, il faudra bien cha√Æner les traitements o√π **`login`** est appel√©, dans le router **`auths`**.
- **pour cr√©er l'utilisateur **`admin`** se trouvant dans les **`defaultUsers`** avec des credentials par d√©faut** : on souhaite indiquer comme **`password`** le password hach√© correspondant au password **`"admin"`**. Pour se simplifier la vie, on appelle la fonction synchrone **`hashSync`** (voir ligne 18). Bien √©videmment, dans une application robuste et s√©curis√©e, il est interdit de coder en dur ce genre de secrets dans les sources de notre application üòâ !

Afin de traiter des deux fonctions du service **`users`** qui sont devenues asynchrones, **`login`** et **`register`**, nous allons modifier le router **`/routes/auths`** :
```ts numbered highlighting="7,24,34,51"
import { Router } from "express";
import { PotentialUser } from "../types";
import { login, register } from "../services/users";
const router = Router();

/* Register a user */
router.post("/register", async (req, res) => {
  const body: unknown = req.body;
  if (
    !body ||
    typeof body !== "object" ||
    !("username" in body) ||
    !("password" in body) ||
    typeof body.username !== "string" ||
    typeof body.password !== "string" ||
    !body.username.trim() ||
    !body.password.trim()
  ) {
    return res.sendStatus(400);
  }

  const { username, password } = body as PotentialUser;

  const authenticatedUser = await register(username, password);

  if (!authenticatedUser) {
    return res.sendStatus(409);
  }

  return res.json(authenticatedUser);
});

/* Login a user */
router.post("/login", async (req, res) => {
  const body: unknown = req.body;
  if (
    !body ||
    typeof body !== "object" ||
    !("username" in body) ||
    !("password" in body) ||
    typeof body.username !== "string" ||
    typeof body.password !== "string" ||
    !body.username.trim() ||
    !body.password.trim()
  ) {
    return res.sendStatus(400);
  }

  const { username, password } = body as PotentialUser;

  const authenticatedUser = await login(username, password);

  if (!authenticatedUser) {
    return res.sendStatus(401);
  }

  return res.json(authenticatedUser);
});

export default router;
```

Nous avons simplement cha√Æn√© les r√©ponses √† faire au client seulement une fois les op√©rations **`register`** et **`login`** termin√©es. Pour ce faire, nous avons pr√©c√©d√© le nom de ces m√©thodes par **`await`**. Nous avons donc du ajouter **`async`** aux fonctions middleware s'occupant des routes **`POST /auths/register`** et **`POST /auths/login`**.

Veuillez v√©rifier que votre application fonctionne correctement.  
Via l'IHM, veuillez faire un register d'un nouvel utilisateur.  
Au niveau de l'API, allez voir le contenu du nouveau fichier **`/data/users.json`**. Les passwords devraient maintenant √™tre hach√©s, comme par exemple :

```json
[
  {
    "id": 1,
    "username": "admin",
    "password": "$2b$10$RioLKlPFyYFEhv/46gR7dufDkke07eDpWH9tBt/A4Z9tJh0oJnnf2"
  },
  {
    "id": 2,
    "username": "manager",
    "password": "$2b$10$NZZ1zxOPdby6gl4Dw8K0Q.v4ZRWTbh1Ta7qcYzH5G4SrO5z71H0kO"
  }
]
```

En cas de souci, vous pouvez utiliser le code du tutoriel [auths](https://github.com/e-vinci/ts-demos/tree/main/back/api/auths).

# <InternalPageTitle> Exercice 3.1 : Authentification & autorisation d'op√©rations </InternalPageTitle>

Vous allez s√©curiser la RESTful API de **myMovies**.

Veuillez cr√©er un nouveau projet ans votre repo git dans **`/exercises/3.1`** en clonant le boilerplate du cours offrant l'authentification et l'autorisation JWT : [jwt-ts-api-boilerplate](https://github.com/e-vinci/jwt-ts-api-boilerplate). Dans ce boilerplate, vous trouverez d√©j√† un service **`users`** qui g√®re les utilisateurs, ainsi que des routes pour les op√©rations de **`login`** et de **`register`**.

Dans ce projet, dans un premier temps, sans utiliser JWT, veuillez int√©grer le code utile de vos op√©rations (router & service de **`films`**, requ√™tes HTTP pour tester les op√©rations sur les **`films`**) de votre **`/exercises/1.8`**. 

Une fois que vous op√©rations sur les films sont bien int√©gr√©es, veuillez planifier de nouvelles op√©rations et quelles op√©rations prot√©ger par JWT. 

Pour les nouvelles op√©rations, vous devez pouvoir ajouter des commentaires sur un film et lire tous les commentaires associ√©s √† un film.

Pour la protection des op√©rations, vous ne devez pas g√©rer de r√¥les, mais simplement v√©rifier que l'utilisateur est authentifi√©.

Veuillez d'abord identifier toutes les op√©rations mises √† disposition par votre API (y compris l'authentification), ainsi que si celles-ci sont prot√©g√©es par JWT, au sein du fichier **`README.md`** (fichier Markdown) de votre projet. Voici un exemple de comment nous vous recommandons de documenter votre API, sous forme de tableau : 

| URI | M√©thode HTTP | Auths? | Op√©ration |
|---|---|---|---|
| **`films`** | GET | Non | READ ALL : Lire toutes les ressources de la collection |
| ... | ... | ... | ... |
| **`comments`** | GET | JWT | READ ALL FILTERED : Lire toutes les ressources de la collection |
| **`comments`** | POST | JWT | CREATE ONE : Cr√©er une ressource bas√©e sur les donn√©es de la requ√™te |
| ... | ... | ... | ... |

<br/>

Une fois la documentation de votre API pr√™te, vous pouvez commencer par prot√©ger les op√©rations existantes et les tester avec Rest Client.

Une fois que tout est fonctionnel, vous pouvez impl√©menter les nouvelles op√©rations de gestion de commentaires et les prot√©ger par JWT.

Veuillez v√©rifier que vos op√©rations sont bien prot√©g√©es et fonctionnelles en les testant avec Rest Client.

Quand un prototype d'api est finalis√© et test√©, veuillez faire un **`commit`** de votre code avec comme message : **`new: ex3.1`**.

#### ü§ù Tips
Comment cr√©er un tableau dans un fichier Markdown (pour **`README.md`**) ?  
Voici deux options :
- Soit vous utiliser des **`|`** pour d√©limiter les cellules et des **`|---|`** pour s√©parer les headers du corps du tableau. 
Voici le Markdown de l'exemple donn√© ci-dessus :
```text
| URI | M√©thode HTTP | Auths? | Op√©ration |
|---|---|---|---|
| **`films`** | GET | Non | READ ALL : Lire toutes les ressources de la collection |
| ... | ... | ... | ... |
| **`comments`** | GET | JWT | READ ALL FILTERED : Lire toutes les ressources de la collection |
| **`comments`** | POST | JWT | CREATE ONE : Cr√©er une ressource bas√©e sur les donn√©es de la requ√™te |
| ... | ... | ... | ... |
```
- Soit c'est simplement un tableau HTML (`<table>`).

# <InternalPageTitle> üç¨ Exercice 3.2 : une autre API s√©curis√©e </InternalPageTitle>

Cet exercice est optionnel, n'h√©sitez pas √† le faire si vous avez du temps.

Peut-√™tre avez-vous d√©j√† entendu parler de cette mode montante dans le Web qu'est la JAMstack ?

Nous souhaitons d√©velopper un Headless CMS, c'est-√†-dire un outil permettant de cr√©er du contenu, tr√®s souvent utilis√© dans le cadre de sites JAMstack.

Un Headless CMS fournira une interface web pour cr√©er du contenu (ou des donn√©es), ainsi qu'une RESTful API mettant √† disposition ce contenu.

L'Headless CMS que nous souhaitons d√©velopper doit permettre de cr√©er le contenu associ√© √† un blog.

Un blog sera structur√© en pages. Une page aura un id, un titre, un URI, un contenu, un auteur ainsi qu'un statut de publication.

Le statut de publication d'une page peut actuellement prendre comme valeur :
- ¬´ hidden ¬ª
- ¬´ published ¬ª

Seul un utilisateur authentifi√© pourra lire, cr√©er, modifier ou supprimer des pages.

La modification d'une page, tout comme la suppression d'une page ne pourra se faire que par son auteur.

L'ajout ou la modification d'une page ne sera possible que si le statut de publication donn√© correspond √† un des deux statuts actuels (¬´ hidden ou ¬´ published ¬ª). Sinon un message d'erreur devra √™tre renvoy√©.

La lecture d'une page, ou de toutes les pages, pourra √™tre r√©alis√©e par n'importe quel utilisateur authentifi√© pour les pages dont le statut vaut ¬´ published ¬ª.

Pour les pages dont le statut vaut ¬´ hidden ¬ª, seul leur auteur authentifi√© pourra les lire.

Veuillez cr√©er un nouveau projet dans votre repo git dans **`/exercises/3.2`** sur base du boilerplate : [jwt-ts-api-boilerplate](https://github.com/e-vinci/jwt-ts-api-boilerplate).

‚ö° Si vous avez fait un clone du boilerplate, attention au Git dans le Git, n'oubliez pas de supprimer le dossier **`.git`** pr√©sent dans votre nouveau projet.

Puis, veuillez formaliser les op√©rations associ√©es √† vos RESTful APIs sous forme d'un tableau dans un fichier **`README.md`**.

Veuillez tester toutes les m√©thodes offertes par votre application √† l'aide du client HTTP de REST Client.

Veuillez faire un **`commit`** de votre code avec le message suivant : **`new: ex3.2`**.

## üç¨ Bonus 
- N¬∞1 : vous souhaitez rapidement d√©couvrir les principes d'une architecture Web associ√©e √† la JAMstack ? https://jamstack.wtf/
- N¬∞2 : si vous souhaitez d√©couvrir le format Markdown, notamment tr√®s souvent utilis√© dans certains sites JAMstack (source des donn√©es pour certains Headless CMS) : https://www.markdownguide.org/basic-syntax/


## üç¨ Challenges
- N¬∞1 : Modifiez les autorisations au niveau des op√©rations de lecture : la lecture d'une page, ou de toutes les pages, pourra √™tre r√©alis√©e par n'importe quel utilisateur anonyme ou authentifi√© pour les pages dont le statut vaut ¬´ published ¬ª. Pour les pages dont le statut vaut ¬´ hidden ¬ª, seul leur auteur authentifi√© pourra les lire.
N¬∞2 : lorsqu'un utilisateur tente d'effacer ou modifier une page dont il n'est pas l'auteur, renvoyez un code d'erreur appropri√© au client.
N¬∞3 : Si √ßa n'est pas d√©j√† fait, pensez √† ne pas renvoyer les passwords des utilisateurs dans les r√©ponses de votre API.

# <InternalPageTitle> üç¨ Authentification & autorisation JWT √† l'aide de cookies </InternalPageTitle>

## Pourquoi utiliser l'autorisation JWT √† l'aide de cookies ?

Nous avons vu une fa√ßon de g√©rer des token JWT, sans g√©rer de cookies.

Cela impose aux client de sauvegarder les tokens et de les envoyer dans un **`authorization header`** lorsqu'ils souhaitent acc√©der √† une op√©ration prot√©g√©e.

Il est aussi possible d'int√©grer les tokens au sein de cookies. Dans ce cas-l√†, les clients qui ont re√ßu un cookie de l'API renverront automatiquement ce cookie (m√©canisme des browsers). Les tokens JWT voyageront automatiquement gr√¢ce au m√©canisme de cookies.

üí≠ Faut-il mieux int√©grer les token JWT dans des cookies ou pas ?  
Il est difficile de donner une r√©ponse √† cette question. Chaque approche a des avantages et des inconv√©nients. Ce qui devrait √™tre le point d'attention, c'est la s√©curit√©. Et dans les deux cas, on atteint un niveau de s√©curit√© raisonnable.
Pour ce cours, nous avons choisi la fa√ßon la plus moderne, en laissant au client le choix de sauvegarder les token dans le web storage (nous allons voir √ßa tout prochainement pour l'aspect frontend).  
Notons que le cas le plus s√ªr est probablement d'avoir deux types de token, ce qui est d'une complexit√© qui d√©passe les objectifs de ce cours. N√©anmoins, pour votre info, les m√©canismes d'authentification comme OAuth (authorization de MS Azure) & OpenID Connect (authentification de MS Azure) g√®re deux types de token :
- un token √† dur√©e de vie courte qui sera enregistr√© en m√©moire vive au niveau du client (access token) ou dans le web storage.
- un token √† dur√©e de vie longue qui sera enregistr√© par le client dans un cookie (refresh token, notamment utilis√© par l'API pour cr√©er un nouvel access token).

## Un cookie, c'est quoi ?

Un **cookie** repr√©sente des donn√©es qu'un serveur envoie √† un browser.  
Le browser peut sauver ce cookie. Pour chaque requ√™te faite au serveur sur la m√™me origine (que l'origine o√π le cookie a √©t√© re√ßu), le cookie sera automatiquement envoy√© au serveur.

Il fut un temps o√π les cookies √©taient utilis√©s comme un m√©canisme g√©n√©ral de stockage de donn√©es c√¥t√© client. 

üëç Actuellement, si les cookies sont utilis√©s pour sauvegarder les donn√©es de session, il faut se prot√©ger contre les attaques XSS et rendre les cookies inaccessibles au JavaScript : on utilise donc les cookies **`HttpOnly`** qui sont inaccessibles √† la **`Document.cookie API`**. 

Pour la suite, on va donc voir :
- comment utiliser Express pour cr√©er des cookies au niveau d'une API ;
- comment rendre ces cookies inaccessibles aux attaques XSS en configurant **`HttpOnly`**.

## Impl√©mentation de l'authentification & l'autorisation JWT au sein de cookies

### Intro

Nous allons donc cr√©er une nouvelle version de l'API sauvegardant le token d'un utilisateur au sein d'un cookie, ainsi que son username, sans que ces infos soient accessible au JS c√¥t√© client.

Pour ce faire nous allons utiliser la librairie [cookie-session](https://github.com/expressjs/cookie-session) qui permet d'enregistrer des donn√©es de session dans des cookies.

Veuillez cr√©er un nouveau projet nomm√© **`/back/api/cookies`** sur base d'un copi√©/coll√© du projet [auths](https://github.com/e-vinci/ts-demos/tree/main/back/api/auths)).

Veuillez installer la librairie **`cookie-session`** au sein de votre nouveau projet **`cookies`** et les types associ√©s (pour TypeScript):
```bash
npm i cookie-session
npm install @types/cookie-session -D
```

### Utilisation de la fonction middleware **`cookieSession`**

Veuillez mettre √† jour **`/app.ts`** pour mettre en place la gestion de cookies :

```ts numbered highlighting="2,11-20"
import express, { ErrorRequestHandler } from "express";
import cookieSession from "cookie-session";

import usersRouter from "./routes/users";
import pizzaRouter from "./routes/pizzas";
import drinkRouter from "./routes/drinks";
import authsRouter from "./routes/auths";

const app = express();

const expiryDateIn3Months = new Date(Date.now() + 1000 * 60 * 60 * 24 * 30 * 3);
const cookieSecreteKey = 'YouWouldnot!not!like!mypizza';
app.use(
  cookieSession({
    name: 'user',
    keys: [cookieSecreteKey],  
    httpOnly: true,
    expires: expiryDateIn3Months,
  }),
);

app.use((_req, _res, next) => {
  console.log(
    "Time:",
    new Date().toLocaleString("fr-FR", { timeZone: "Europe/Brussels" })
  );
  next();
});

app.use(express.json());
app.use(express.urlencoded({ extended: false }));

app.use("/users", usersRouter);
app.use("/pizzas", pizzaRouter);
app.use("/drinks", drinkRouter);
app.use("/auths", authsRouter);

const errorHandler: ErrorRequestHandler = (err, _req, res, _next) => {
  console.error(err.stack);
  return res.status(500).send("Something broke!");
};

app.use(errorHandler);
export default app;
```

Nous avons donc bien indiqu√© que le cookie est inaccessible au JS via : **`httpOnly: true`**.

Nous avons fait en sorte que le cookie soit sign√© via la cl√© **`cookieSecreteKey`**.  
Le m√©canisme de signature correspond √† ce qui a √©t√© vu dans le cadre des tokens JWT.  
Ainsi, si un cookie venait √™tre modifi√© par un utilisateur, lors de la v√©rification du cookie, cela sera automatiquement d√©tect√© par la fonction middleware **`cookieSession`** et la session ne sera pas cr√©√©e.

Pour info, la fonction middleware **`cookieSession`** va cr√©er deux cookies :
- un cookie portant comme nom la valeur de **`name`** ; il est encod√© en base64. N'h√©sitez pas √† vous amuser √† d√©coder un cookie g√©n√©r√© par **`cookieSession`** sur [base64decode](https://www.base64decode.org/).
- un cookie portant comme nom la valeur de **`name`** + **`.sig`** : c'est la signature qui pr√©vient contre le "tempering" (acte intentionnel mais non autoris√© qui am√®ne √† la modification d'un syst√®me ou de donn√©es).

### Lecture et ajout de donn√©es de session via `req.session`

Pour cr√©er des donn√©es de session, il suffit de simplement les ajouter √† l'objet **`req.session`**.

Dans le cadre de la RESTful API g√©rant les pizzas, cela est fait lors d'une op√©ration de type **`register`** ou **`login`**.

Veuillez mettre √† jour le router **`/routes/auths.ts`** :

```ts numbered highlighting="19,21,37,39,43-46,48-57"
import { Request, Router } from "express";
import { AuthenticatedUser, PotentialUser } from "../types";
import { login, register } from "../services/users";
const router = Router();

/* Register a user */
router.post("/register", async (req, res) => {
  const body: unknown = req.body;
  if (
    !body ||
    typeof body !== "object" ||
    !("username" in body) ||
    !("password" in body) ||
    typeof body.username !== "string" ||
    typeof body.password !== "string" ||
    !body.username.trim() ||
    !body.password.trim()
  ) {
    return res.sendStatus(400);
  }

  const { username, password } = body as PotentialUser;

  const authenticatedUser = await register(username, password);

  if (!authenticatedUser) {
    return res.sendStatus(409);
  }

  createCookieSessionData(req, authenticatedUser);

  return res.json({ username: authenticatedUser.username });
});

/* Login a user */
router.post("/login", async (req, res) => {
  const body: unknown = req.body;
  if (
    !body ||
    typeof body !== "object" ||
    !("username" in body) ||
    !("password" in body) ||
    typeof body.username !== "string" ||
    typeof body.password !== "string" ||
    !body.username.trim() ||
    !body.password.trim()
  ) {
    return res.sendStatus(400);
  }

  const { username, password } = body as PotentialUser;

  const authenticatedUser = await login(username, password);

  if (!authenticatedUser) {
    return res.sendStatus(401);
  }

  createCookieSessionData(req, authenticatedUser);

  return res.json({ username: authenticatedUser.username });
});

/* Logout a user */
router.get("/logout", (req, res) => {
  req.session = null;
  return res.sendStatus(200);
});

function createCookieSessionData(
  req: Request,
  authenticatedUser: AuthenticatedUser
) {
  if (!req.session) {
    return;
  }
  req.session.username = authenticatedUser.username;
  req.session.token = authenticatedUser.token;
}

export default router;
```

Dans le code ci-dessus, nous pr√©parons les donn√©es de session qui seront √©crites dans le cookie √† l'aide de l'objet **`req.session`**.  
Lorsque nous renvoyons du JSON aux clients, nous ne renvoyons plus le token, mais juste le username de l'utilisateur. L'application cliente, le browser, pourra utiliser cette info pour afficher le nom de l'utilisateur. Pour rappel, le browser n'a pas acc√®s, via le JS, √† l'info se trouvant dans le cookie.

Quand nous g√©rons une session via des cookies, il n'est pas √©vident de bien clore une session. Nous avons cr√©√© une nouvelle op√©ration de type **`GET /auths/logout`** qui permet d'effacer les donn√©es de session d'un utilisateur.

Il nous reste √† changer le m√©canisme d'autorisation.
Les tokens ne seront plus re√ßus via un authorization header, mais via un cookie.  
Nous allons donc mettre √† jour le middleware **`/utils/authorize`** :

```ts numbered highlighting="13-16"
import jwt from "jsonwebtoken";
import { readOneUserFromUsername } from "../services/users";
import { NextFunction, RequestHandler, Response } from "express";
import { AuthenticatedRequest, JwtPayload, User } from "../types";

const jwtSecret = "ilovemypizza!";

const authorize = (
  req: AuthenticatedRequest,
  res: Response,
  next: NextFunction
) => {
  if (!req.session) {
    return res.sendStatus(401);
  }
  const { token } = req.session;
  if (!token) {
    return res.sendStatus(401);
  }

  try {
    const decoded = jwt.verify(token, jwtSecret) as JwtPayload;
    const { username } = decoded;

    const existingUser = readOneUserFromUsername(username);

    if (!existingUser) {
      return res.sendStatus(401);
    }

    req.user = existingUser; // request.user object is available in all other middleware functions
    return next();
  } catch (err) {
    console.error("authorize: ", err);
    return res.sendStatus(401);
  }
};

const isAdmin: RequestHandler = (req: AuthenticatedRequest, res, next) => {
  const { username } = req.user as User;

  if (username !== "admin") {
    return res.sendStatus(403);
  }
  return next();
};

export { authorize, isAdmin };
```

# <InternalPageTitle> üç¨ Test via REST Client d'une RESTful API attendant des cookies </InternalPageTitle>

Il nous reste √† tester nos requ√™tes via REST Client.

Il n'y a pas de nouvelles notions √† apprendre pour utiliser REST Client avec des cookies : le comportement par d√©faut de REST Client, lorsqu'un cookie est renvoy√© dans une r√©ponse, est d'inclure ce cookie dans chaque requ√™te vers la m√™me origine.

D√®s lors, pour tester l'API, il suffit d'enlever tous les authorization headers et de rajouter une requ√™te pour tester l'effacement d'une session.

Veuillez tester les requ√™tes √† l'aide de **`/REST Client/pizzas.http`** :

```http
######### NORMAL OPERATION  ###########

### Read all pizzas
GET http://localhost:3000/pizzas

### Read all pizzas with File variable
@baseUrl = http://localhost:3000
GET {{baseUrl}}/pizzas

### Read all pizzas sorted by title (ascending)
GET {{baseUrl}}/pizzas/?order=+title

### Read all pizzas sorted by title (descending)
GET {{baseUrl}}/pizzas/?order=-title

### Read pizza identified by 2
GET {{baseUrl}}/pizzas/2

### Create a pizza by using the admin account
#### First login as the admin
POST {{baseUrl}}/auths/login
Content-Type: application/json

{
    "username":"admin",
    "password":"admin"
}

#### Create a pizza with the admin token
POST {{baseUrl}}/pizzas
Content-Type: application/json

{
    "title":"Magic Green",
    "content":"Epinards, Brocolis, Olives vertes, Basilic"
}

### Delete pizza identified by 2 with the admin token
DELETE {{baseUrl}}/pizzas/2

### Update the pizza identified by 6 with the admin token
PATCH {{baseUrl}}/pizzas/6
Content-Type: application/json

{
    "title":"Magic Green 2"
}


######### ERROR OPERATION  ###########

### 1. Create a pizza without a token
POST {{baseUrl}}/pizzas
Content-Type: application/json

{
    "title":"Magic Green",
    "content":"Epinards, Brocolis, Olives vertes, Basilic"
}

### 2. Create a pizza without being the admin, use manager account
#### 2.1 First login as the manager
POST {{baseUrl}}/auths/login
Content-Type: application/json

{
    "username":"manager",
    "password":"manager"
}

#### 2.2 Try to create a pizza with the manager token
POST {{baseUrl}}/pizzas
Content-Type: application/json

{
    "title":"Magic Green",
    "content":"Epinards, Brocolis, Olives vertes, Basilic"
}

### Read pizza which does not exists
GET {{baseUrl}}/pizzas/100

### Create a pizza which lacks a property
POST {{baseUrl}}/pizzas
Content-Type: application/json

{
    "content":"Epinards, Brocolis, Olives vertes, Basilic"
}

### Create a pizza without info for a property
POST {{baseUrl}}/pizzas
Content-Type: application/json

{
    "title":"",
    "content":"Epinards, Brocolis, Olives vertes, Basilic"
}

### Update for a pizza which does not exist
PATCH {{baseUrl}}/pizzas/200
Content-Type: application/json

{
    "title":"Magic Green 2"
}

### Update for a pizza which does not provide any info for a property
PATCH {{baseUrl}}/pizzas/1

Content-Type: application/json

{
    "title":"Magic Green 2",
    "content":""
}
```

Veuillez mettre √† jour **`/REST Client/auths.http`** pour tester **`GET /auths/logout`** :
```http
### Logout any user
GET {{baseUrl}}/auths/logout
```

Pour ajouter une pizza, il suffit juste :
1. De loguer l'admin.
2. De cr√©er une nouvelle pizza ; le cookie est automatiquement envoy√©.

Admettons que vous souhaitez tester l'ajout d'une pizza sans envoyer de token :
1. Lancez l'op√©ration de logout (**`GET /auths/logout`**) ; le cookie renvoy√© ne contient pas de donn√©es de session ;
2. Tentez la cr√©ation d'une pizza qui renverra un code **`401 Unauthorized`**.

En cas de souci, vous pouvez utiliser le code du tutoriel [cookies](https://github.com/e-vinci/ts-demos/tree/main/back/api/cookies).